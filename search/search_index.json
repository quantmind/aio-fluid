{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Aio Fluid</p> <p>Async utilities for backend python services</p> <p> </p>"},{"location":"#installation","title":"Installation","text":"<p>This is a simple python package you can install via pip:</p> <pre><code>pip install aio-fluid\n</code></pre>"},{"location":"scheduler/","title":"Distributed Task Producer/Consumer","text":"<p>This module has a lightweight implementation of a distributed task producer (TaskScheduler) and consumer (TaskConsumer). The middleware for distributing tasks can be configured via the Broker interface. A redis broker is provided for convenience.</p>"},{"location":"scheduler/#tasks","title":"Tasks","text":"<p>Tasks are standard python async functions decorated with the <code>task</code> decorator.</p> <pre><code>from fluid.scheduler import task, TaskRun\n\n@task\nasync def say_hi(ctx: TaskRun):\n    return \"Hi!\"\n</code></pre> <p>There are two types of tasks implemented</p> <ul> <li>Simple concurrent tasks - they run concurrently with the task consumer - thy must be IO type tasks (no heavy CPU bound operations)</li> </ul> <pre><code>  from fluid.scheduler import task, TaskRun\n\n  @task\n  async def fecth_data(ctx: TaskRun):\n      # fetch data\n      data = await http_cli.get(\"https://...\")\n      data_id = await datastore_cli.stote(data)\n      # trigger another task\n      ctx.task_manager.queue(\"heavy_calculation\", data_id=data_id)\n</code></pre> <ul> <li>CPU bound tasks - they run on a subprocess</li> </ul> <p>```python     from fluid.scheduler import task, TaskRun</p> <pre><code>@task(cpu_bound=True)\nasync def heavy_calculation(ctx: TaskRun):\n    # perform some heavy calculation\n    data = await datastore_cli.get(ctx.params[\"data_id\"])\n    ...\n    # trigger another task\n    ctx.task_manager.queue(\"fetch_data\")\n</code></pre> <p>```</p> <p>Both tasks can be periodically scheduled via the <code>schedule</code> keyword argument:</p> <pre><code>from datetime import timedelta\nfrom fluid.scheduler import task, TaskContext, every\n\n@task(schedule=every(timedelta(seconds=1)))\nasync def scheduled(context: TaskContext) -&gt; str:\n    await asyncio.sleep(0.1)\n    return \"OK\"\n</code></pre>"},{"location":"scheduler/#broker","title":"Broker","text":"<p>A Task broker needs to implement three abstract methods</p> <pre><code>  @abstractmethod\n  async def queue_task(self, queued_task: QueuedTask) -&gt; TaskRun:\n      \"\"\"Queue a task\"\"\"\n\n  @abstractmethod\n  async def get_task_run(self) -&gt; Optional[TaskRun]:\n      \"\"\"Get a Task run from the task queue\"\"\"\n\n  @abstractmethod\n  async def queue_length(self) -&gt; Dict[str, int]:\n      \"\"\"Length of task queues\"\"\"\n</code></pre> <p>The library ships a Redis broker for convenience.</p> <pre><code>from fluid.scheduler import Broker\n\nredis_broker = Broker.from_url(\"redis://localhost:6349\")\n</code></pre>"},{"location":"reference/","title":"Reference - Code API","text":"<p>Here's the reference or code API, the classes, functions, parameters, attributes, and all the Aio Fluid parts you can use in your applications.</p> <p>If you want to learn Aio Fluid you are much better off reading the Api Fluid Tutorial.</p>"},{"location":"reference/task_broker/","title":"Task Broker","text":"<p>It can be imported from <code>fluid.scheduler</code>:</p> <pre><code>from fastapi.scheduler import TaskBroker\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker","title":"fluid.scheduler.TaskBroker","text":"<pre><code>TaskBroker(url)\n</code></pre> <p>               Bases: <code>ABC</code></p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>def __init__(self, url: URL) -&gt; None:\n    self.url: URL = url\n    self.registry: TaskRegistry = TaskRegistry()\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url = url\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.registry","title":"registry  <code>instance-attribute</code>","text":"<pre><code>registry = TaskRegistry()\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.task_queue_names","title":"task_queue_names  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>task_queue_names\n</code></pre> <p>Names of the task queues</p>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.queue_task","title":"queue_task  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>queue_task(task_run)\n</code></pre> <p>Queue a task</p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>@abstractmethod\nasync def queue_task(self, task_run: TaskRun) -&gt; None:\n    \"\"\"Queue a task\"\"\"\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.get_task_run","title":"get_task_run  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get_task_run(task_manager)\n</code></pre> <p>Get a Task run from the task queue</p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>@abstractmethod\nasync def get_task_run(self, task_manager: TaskManager) -&gt; TaskRun | None:\n    \"\"\"Get a Task run from the task queue\"\"\"\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.queue_length","title":"queue_length  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>queue_length()\n</code></pre> <p>Length of task queues</p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>@abstractmethod\nasync def queue_length(self) -&gt; dict[str, int]:\n    \"\"\"Length of task queues\"\"\"\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.get_tasks_info","title":"get_tasks_info  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get_tasks_info(*task_names)\n</code></pre> <p>List of TaskInfo objects</p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>@abstractmethod\nasync def get_tasks_info(self, *task_names: str) -&gt; list[TaskInfo]:\n    \"\"\"List of TaskInfo objects\"\"\"\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.update_task","title":"update_task  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>update_task(task, params)\n</code></pre> <p>Update a task dynamic parameters</p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>@abstractmethod\nasync def update_task(self, task: Task, params: dict[str, Any]) -&gt; TaskInfo:\n    \"\"\"Update a task dynamic parameters\"\"\"\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.close","title":"close  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Close the broker on shutdown</p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>@abstractmethod\nasync def close(self) -&gt; None:\n    \"\"\"Close the broker on shutdown\"\"\"\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.lock","title":"lock  <code>abstractmethod</code>","text":"<pre><code>lock(name, timeout=None)\n</code></pre> <p>Create a lock</p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>@abstractmethod\ndef lock(self, name: str, timeout: float | None = None) -&gt; Lock:\n    \"\"\"Create a lock\"\"\"\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.new_uuid","title":"new_uuid","text":"<pre><code>new_uuid()\n</code></pre> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>def new_uuid(self) -&gt; str:\n    return uuid4().hex\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.filter_tasks","title":"filter_tasks  <code>async</code>","text":"<pre><code>filter_tasks(scheduled=None, enabled=None)\n</code></pre> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>async def filter_tasks(\n    self,\n    scheduled: bool | None = None,\n    enabled: bool | None = None,\n) -&gt; list[Task]:\n    task_info = await self.get_tasks_info()\n    task_map = {info.name: info for info in task_info}\n    tasks = []\n    for task in self.registry.values():\n        if scheduled is not None and bool(task.schedule) is not scheduled:\n            continue\n        if enabled is not None and task_map[task.name].enabled is not enabled:\n            continue\n        tasks.append(task)\n    return tasks\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.task_from_registry","title":"task_from_registry","text":"<pre><code>task_from_registry(task)\n</code></pre> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>def task_from_registry(self, task: str | Task) -&gt; Task:\n    if isinstance(task, Task):\n        self.register_task(task)\n        return task\n    else:\n        if task_ := self.registry.get(task):\n            return task_\n        raise UnknownTaskError(task)\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.register_task","title":"register_task","text":"<pre><code>register_task(task)\n</code></pre> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>def register_task(self, task: Task) -&gt; None:\n    self.registry[task.name] = task\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.enable_task","title":"enable_task  <code>async</code>","text":"<pre><code>enable_task(task_name, enable=True)\n</code></pre> <p>Enable or disable a registered task</p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>async def enable_task(self, task_name: str, enable: bool = True) -&gt; TaskInfo:\n    \"\"\"Enable or disable a registered task\"\"\"\n    task = self.registry.get(task_name)\n    if not task:\n        raise UnknownTaskError(task_name)\n    return await self.update_task(task, dict(enabled=enable))\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.from_url","title":"from_url  <code>classmethod</code>","text":"<pre><code>from_url(url='')\n</code></pre> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>@classmethod\ndef from_url(cls, url: str = \"\") -&gt; TaskBroker:\n    p = URL(url or broker_url_from_env())\n    if factory := _brokers.get(p.scheme):\n        return factory(p)\n    raise RuntimeError(f\"Invalid broker {p}\")\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.register_broker","title":"register_broker  <code>classmethod</code>","text":"<pre><code>register_broker(name, factory)\n</code></pre> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>@classmethod\ndef register_broker(cls, name: str, factory: type[TaskBroker]) -&gt; None:\n    _brokers[name] = factory\n</code></pre>"},{"location":"reference/task_manager/","title":"Task Manager","text":"<p>It can be imported from <code>fluid.scheduler</code>:</p> <pre><code>from fastapi.scheduler import TaskManager\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager","title":"fluid.scheduler.TaskManager","text":"<pre><code>TaskManager(**kwargs)\n</code></pre> <p>The task manager is the main entry point for managing tasks</p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def __init__(self, **kwargs: Any) -&gt; None:\n    self.state: dict[str, Any] = {}\n    self.config: TaskManagerConfig = TaskManagerConfig(**kwargs)\n    self.dispatcher = TaskDispatcher()\n    self.broker = TaskBroker.from_url(self.config.broker_url)\n    self._stack = AsyncExitStack()\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.state","title":"state  <code>instance-attribute</code>","text":"<pre><code>state = {}\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config = TaskManagerConfig(**kwargs)\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.dispatcher","title":"dispatcher  <code>instance-attribute</code>","text":"<pre><code>dispatcher = TaskDispatcher()\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.broker","title":"broker  <code>instance-attribute</code>","text":"<pre><code>broker = from_url(broker_url)\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.registry","title":"registry  <code>property</code>","text":"<pre><code>registry\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.type","title":"type  <code>property</code>","text":"<pre><code>type\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.enter_async_context","title":"enter_async_context  <code>async</code>","text":"<pre><code>enter_async_context(cm)\n</code></pre> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>async def enter_async_context(self, cm: Any) -&gt; Any:\n    return await self._stack.enter_async_context(cm)\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.execute","title":"execute  <code>async</code>","text":"<pre><code>execute(task, **params)\n</code></pre> <p>Execute a task and wait for it to finish</p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>async def execute(self, task: Task | str, **params: Any) -&gt; TaskRun:\n    \"\"\"Execute a task and wait for it to finish\"\"\"\n    task_run = self.create_task_run(task, **params)\n    await task_run.execute()\n    return task_run\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.on_shutdown","title":"on_shutdown  <code>async</code>","text":"<pre><code>on_shutdown()\n</code></pre> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>async def on_shutdown(self) -&gt; None:\n    await self.broker.close()\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.execute_sync","title":"execute_sync","text":"<pre><code>execute_sync(task, **params)\n</code></pre> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def execute_sync(self, task: Task | str, **params: Any) -&gt; TaskRun:\n    return asyncio.get_event_loop().run_until_complete(\n        self._execute_and_exit(task, **params)\n    )\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.register_task","title":"register_task","text":"<pre><code>register_task(task)\n</code></pre> <p>Register a task with the task manager</p> <p>Only tasks registered can be executed by a task manager</p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def register_task(self, task: Task) -&gt; None:\n    \"\"\"Register a task with the task manager\n\n    Only tasks registered can be executed by a task manager\n    \"\"\"\n    self.broker.register_task(task)\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.queue","title":"queue  <code>async</code>","text":"<pre><code>queue(task, priority=None, **params)\n</code></pre> <p>Queue a task for execution</p> <p>This methods fires two events:</p> <ul> <li>queue: when the task is about to be queued</li> <li>queued: after the task is queued</li> </ul> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>async def queue(\n    self,\n    task: str | Task,\n    priority: TaskPriority | None = None,\n    **params: Any,\n) -&gt; TaskRun:\n    \"\"\"Queue a task for execution\n\n    This methods fires two events:\n\n    - queue: when the task is about to be queued\n    - queued: after the task is queued\n    \"\"\"\n    task_run = self.create_task_run(task, priority=priority, **params)\n    self.dispatcher.dispatch(task_run)\n    task_run.set_state(TaskState.queued)\n    await self.broker.queue_task(task_run)\n    return task_run\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.create_task_run","title":"create_task_run","text":"<pre><code>create_task_run(task, run_id='', priority=None, **params)\n</code></pre> <p>Create a TaskRun in <code>init</code> state</p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def create_task_run(\n    self,\n    task: str | Task,\n    run_id: str = \"\",\n    priority: TaskPriority | None = None,\n    **params: Any,\n) -&gt; TaskRun:\n    \"\"\"Create a TaskRun in `init` state\"\"\"\n    if isinstance(task, str):\n        task = self.broker.task_from_registry(task)\n    run_id = run_id or self.broker.new_uuid()\n    return TaskRun(\n        id=run_id,\n        task=task,\n        priority=priority or task.priority,\n        params=params,\n        task_manager=self,\n    )\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.register_from_module","title":"register_from_module","text":"<pre><code>register_from_module(module)\n</code></pre> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def register_from_module(self, module: Any) -&gt; None:\n    for name in dir(module):\n        if name.startswith(\"_\"):\n            continue\n        if isinstance(obj := getattr(module, name), Task):\n            self.register_task(obj)\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.cli","title":"cli","text":"<pre><code>cli(**kwargs)\n</code></pre> <p>Create the task manager command line interface</p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def cli(self, **kwargs: Any) -&gt; Any:\n    \"\"\"Create the task manager command line interface\"\"\"\n    try:\n        from fluid.scheduler.cli import TaskManagerCLI\n    except ImportError:\n        raise ImportError(\n            \"TaskManagerCLI is not available - \"\n            \"install with `pip install aio-fluid[cli]`\"\n        ) from None\n    return TaskManagerCLI(self, **kwargs)\n</code></pre>"},{"location":"reference/task_run/","title":"Task Run","text":"<p>It can be imported from <code>fluid.scheduler</code>:</p> <pre><code>from fastapi.scheduler import TaskRun\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun","title":"fluid.scheduler.TaskRun","text":"<p>               Bases: <code>BaseModel</code></p> <p>A TaskRun contains all the data generated by a Task run</p>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.task","title":"task  <code>instance-attribute</code>","text":"<pre><code>task\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.priority","title":"priority  <code>instance-attribute</code>","text":"<pre><code>priority\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.params","title":"params  <code>instance-attribute</code>","text":"<pre><code>params\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.state","title":"state  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>state = init\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.task_manager","title":"task_manager  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>task_manager = Field(exclude=True, repr=False)\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.queued","title":"queued  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>queued = None\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.start","title":"start  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>start = None\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.end","title":"end  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>end = None\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.logger","title":"logger  <code>property</code>","text":"<pre><code>logger\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.in_queue","title":"in_queue  <code>property</code>","text":"<pre><code>in_queue\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.duration","title":"duration  <code>property</code>","text":"<pre><code>duration\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.duration_ms","title":"duration_ms  <code>property</code>","text":"<pre><code>duration_ms\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.total","title":"total  <code>property</code>","text":"<pre><code>total\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.name","title":"name  <code>property</code>","text":"<pre><code>name\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.name_id","title":"name_id  <code>property</code>","text":"<pre><code>name_id\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.is_done","title":"is_done  <code>property</code>","text":"<pre><code>is_done\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.is_failure","title":"is_failure  <code>property</code>","text":"<pre><code>is_failure\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.execute","title":"execute  <code>async</code>","text":"<pre><code>execute()\n</code></pre> Source code in <code>fluid/scheduler/models.py</code> <pre><code>async def execute(self) -&gt; None:\n    try:\n        self.set_state(TaskState.running)\n        await self.task.executor(self)\n    except Exception:\n        self.set_state(TaskState.failure)\n        raise\n    else:\n        self.set_state(TaskState.success)\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.serialize_task","title":"serialize_task","text":"<pre><code>serialize_task(task, _info)\n</code></pre> Source code in <code>fluid/scheduler/models.py</code> <pre><code>@field_serializer(\"task\")\ndef serialize_task(self, task: Task, _info: Any) -&gt; str:\n    return task.name\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.params_dump_json","title":"params_dump_json","text":"<pre><code>params_dump_json()\n</code></pre> Source code in <code>fluid/scheduler/models.py</code> <pre><code>def params_dump_json(self) -&gt; str:\n    return self.task.params_dump_json(self.params)\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.set_state","title":"set_state","text":"<pre><code>set_state(state, state_time=None)\n</code></pre> Source code in <code>fluid/scheduler/models.py</code> <pre><code>def set_state(\n    self,\n    state: TaskState,\n    state_time: datetime | None = None,\n) -&gt; None:\n    if self.state == state:\n        return\n    state_time = state_time or utcnow()\n    match (self.state, state):\n        case (TaskState.init, TaskState.queued):\n            self.queued = state_time\n            self.state = state\n            self._dispatch()\n        case (TaskState.init, _):\n            self.set_state(TaskState.queued, state_time)\n            self.set_state(state, state_time)\n        case (TaskState.queued, TaskState.running):\n            self.start = state_time\n            self.state = state\n            self._dispatch()\n        case (\n            TaskState.queued,\n            TaskState.success\n            | TaskState.aborted\n            | TaskState.rate_limited\n            | TaskState.failure,\n        ):\n            self.set_state(TaskState.running, state_time)\n            self.set_state(state, state_time)\n        case (\n            TaskState.running,\n            TaskState.success\n            | TaskState.aborted\n            | TaskState.rate_limited\n            | TaskState.failure,\n        ):\n            self.end = state_time\n            self.state = state\n            self._dispatch()\n        case _:\n            raise TaskRunError(f\"invalid state transition {self.state} -&gt; {state}\")\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.lock","title":"lock","text":"<pre><code>lock(timeout)\n</code></pre> Source code in <code>fluid/scheduler/models.py</code> <pre><code>def lock(self, timeout: float | None) -&gt; Lock:\n    return self.task_manager.broker.lock(self.name, timeout=timeout)\n</code></pre>"}]}