{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>Aio Fluid</p> <p>Async utilities for backend python services developed by Quantmind.</p> <p> </p> <p>Documentation: fluid.quantmind.com</p> <p>Source Code: github.com/quantmind/aio-fluid</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Async workers: workers with start/stop capabilities.</li> <li>Async tasks scheduler and consumer: A task scheduler and consumer for async and CPU bound tasks.</li> <li>Async CRUD database operations: An async CRUD interface for postgres databases.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>This is a python package you can install via pip:</p> <pre><code>pip install aio-fluid\n</code></pre> <p>To install all the dependencies:</p> <p><pre><code>pip install aio-fluid[cli, db, http, log, k8s]\n</code></pre> this includes the following extra dependencies:</p> <ul> <li><code>cli</code> for the command line interface using click and rich</li> <li><code>db</code> for database support with asyncpg and sqlalchemy</li> <li><code>http</code> for http client support with httpx and aiohttp</li> <li><code>log</code> for JSON logging support with python-json-logger</li> <li><code>k8s</code> for Kubernetes support for CPU bound tasks</li> </ul>"},{"location":"#development","title":"Development","text":"<p>You can run the examples via</p> <pre><code>poetry run python -m examples.main\n</code></pre>"},{"location":"reference/","title":"Introduction","text":"<p>Here's the reference or code API, the classes, functions, parameters, attributes, and all the <code>aio-fluid</code> parts you can use in your applications.</p> <p>If you want to learn how to use the library you are much better off reading the Tutorials.</p>"},{"location":"reference/db/","title":"Database","text":"<p>It can be imported from <code>fluid.db</code>:</p> <pre><code>from fluid.db import Database\n</code></pre>"},{"location":"reference/db/#fluid.db.Database","title":"fluid.db.Database  <code>dataclass</code>","text":"<pre><code>Database(\n    dsn,\n    echo=DBECHO,\n    pool_size=DBPOOL_MAX_SIZE,\n    max_overflow=DBPOOL_MAX_OVERFLOW,\n    metadata=MetaData(),\n    migration_path=\"\",\n    app_name=APP_NAME,\n    _engine=None,\n)\n</code></pre> <p>A container for tables in a database and a manager of asynchronous connections to a postgresql database</p>"},{"location":"reference/db/#fluid.db.Database.dsn","title":"dsn  <code>instance-attribute</code>","text":"<pre><code>dsn\n</code></pre> <p>data source name, aka connection string</p> <p>Example: <code>postgresql+asyncpg://user:password@localhost/dbname</code></p> <p>not the <code>+asyncpg</code> part is important for the sync engine</p>"},{"location":"reference/db/#fluid.db.Database.echo","title":"echo  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>echo = DBECHO\n</code></pre> <p>Echo SQL queries to stdout</p> <p>It defaults to the <code>DBECHO</code> setting in the settings module</p>"},{"location":"reference/db/#fluid.db.Database.pool_size","title":"pool_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pool_size = DBPOOL_MAX_SIZE\n</code></pre>"},{"location":"reference/db/#fluid.db.Database.max_overflow","title":"max_overflow  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_overflow = DBPOOL_MAX_OVERFLOW\n</code></pre>"},{"location":"reference/db/#fluid.db.Database.metadata","title":"metadata  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metadata = field(default_factory=MetaData)\n</code></pre>"},{"location":"reference/db/#fluid.db.Database.migration_path","title":"migration_path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>migration_path = ''\n</code></pre>"},{"location":"reference/db/#fluid.db.Database.app_name","title":"app_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>app_name = APP_NAME\n</code></pre>"},{"location":"reference/db/#fluid.db.Database.tables","title":"tables  <code>property</code>","text":"<pre><code>tables\n</code></pre> <p>A dictionary of tables in the database</p>"},{"location":"reference/db/#fluid.db.Database.engine","title":"engine  <code>property</code>","text":"<pre><code>engine\n</code></pre> <p>The :class:<code>sqlalchemy.ext.asyncio.AsyncEngine</code> creating connection and transactions</p>"},{"location":"reference/db/#fluid.db.Database.sync_engine","title":"sync_engine  <code>property</code>","text":"<pre><code>sync_engine\n</code></pre> <p>The sqlalchemy Engine object for synchrouns operations</p>"},{"location":"reference/db/#fluid.db.Database.from_env","title":"from_env  <code>classmethod</code>","text":"<pre><code>from_env(*, dsn=DATABASE, schema=DATABASE_SCHEMA, **kwargs)\n</code></pre> <p>Create a new database container from environment variables as defaults</p> Source code in <code>fluid/db/container.py</code> <pre><code>@classmethod\ndef from_env(\n    cls,\n    *,\n    dsn: str = settings.DATABASE,\n    schema: str | None = settings.DATABASE_SCHEMA,\n    **kwargs: Any,\n) -&gt; Self:\n    \"\"\"Create a new database container from environment variables as defaults\"\"\"\n    return cls(dsn=dsn, metadata=sa.MetaData(schema=schema), **kwargs)\n</code></pre>"},{"location":"reference/db/#fluid.db.Database.connection","title":"connection  <code>async</code>","text":"<pre><code>connection()\n</code></pre> <p>Context manager for obtaining an asynchronous connection</p> Source code in <code>fluid/db/container.py</code> <pre><code>@asynccontextmanager\nasync def connection(self) -&gt; AsyncIterator[AsyncConnection]:\n    \"\"\"Context manager for obtaining an asynchronous connection\"\"\"\n    async with self.engine.connect() as conn:\n        yield conn\n</code></pre>"},{"location":"reference/db/#fluid.db.Database.ensure_connection","title":"ensure_connection  <code>async</code>","text":"<pre><code>ensure_connection(conn=None)\n</code></pre> <p>Context manager for obtaining an asynchronous connection</p> Source code in <code>fluid/db/container.py</code> <pre><code>@asynccontextmanager\nasync def ensure_connection(\n    self,\n    conn: AsyncConnection | None = None,\n) -&gt; AsyncIterator[AsyncConnection]:\n    \"\"\"Context manager for obtaining an asynchronous connection\"\"\"\n    if conn:\n        yield conn\n    else:\n        async with self.engine.connect() as conn:\n            yield conn\n</code></pre>"},{"location":"reference/db/#fluid.db.Database.transaction","title":"transaction  <code>async</code>","text":"<pre><code>transaction()\n</code></pre> <p>Context manager for initializing an asynchronous database transaction</p> Source code in <code>fluid/db/container.py</code> <pre><code>@asynccontextmanager\nasync def transaction(self) -&gt; AsyncIterator[AsyncConnection]:\n    \"\"\"Context manager for initializing an asynchronous database transaction\"\"\"\n    async with self.engine.begin() as conn:\n        yield conn\n</code></pre>"},{"location":"reference/db/#fluid.db.Database.ensure_transaction","title":"ensure_transaction  <code>async</code>","text":"<pre><code>ensure_transaction(conn=None)\n</code></pre> <p>Context manager for ensuring we a connection has initialized a database transaction</p> Source code in <code>fluid/db/container.py</code> <pre><code>@asynccontextmanager\nasync def ensure_transaction(\n    self,\n    conn: AsyncConnection | None = None,\n) -&gt; AsyncIterator[AsyncConnection]:\n    \"\"\"Context manager for ensuring we a connection has initialized\n    a database transaction\"\"\"\n    if conn:\n        if not conn.in_transaction():\n            async with conn.begin():\n                yield conn\n        else:\n            yield conn\n    else:\n        async with self.transaction() as conn:\n            yield conn\n</code></pre>"},{"location":"reference/db/#fluid.db.Database.close","title":"close  <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Close the asynchronous db engine if opened</p> Source code in <code>fluid/db/container.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close the asynchronous db engine if opened\"\"\"\n    if self._engine is not None:\n        engine, self._engine = self._engine, None\n        await engine.dispose()\n</code></pre>"},{"location":"reference/db/#fluid.db.Database.ping","title":"ping  <code>async</code>","text":"<pre><code>ping()\n</code></pre> <p>Ping the database</p> Source code in <code>fluid/db/container.py</code> <pre><code>async def ping(self) -&gt; str:\n    \"\"\"Ping the database\"\"\"\n    # TODO: we need a custom ping query\n    async with self.connection() as conn:\n        await conn.execute(sa.text(\"SELECT 1\"))\n    return \"ok\"\n</code></pre>"},{"location":"reference/db/#fluid.db.Database.migration","title":"migration","text":"<pre><code>migration()\n</code></pre> <p>The migration manager for this database</p> Source code in <code>fluid/db/container.py</code> <pre><code>def migration(self) -&gt; Migration:\n    \"\"\"The migration manager for this database\"\"\"\n    return Migration(db=self)\n</code></pre>"},{"location":"reference/db_cli/","title":"DB CLI","text":"<p>The Database command line interface (CLI) is a tool for managing database migrations and other database operations. It requires to install the additional <code>cli</code> extra:</p> <pre><code>pip install aio-fluid[db,cli]\n</code></pre> <p>It can be imported from <code>fluid.db.cli</code>:</p> <pre><code>from fluid.db.cli import DbGroup\n</code></pre>"},{"location":"reference/db_cli/#fluid.db.cli.DbGroup","title":"fluid.db.cli.DbGroup","text":"<pre><code>DbGroup(\n    db,\n    name=\"db\",\n    help=\"Manage database and migrations\",\n    **kwargs\n)\n</code></pre> <p>               Bases: <code>Group</code></p> <p>A click group for database commands</p> <p>This class provides a CLI for a Database Application.</p> <p>It requires to install the <code>cli</code> extra dependencies.</p> Source code in <code>fluid/db/cli.py</code> <pre><code>def __init__(\n    self,\n    db: Database,\n    name: str = \"db\",\n    help: str = \"Manage database and migrations\",  # noqa: A002\n    **kwargs: Any,\n) -&gt; None:\n    super().__init__(name=name, help=help, **kwargs)\n    self.db = db\n    for command in _db.commands.values():\n        self.add_command(command)\n</code></pre>"},{"location":"reference/db_cli/#fluid.db.cli.DbGroup.db","title":"db  <code>instance-attribute</code>","text":"<pre><code>db = db\n</code></pre>"},{"location":"reference/db_cli/#fluid.db.cli.DbGroup.get_command","title":"get_command","text":"<pre><code>get_command(ctx, name)\n</code></pre> Source code in <code>fluid/db/cli.py</code> <pre><code>def get_command(self, ctx: click.Context, name: str) -&gt; Optional[click.Command]:\n    ctx.obj = {\"db\": self.db}\n    return super().get_command(ctx, name)\n</code></pre>"},{"location":"reference/db_cli/#fluid.db.cli.DbGroup.list_commands","title":"list_commands","text":"<pre><code>list_commands(ctx)\n</code></pre> Source code in <code>fluid/db/cli.py</code> <pre><code>def list_commands(self, ctx: click.Context) -&gt; list[str]:\n    ctx.obj = {\"db\": self.db}\n    return super().list_commands(ctx)\n</code></pre>"},{"location":"reference/db_crud/","title":"CrudDB","text":"<p>The CrudDB class inherits from Database to provide standard CRUD operations for a database table.</p> <p>It can be imported from <code>fluid.db</code>:</p> <pre><code>from fluid.db import CrudDB\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB","title":"fluid.db.CrudDB  <code>dataclass</code>","text":"<pre><code>CrudDB(\n    dsn,\n    echo=DBECHO,\n    pool_size=DBPOOL_MAX_SIZE,\n    max_overflow=DBPOOL_MAX_OVERFLOW,\n    metadata=MetaData(),\n    migration_path=\"\",\n    app_name=APP_NAME,\n    _engine=None,\n)\n</code></pre> <p>               Bases: <code>Database</code></p> <p>A Database with additional methods for CRUD operations</p>"},{"location":"reference/db_crud/#fluid.db.CrudDB.dsn","title":"dsn  <code>instance-attribute</code>","text":"<pre><code>dsn\n</code></pre> <p>data source name, aka connection string</p> <p>Example: <code>postgresql+asyncpg://user:password@localhost/dbname</code></p> <p>not the <code>+asyncpg</code> part is important for the sync engine</p>"},{"location":"reference/db_crud/#fluid.db.CrudDB.echo","title":"echo  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>echo = DBECHO\n</code></pre> <p>Echo SQL queries to stdout</p> <p>It defaults to the <code>DBECHO</code> setting in the settings module</p>"},{"location":"reference/db_crud/#fluid.db.CrudDB.pool_size","title":"pool_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pool_size = DBPOOL_MAX_SIZE\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.max_overflow","title":"max_overflow  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_overflow = DBPOOL_MAX_OVERFLOW\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.metadata","title":"metadata  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metadata = field(default_factory=MetaData)\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.migration_path","title":"migration_path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>migration_path = ''\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.app_name","title":"app_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>app_name = APP_NAME\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.tables","title":"tables  <code>property</code>","text":"<pre><code>tables\n</code></pre> <p>A dictionary of tables in the database</p>"},{"location":"reference/db_crud/#fluid.db.CrudDB.engine","title":"engine  <code>property</code>","text":"<pre><code>engine\n</code></pre> <p>The :class:<code>sqlalchemy.ext.asyncio.AsyncEngine</code> creating connection and transactions</p>"},{"location":"reference/db_crud/#fluid.db.CrudDB.sync_engine","title":"sync_engine  <code>property</code>","text":"<pre><code>sync_engine\n</code></pre> <p>The sqlalchemy Engine object for synchrouns operations</p>"},{"location":"reference/db_crud/#fluid.db.CrudDB.from_env","title":"from_env  <code>classmethod</code>","text":"<pre><code>from_env(*, dsn=DATABASE, schema=DATABASE_SCHEMA, **kwargs)\n</code></pre> <p>Create a new database container from environment variables as defaults</p> Source code in <code>fluid/db/container.py</code> <pre><code>@classmethod\ndef from_env(\n    cls,\n    *,\n    dsn: str = settings.DATABASE,\n    schema: str | None = settings.DATABASE_SCHEMA,\n    **kwargs: Any,\n) -&gt; Self:\n    \"\"\"Create a new database container from environment variables as defaults\"\"\"\n    return cls(dsn=dsn, metadata=sa.MetaData(schema=schema), **kwargs)\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.connection","title":"connection  <code>async</code>","text":"<pre><code>connection()\n</code></pre> <p>Context manager for obtaining an asynchronous connection</p> Source code in <code>fluid/db/container.py</code> <pre><code>@asynccontextmanager\nasync def connection(self) -&gt; AsyncIterator[AsyncConnection]:\n    \"\"\"Context manager for obtaining an asynchronous connection\"\"\"\n    async with self.engine.connect() as conn:\n        yield conn\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.ensure_connection","title":"ensure_connection  <code>async</code>","text":"<pre><code>ensure_connection(conn=None)\n</code></pre> <p>Context manager for obtaining an asynchronous connection</p> Source code in <code>fluid/db/container.py</code> <pre><code>@asynccontextmanager\nasync def ensure_connection(\n    self,\n    conn: AsyncConnection | None = None,\n) -&gt; AsyncIterator[AsyncConnection]:\n    \"\"\"Context manager for obtaining an asynchronous connection\"\"\"\n    if conn:\n        yield conn\n    else:\n        async with self.engine.connect() as conn:\n            yield conn\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.transaction","title":"transaction  <code>async</code>","text":"<pre><code>transaction()\n</code></pre> <p>Context manager for initializing an asynchronous database transaction</p> Source code in <code>fluid/db/container.py</code> <pre><code>@asynccontextmanager\nasync def transaction(self) -&gt; AsyncIterator[AsyncConnection]:\n    \"\"\"Context manager for initializing an asynchronous database transaction\"\"\"\n    async with self.engine.begin() as conn:\n        yield conn\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.ensure_transaction","title":"ensure_transaction  <code>async</code>","text":"<pre><code>ensure_transaction(conn=None)\n</code></pre> <p>Context manager for ensuring we a connection has initialized a database transaction</p> Source code in <code>fluid/db/container.py</code> <pre><code>@asynccontextmanager\nasync def ensure_transaction(\n    self,\n    conn: AsyncConnection | None = None,\n) -&gt; AsyncIterator[AsyncConnection]:\n    \"\"\"Context manager for ensuring we a connection has initialized\n    a database transaction\"\"\"\n    if conn:\n        if not conn.in_transaction():\n            async with conn.begin():\n                yield conn\n        else:\n            yield conn\n    else:\n        async with self.transaction() as conn:\n            yield conn\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.close","title":"close  <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Close the asynchronous db engine if opened</p> Source code in <code>fluid/db/container.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close the asynchronous db engine if opened\"\"\"\n    if self._engine is not None:\n        engine, self._engine = self._engine, None\n        await engine.dispose()\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.ping","title":"ping  <code>async</code>","text":"<pre><code>ping()\n</code></pre> <p>Ping the database</p> Source code in <code>fluid/db/container.py</code> <pre><code>async def ping(self) -&gt; str:\n    \"\"\"Ping the database\"\"\"\n    # TODO: we need a custom ping query\n    async with self.connection() as conn:\n        await conn.execute(sa.text(\"SELECT 1\"))\n    return \"ok\"\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.migration","title":"migration","text":"<pre><code>migration()\n</code></pre> <p>The migration manager for this database</p> Source code in <code>fluid/db/container.py</code> <pre><code>def migration(self) -&gt; Migration:\n    \"\"\"The migration manager for this database\"\"\"\n    return Migration(db=self)\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.db_select","title":"db_select  <code>async</code>","text":"<pre><code>db_select(table, filters, *, order_by=None, conn=None)\n</code></pre> <p>Select rows from a given table :param table: sqlalchemy Table :param filters: key-value pairs for filtering rows :param conn: optional db connection :param consumer: optional consumer (see :meth:<code>.get_query</code>)</p> Source code in <code>fluid/db/crud.py</code> <pre><code>async def db_select(\n    self,\n    table: FromClause,\n    filters: dict,\n    *,\n    order_by: tuple[str, ...] | None = None,\n    conn: AsyncConnection | None = None,\n) -&gt; CursorResult:\n    \"\"\"Select rows from a given table\n    :param table: sqlalchemy Table\n    :param filters: key-value pairs for filtering rows\n    :param conn: optional db connection\n    :param consumer: optional consumer (see :meth:`.get_query`)\n    \"\"\"\n    sql_query = self.get_query(table, Select(table), params=filters)\n    if order_by:\n        sql_query = self.order_by_query(table, cast(Select, sql_query), order_by)\n    async with self.ensure_transaction(conn) as conn:\n        return await conn.execute(sql_query)\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.db_insert","title":"db_insert  <code>async</code>","text":"<pre><code>db_insert(table, data, *, conn=None)\n</code></pre> <p>Perform an insert into a table :param table: sqlalchemy Table :param data: key-value pairs for columns values :param conn: optional db connection</p> Source code in <code>fluid/db/crud.py</code> <pre><code>async def db_insert(\n    self,\n    table: Table,\n    data: list[dict] | dict,\n    *,\n    conn: AsyncConnection | None = None,\n) -&gt; CursorResult:\n    \"\"\"Perform an insert into a table\n    :param table: sqlalchemy Table\n    :param data: key-value pairs for columns values\n    :param conn: optional db connection\n    \"\"\"\n    async with self.ensure_transaction(conn) as conn:\n        sql_query = self.insert_query(table, data)\n        return await conn.execute(sql_query)\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.db_update","title":"db_update  <code>async</code>","text":"<pre><code>db_update(table, filters, data, *, conn=None)\n</code></pre> <p>Perform an update of rows</p> <p>:param table: sqlalchemy Table :param filters: key-value pairs for filtering rows to update :param data: key-value pairs for updating columns values of selected rows :param conn: optional db connection :param consumer: optional consumer (see :meth:<code>.get_query</code>)</p> Source code in <code>fluid/db/crud.py</code> <pre><code>async def db_update(\n    self,\n    table: Table,\n    filters: dict,\n    data: dict,\n    *,\n    conn: AsyncConnection | None = None,\n) -&gt; CursorResult:\n    \"\"\"Perform an update of rows\n\n    :param table: sqlalchemy Table\n    :param filters: key-value pairs for filtering rows to update\n    :param data: key-value pairs for updating columns values of selected rows\n    :param conn: optional db connection\n    :param consumer: optional consumer (see :meth:`.get_query`)\n    \"\"\"\n    update = (\n        cast(\n            Update,\n            self.get_query(table, table.update(), params=filters),\n        )\n        .values(**data)\n        .returning(*table.columns)\n    )\n    async with self.ensure_transaction(conn) as conn:\n        return await conn.execute(update)\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.db_upsert","title":"db_upsert  <code>async</code>","text":"<pre><code>db_upsert(table, filters, data=None, *, conn=None)\n</code></pre> <p>Perform an upsert for a single record</p> <p>:param table: sqlalchemy Table :param filters: key-value pairs for filtering rows to update :param data: key-value pairs for updating columns values of selected rows :param conn: optional db connection :param consumer: optional consumer (see :meth:<code>.get_query</code>)</p> Source code in <code>fluid/db/crud.py</code> <pre><code>async def db_upsert(\n    self,\n    table: Table,\n    filters: dict,\n    data: dict | None = None,\n    *,\n    conn: AsyncConnection | None = None,\n) -&gt; Row:\n    \"\"\"Perform an upsert for a single record\n\n    :param table: sqlalchemy Table\n    :param filters: key-value pairs for filtering rows to update\n    :param data: key-value pairs for updating columns values of selected rows\n    :param conn: optional db connection\n    :param consumer: optional consumer (see :meth:`.get_query`)\n    \"\"\"\n    if data:\n        result = await self.db_update(table, filters, data, conn=conn)\n    else:\n        result = await self.db_select(table, filters, conn=conn)\n    record = result.one_or_none()\n    if record is None:\n        insert_data = data.copy() if data else {}\n        insert_data.update(filters)\n        result = await self.db_insert(table, insert_data, conn=conn)\n        record = result.one()\n    return record\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.db_delete","title":"db_delete  <code>async</code>","text":"<pre><code>db_delete(table, filters, *, conn=None)\n</code></pre> <p>Delete rows from a given table :param table: sqlalchemy Table :param filters: key-value pairs for filtering rows :param conn: optional db connection :param consumer: optional consumer (see :meth:<code>.get_query</code>)</p> Source code in <code>fluid/db/crud.py</code> <pre><code>async def db_delete(\n    self,\n    table: Table,\n    filters: dict,\n    *,\n    conn: AsyncConnection | None = None,\n) -&gt; CursorResult:\n    \"\"\"Delete rows from a given table\n    :param table: sqlalchemy Table\n    :param filters: key-value pairs for filtering rows\n    :param conn: optional db connection\n    :param consumer: optional consumer (see :meth:`.get_query`)\n    \"\"\"\n    sql_query = self.get_query(\n        table,\n        table.delete().returning(*table.columns),\n        params=filters,\n    )\n    async with self.ensure_transaction(conn) as conn:\n        return await conn.execute(sql_query)\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.db_count","title":"db_count  <code>async</code>","text":"<pre><code>db_count(table, filters, *, conn=None)\n</code></pre> <p>Count rows in a table :param table: sqlalchemy Table :param filters: key-value pairs for filtering rows :param conn: optional db connection :param consumer: optional consumer (see :meth:<code>.get_query</code>)</p> Source code in <code>fluid/db/crud.py</code> <pre><code>async def db_count(\n    self,\n    table: FromClause,\n    filters: dict,\n    *,\n    conn: AsyncConnection | None = None,\n) -&gt; int:\n    \"\"\"Count rows in a table\n    :param table: sqlalchemy Table\n    :param filters: key-value pairs for filtering rows\n    :param conn: optional db connection\n    :param consumer: optional consumer (see :meth:`.get_query`)\n    \"\"\"\n    count_query = self.db_count_query(\n        cast(\n            Select,\n            self.get_query(\n                table,\n                table.select(),\n                params=filters,\n            ),\n        ),\n    )\n    async with self.ensure_connection(conn) as conn:\n        result: CursorResult = await conn.execute(count_query)\n        return cast(int, result.scalar())\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.insert_query","title":"insert_query","text":"<pre><code>insert_query(table, records)\n</code></pre> Source code in <code>fluid/db/crud.py</code> <pre><code>def insert_query(self, table: Table, records: list[dict] | dict) -&gt; Insert:\n    if isinstance(records, dict):\n        records = [records]\n    else:\n        cols: Set[str] = set()\n        for record in records:\n            cols.update(record)\n        new_records = []\n        for record in records:\n            if len(record) &lt; len(cols):\n                record = record.copy()\n                missing = cols.difference(record)\n                for col in missing:\n                    record[col] = None\n            new_records.append(record)\n        records = new_records\n    return insert(table).values(records).returning(*table.columns)\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.get_query","title":"get_query","text":"<pre><code>get_query(table, sql_query, *, params=None)\n</code></pre> <p>Build an SqlAlchemy query :param table: sqlalchemy Table :param sql_query: sqlalchemy query type :param params: key-value pairs for the query :param consumer: optional consumer for manipulating parameters</p> Source code in <code>fluid/db/crud.py</code> <pre><code>def get_query(\n    self,\n    table: FromClause,\n    sql_query: QueryType,\n    *,\n    params: dict | None = None,\n) -&gt; QueryType:\n    \"\"\"Build an SqlAlchemy query\n    :param table: sqlalchemy Table\n    :param sql_query: sqlalchemy query type\n    :param params: key-value pairs for the query\n    :param consumer: optional consumer for manipulating parameters\n    \"\"\"\n    filters: list = []\n    columns = table.c\n    params = params or {}\n\n    for key, value in params.items():\n        bits = key.split(\":\")\n        field = bits[0]\n        op = bits[1] if len(bits) == 2 else \"eq\"\n        field = getattr(columns, field)\n        result = self.default_filter_column(field, op, value)\n        if result is not None:\n            if not isinstance(result, (list, tuple)):\n                result = (result,)\n            filters.extend(result)\n    if filters:\n        whereclause = and_(*filters) if len(filters) &gt; 1 else filters[0]\n        sql_query = cast(Select, sql_query).where(whereclause)\n    return sql_query\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.db_count_query","title":"db_count_query","text":"<pre><code>db_count_query(sql_query)\n</code></pre> Source code in <code>fluid/db/crud.py</code> <pre><code>def db_count_query(self, sql_query: Select) -&gt; Select:\n    return select(func.count()).select_from(sql_query.alias(\"inner\"))\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.order_by_query","title":"order_by_query","text":"<pre><code>order_by_query(table, sql_query, order_by)\n</code></pre> <p>Apply ordering to a sql_query</p> Source code in <code>fluid/db/crud.py</code> <pre><code>def order_by_query(\n    self,\n    table: FromClause,\n    sql_query: Select,\n    order_by: tuple[str, ...],\n) -&gt; Select:\n    \"\"\"Apply ordering to a sql_query\"\"\"\n    return sql_query.order_by(*self.order_by_columns(table, order_by))\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.order_by_columns","title":"order_by_columns","text":"<pre><code>order_by_columns(table, order_by)\n</code></pre> <p>Apply ordering to a sql_query</p> Source code in <code>fluid/db/crud.py</code> <pre><code>def order_by_columns(\n    self,\n    table: FromClause,\n    order_by: tuple[str, ...],\n) -&gt; list[Column]:\n    \"\"\"Apply ordering to a sql_query\"\"\"\n    columns = []\n    for name in order_by:\n        if name.startswith(\"-\"):\n            order_by_column = getattr(table.c, name[1:], None)\n            if order_by_column is not None:\n                columns.append(order_by_column.desc())\n        else:\n            order_by_column = getattr(table.c, name, None)\n            if order_by_column is not None:\n                columns.append(order_by_column)\n    return columns\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.search_query","title":"search_query","text":"<pre><code>search_query(table, sql_query, search_fields, search)\n</code></pre> <p>Apply search to a sql_query</p> Source code in <code>fluid/db/crud.py</code> <pre><code>def search_query(\n    self,\n    table: FromClause,\n    sql_query: Select,\n    search_fields: tuple[str, ...],\n    search: str,\n) -&gt; Select:\n    \"\"\"Apply search to a sql_query\"\"\"\n    if search and search_fields:\n        columns = [getattr(table.c, col) for col in search_fields]\n        return sql_query.where(or_(*(col.ilike(f\"%{search}%\") for col in columns)))\n    return sql_query\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.default_filter_column","title":"default_filter_column","text":"<pre><code>default_filter_column(column, op, value)\n</code></pre> <p>Applies a filter on a field. Notes on 'ne' op: Example data: [None, 'john', 'roger'] ne:john would return only roger (i.e. nulls excluded) ne:     would return john and roger Notes on  'search' op: For some reason, SQLAlchemy uses to_tsquery rather than plainto_tsquery for the match operator to_tsquery uses operators (&amp;, |, ! etc.) while plainto_tsquery tokenises the input string and uses AND between tokens, hence plainto_tsquery is what we want here For other database back ends, the behaviour of the match operator is completely different - see: http://docs.sqlalchemy.org/en/rel_1_0/core/sqlelement.html :param field: field name :param op: 'eq', 'ne', 'gt', 'lt', 'ge', 'le' or 'search' :param value: comparison value, string or list/tuple :return:</p> Source code in <code>fluid/db/crud.py</code> <pre><code>def default_filter_column(self, column: Column, op: str, value: Any) -&gt; Any:\n    \"\"\"\n    Applies a filter on a field.\n    Notes on 'ne' op:\n    Example data: [None, 'john', 'roger']\n    ne:john would return only roger (i.e. nulls excluded)\n    ne:     would return john and roger\n    Notes on  'search' op:\n    For some reason, SQLAlchemy uses to_tsquery rather than\n    plainto_tsquery for the match operator\n    to_tsquery uses operators (&amp;, |, ! etc.) while\n    plainto_tsquery tokenises the input string and uses AND between\n    tokens, hence plainto_tsquery is what we want here\n    For other database back ends, the behaviour of the match\n    operator is completely different - see:\n    http://docs.sqlalchemy.org/en/rel_1_0/core/sqlelement.html\n    :param field: field name\n    :param op: 'eq', 'ne', 'gt', 'lt', 'ge', 'le' or 'search'\n    :param value: comparison value, string or list/tuple\n    :return:\n    \"\"\"\n    if multiple := isinstance(value, (list, tuple)):\n        value = tuple(column_value_to_python(column, v) for v in value)\n    else:\n        value = column_value_to_python(column, value)\n\n    if multiple and op in (\"eq\", \"ne\"):\n        if op == \"eq\":\n            return column.in_(value)\n        elif op == \"ne\":\n            return ~column.in_(value)\n    else:\n        if multiple:\n            assert len(value) &gt; 0\n            value = value[0]\n\n        if op == \"eq\":\n            return column == value\n        elif op == \"ne\":\n            return column != value\n        elif op == \"gt\":\n            return column &gt; value\n        elif op == \"ge\":\n            return column &gt;= value\n        elif op == \"lt\":\n            return column &lt; value\n        elif op == \"le\":\n            return column &lt;= value\n</code></pre>"},{"location":"reference/db_migrations/","title":"DB Migration","text":"<p>The migration object is accessed via Database.migration or CrudDB and is used to create and manage database migrations.</p>"},{"location":"reference/db_migrations/#fluid.db.Migration","title":"fluid.db.Migration  <code>dataclass</code>","text":"<pre><code>Migration(db)\n</code></pre> <p>A wrapper around Alembic commands to perform database migrations</p>"},{"location":"reference/db_migrations/#fluid.db.Migration.db","title":"db  <code>instance-attribute</code>","text":"<pre><code>db\n</code></pre>"},{"location":"reference/db_migrations/#fluid.db.Migration.cfg","title":"cfg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cfg = field(init=False, repr=False)\n</code></pre>"},{"location":"reference/db_migrations/#fluid.db.Migration.metadata","title":"metadata  <code>property</code>","text":"<pre><code>metadata\n</code></pre>"},{"location":"reference/db_migrations/#fluid.db.Migration.sync_engine","title":"sync_engine  <code>property</code>","text":"<pre><code>sync_engine\n</code></pre>"},{"location":"reference/db_migrations/#fluid.db.Migration.init","title":"init","text":"<pre><code>init()\n</code></pre> Source code in <code>fluid/db/migration.py</code> <pre><code>def init(self) -&gt; str:\n    dirname = self.cfg.get_main_option(\"script_location\") or \"\"\n    alembic_cmd.init(self.cfg, dirname)\n    return self.message()\n</code></pre>"},{"location":"reference/db_migrations/#fluid.db.Migration.show","title":"show","text":"<pre><code>show(revision)\n</code></pre> Source code in <code>fluid/db/migration.py</code> <pre><code>def show(self, revision: str) -&gt; str:\n    alembic_cmd.show(self.cfg, revision)\n    return self.message()\n</code></pre>"},{"location":"reference/db_migrations/#fluid.db.Migration.history","title":"history","text":"<pre><code>history()\n</code></pre> Source code in <code>fluid/db/migration.py</code> <pre><code>def history(self) -&gt; str:\n    alembic_cmd.history(self.cfg)\n    return self.message()\n</code></pre>"},{"location":"reference/db_migrations/#fluid.db.Migration.revision","title":"revision","text":"<pre><code>revision(message, autogenerate=False, branch_label=None)\n</code></pre> Source code in <code>fluid/db/migration.py</code> <pre><code>def revision(\n    self,\n    message: str,\n    autogenerate: bool = False,\n    branch_label: str | None = None,\n) -&gt; str:\n    alembic_cmd.revision(\n        self.cfg,\n        autogenerate=autogenerate,\n        message=message,\n        branch_label=branch_label,\n    )\n    return self.message()\n</code></pre>"},{"location":"reference/db_migrations/#fluid.db.Migration.upgrade","title":"upgrade","text":"<pre><code>upgrade(revision)\n</code></pre> Source code in <code>fluid/db/migration.py</code> <pre><code>def upgrade(self, revision: str) -&gt; str:\n    alembic_cmd.upgrade(self.cfg, revision)\n    return self.message()\n</code></pre>"},{"location":"reference/db_migrations/#fluid.db.Migration.downgrade","title":"downgrade","text":"<pre><code>downgrade(revision)\n</code></pre> Source code in <code>fluid/db/migration.py</code> <pre><code>def downgrade(self, revision: str) -&gt; str:\n    alembic_cmd.downgrade(self.cfg, revision)\n    return self.message()\n</code></pre>"},{"location":"reference/db_migrations/#fluid.db.Migration.current","title":"current","text":"<pre><code>current(verbose=False)\n</code></pre> Source code in <code>fluid/db/migration.py</code> <pre><code>def current(self, verbose: bool = False) -&gt; str:\n    alembic_cmd.current(self.cfg, verbose=verbose)\n    return self.message()\n</code></pre>"},{"location":"reference/db_migrations/#fluid.db.Migration.message","title":"message","text":"<pre><code>message()\n</code></pre> Source code in <code>fluid/db/migration.py</code> <pre><code>def message(self) -&gt; str:\n    msg = cast(StringIO, self.cfg.stdout).getvalue()\n    self.cfg.stdout.seek(0)\n    self.cfg.stdout.truncate()\n    return msg\n</code></pre>"},{"location":"reference/db_migrations/#fluid.db.Migration.db_exists","title":"db_exists","text":"<pre><code>db_exists(dbname='')\n</code></pre> Source code in <code>fluid/db/migration.py</code> <pre><code>def db_exists(self, dbname: str = \"\") -&gt; bool:\n    url = self.sync_engine.url\n    if dbname:\n        url = url.set(database=dbname)\n    return database_exists(url)\n</code></pre>"},{"location":"reference/db_migrations/#fluid.db.Migration.db_create","title":"db_create","text":"<pre><code>db_create(dbname='')\n</code></pre> <p>Creates a new database if it does not exist</p> Source code in <code>fluid/db/migration.py</code> <pre><code>def db_create(self, dbname: str = \"\") -&gt; bool:\n    \"\"\"Creates a new database if it does not exist\"\"\"\n    url = self.sync_engine.url\n    if dbname:\n        url = url.set(database=dbname)\n    if database_exists(url):\n        return False\n    create_database(url)\n    return True\n</code></pre>"},{"location":"reference/db_migrations/#fluid.db.Migration.db_drop","title":"db_drop","text":"<pre><code>db_drop(dbname='')\n</code></pre> Source code in <code>fluid/db/migration.py</code> <pre><code>def db_drop(self, dbname: str = \"\") -&gt; bool:\n    url = self.sync_engine.url\n    if dbname:\n        url = url.set(database=dbname)\n    if database_exists(url):\n        drop_database(url)\n        return True\n    return False\n</code></pre>"},{"location":"reference/db_migrations/#fluid.db.Migration.truncate_all","title":"truncate_all","text":"<pre><code>truncate_all()\n</code></pre> <p>Drop all tables from :attr:<code>metadata</code> in database</p> Source code in <code>fluid/db/migration.py</code> <pre><code>def truncate_all(self) -&gt; None:\n    \"\"\"Drop all tables from :attr:`metadata` in database\"\"\"\n    with self.sync_engine.begin() as conn:\n        conn.execute(sa.text(f'truncate {\", \".join(self.metadata.tables)}'))\n</code></pre>"},{"location":"reference/db_migrations/#fluid.db.Migration.drop_all_schemas","title":"drop_all_schemas","text":"<pre><code>drop_all_schemas()\n</code></pre> <p>Drop all schema in database</p> Source code in <code>fluid/db/migration.py</code> <pre><code>def drop_all_schemas(self) -&gt; None:\n    \"\"\"Drop all schema in database\"\"\"\n    with self.sync_engine.begin() as conn:\n        conn.execute(sa.text(\"DROP SCHEMA IF EXISTS public CASCADE\"))\n        conn.execute(sa.text(\"CREATE SCHEMA IF NOT EXISTS public\"))\n</code></pre>"},{"location":"reference/db_migrations/#fluid.db.Migration.create_ro_user","title":"create_ro_user","text":"<pre><code>create_ro_user(\n    username, password, role=\"\", schema=\"public\"\n)\n</code></pre> <p>Creates a read-only user</p> Source code in <code>fluid/db/migration.py</code> <pre><code>def create_ro_user(\n    self,\n    username: str,\n    password: str,\n    role: str = \"\",\n    schema: str = \"public\",\n) -&gt; bool:\n    \"\"\"Creates a read-only user\"\"\"\n    engine = self.sync_engine\n    role = role or f\"{engine.url.username}_ro\"\n    database = engine.url.database\n    created = True\n    with engine.begin() as conn:\n        try:\n            conn.execute(sa.text(f\"CREATE ROLE {role};\"))\n        except sa.exc.ProgrammingError:\n            created = False\n    with engine.begin() as conn:\n        conn.execute(\n            sa.text(\n                f\"GRANT CONNECT ON DATABASE {database} TO {role};\"\n                f\"GRANT USAGE ON SCHEMA {schema} TO {role};\"\n                f\"GRANT SELECT ON ALL TABLES IN SCHEMA {schema} TO {role};\"\n                f\"GRANT SELECT ON ALL SEQUENCES IN SCHEMA {schema} TO {role};\",\n            ),\n        )\n        conn.execute(\n            sa.text(\n                f\"ALTER DEFAULT PRIVILEGES IN SCHEMA {schema} \"\n                f\"GRANT SELECT ON TABLES TO {role};\",\n            ),\n        )\n    with engine.begin() as conn:\n        try:\n            conn.execute(\n                sa.text(\n                    f\"CREATE USER {username} WITH PASSWORD '{password}';\"\n                    f\"GRANT {role} TO {username};\",\n                ),\n            )\n        except sa.exc.ProgrammingError:\n            created = False\n    return created\n</code></pre>"},{"location":"reference/db_migrations/#fluid.db.Migration.drop_role","title":"drop_role","text":"<pre><code>drop_role(role)\n</code></pre> <p>Drop a role</p> Source code in <code>fluid/db/migration.py</code> <pre><code>def drop_role(\n    self,\n    role: str,\n) -&gt; bool:\n    \"\"\"Drop a role\"\"\"\n    try:\n        with self.sync_engine.begin() as conn:\n            conn.execute(sa.text(f\"DROP OWNED BY {role};\"))\n        with self.sync_engine.begin() as conn:\n            conn.execute(sa.text(f\"DROP ROLE IF EXISTS {role};\"))\n    except sa.exc.ProgrammingError as exc:\n        if f'role \"{role}\" does not exist' not in str(exc):\n            raise\n        return False\n    return True\n</code></pre>"},{"location":"reference/db_pagination/","title":"DB Pagination","text":"<p>The Pagination class is a tool for managing paginated rows from the database.</p> <p>It can be imported from <code>fluid.db</code>:</p> <pre><code>from fluid.db import Pagination, Search\n</code></pre>"},{"location":"reference/db_pagination/#fluid.db.Pagination","title":"fluid.db.Pagination","text":"<p>               Bases: <code>NamedTuple</code></p>"},{"location":"reference/db_pagination/#fluid.db.Pagination.order_by_fields","title":"order_by_fields  <code>instance-attribute</code>","text":"<pre><code>order_by_fields\n</code></pre>"},{"location":"reference/db_pagination/#fluid.db.Pagination.limit","title":"limit  <code>instance-attribute</code>","text":"<pre><code>limit\n</code></pre>"},{"location":"reference/db_pagination/#fluid.db.Pagination.filters","title":"filters  <code>instance-attribute</code>","text":"<pre><code>filters\n</code></pre>"},{"location":"reference/db_pagination/#fluid.db.Pagination.search","title":"search  <code>instance-attribute</code>","text":"<pre><code>search\n</code></pre>"},{"location":"reference/db_pagination/#fluid.db.Pagination.cursor","title":"cursor  <code>instance-attribute</code>","text":"<pre><code>cursor\n</code></pre>"},{"location":"reference/db_pagination/#fluid.db.Pagination.desc","title":"desc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>desc = False\n</code></pre>"},{"location":"reference/db_pagination/#fluid.db.Pagination.order_by_fields_sign","title":"order_by_fields_sign  <code>property</code>","text":"<pre><code>order_by_fields_sign\n</code></pre>"},{"location":"reference/db_pagination/#fluid.db.Pagination.create","title":"create  <code>classmethod</code>","text":"<pre><code>create(\n    *order_by_fields,\n    cursor=\"\",\n    limit=0,\n    filters=None,\n    search=None,\n    desc=False\n)\n</code></pre> Source code in <code>fluid/db/pagination.py</code> <pre><code>@classmethod\ndef create(\n    cls,\n    *order_by_fields: str,\n    cursor: str = \"\",\n    limit: int = 0,\n    filters: dict[str, Any] | None = None,\n    search: Search | None = None,\n    desc: bool = False,\n) -&gt; Pagination:\n    if limit &lt; 0:\n        raise ValidationError(\"limit must be greater than or equal to 0\")\n    if cursor:\n        if limit:\n            raise ValidationError(\"limit cannot be provided with cursor\")\n        if filters:\n            raise ValidationError(\"filters cannot be provided with cursor\")\n        if search and search.search_text:\n            raise ValidationError(\"search text cannot be provided with cursor\")\n        decoded_cursor = Cursor.decode(cursor, order_by_fields)\n        limit = decoded_cursor.limit\n        filters = decoded_cursor.filters\n        if search:\n            search = search._replace(search_text=decoded_cursor.search_text)\n    else:\n        decoded_cursor = None\n        if limit &gt;= 0:\n            limit = limit or settings.DEFAULT_PAGINATION_LIMIT\n    return cls(\n        order_by_fields=order_by_fields,\n        cursor=decoded_cursor,\n        limit=limit,\n        filters=filters or {},\n        search=search,\n        desc=desc,\n    )\n</code></pre>"},{"location":"reference/db_pagination/#fluid.db.Pagination.execute","title":"execute  <code>async</code>","text":"<pre><code>execute(db, table, *, conn=None)\n</code></pre> Source code in <code>fluid/db/pagination.py</code> <pre><code>async def execute(\n    self,\n    db: CrudDB,\n    table: FromClause,\n    *,\n    conn: AsyncConnection | None = None,\n) -&gt; tuple[Sequence[Row], str]:\n    sql_query = self.query(db, table)\n    async with db.ensure_connection(conn) as conn:\n        result = await conn.execute(sql_query)\n    data = result.all()\n    cursor = \"\"\n    if self.limit &gt; 0 and len(data) &gt; self.limit:\n        cursor = self._encode_cursor(data[-1])\n        data = data[:-1]\n    return data, cursor\n</code></pre>"},{"location":"reference/db_pagination/#fluid.db.Pagination.query","title":"query","text":"<pre><code>query(db, table)\n</code></pre> Source code in <code>fluid/db/pagination.py</code> <pre><code>def query(self, db: CrudDB, table: FromClause) -&gt; Select:\n    sql_query = cast(\n        Select,\n        db.get_query(table, table.select(), params=self.filters),\n    )\n    if self.search:\n        sql_query = db.search_query(\n            table,\n            sql_query,\n            self.search.search_fields,\n            self.search.search_text,\n        )\n    start_clause = self._start_clause(table)\n    if start_clause is not None:\n        sql_query = sql_query.where(start_clause)\n    columns = db.order_by_columns(table, self.order_by_fields_sign)\n    ordered = sql_query.order_by(*columns)\n    return ordered.limit(self.limit + 1) if self.limit &gt; 0 else ordered\n</code></pre>"},{"location":"reference/db_pagination/#fluid.db.Search","title":"fluid.db.Search","text":"<p>               Bases: <code>NamedTuple</code></p>"},{"location":"reference/db_pagination/#fluid.db.Search.search_fields","title":"search_fields  <code>instance-attribute</code>","text":"<pre><code>search_fields\n</code></pre>"},{"location":"reference/db_pagination/#fluid.db.Search.search_text","title":"search_text  <code>instance-attribute</code>","text":"<pre><code>search_text\n</code></pre>"},{"location":"reference/dispatchers/","title":"Event Dispatchers","text":"<p>A set of classes for dispatching events, they can be imported from <code>fluid.utils.dispatcher</code>:</p> <pre><code>from fluid.utils.dispatcher import Dispatcher\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.Event","title":"fluid.utils.dispatcher.Event","text":"<p>               Bases: <code>NamedTuple</code></p>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.Event.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type\n</code></pre> <p>The event type</p>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.Event.tag","title":"tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag = ''\n</code></pre> <p>The event tag - for registering multiple handlers for a given event type</p>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.Event.from_string_or_event","title":"from_string_or_event  <code>classmethod</code>","text":"<pre><code>from_string_or_event(event)\n</code></pre> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>@classmethod\ndef from_string_or_event(cls, event: str | Self) -&gt; Self:\n    if isinstance(event, str):\n        return cls.from_string(event)\n    return event\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.Event.from_string","title":"from_string  <code>classmethod</code>","text":"<pre><code>from_string(event)\n</code></pre> PARAMETER DESCRIPTION <code>event</code> <p>The event string has the form {event_type} or {event_type}.{event_tag}</p> <p> TYPE: <code>str</code> </p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>@classmethod\ndef from_string(\n    cls,\n    event: Annotated[\n        str,\n        Doc(\n            \"The event string has the form {event_type} or {event_type}.{event_tag}\"\n        ),\n    ],\n) -&gt; Self:\n    bits = event.split(\".\")\n    return cls(bits[0], bits[1] if len(bits) &gt; 1 else \"\")\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.BaseDispatcher","title":"fluid.utils.dispatcher.BaseDispatcher","text":"<pre><code>BaseDispatcher()\n</code></pre> <p>               Bases: <code>Generic[MessageType, MessageHandlerType]</code>, <code>ABC</code></p> <p>Base generic abstract class for dispatchers</p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._msg_handlers: defaultdict[str, dict[str, MessageHandlerType]] = (\n        defaultdict(\n            dict,\n        )\n    )\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.BaseDispatcher.register_handler","title":"register_handler","text":"<pre><code>register_handler(event, handler)\n</code></pre> <p>Register a handler for the given event</p> <p>It is possible to register multiple handlers for the same event type by providing a different tag for each handler.</p> <p>For example, to register two handlers for the event type <code>foo</code>:</p> <pre><code>dispatcher.register_handler(\"foo.first\", handler1)\ndispatcher.register_handler(\"foo.second\", handler2)\n</code></pre> PARAMETER DESCRIPTION <code>event</code> <p>The event to register the handler for</p> <p> TYPE: <code>Event | str</code> </p> <code>handler</code> <p>The handler to register</p> <p> TYPE: <code>MessageHandlerType</code> </p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def register_handler(\n    self,\n    event: Annotated[Event | str, Doc(\"The event to register the handler for\")],\n    handler: Annotated[MessageHandlerType, Doc(\"The handler to register\")],\n) -&gt; MessageHandlerType | None:\n    \"\"\"Register a handler for the given event\n\n    It is possible to register multiple handlers for the same event type by\n    providing a different tag for each handler.\n\n    For example, to register two handlers for the event type `foo`:\n\n    ```python\n    dispatcher.register_handler(\"foo.first\", handler1)\n    dispatcher.register_handler(\"foo.second\", handler2)\n    ```\n    \"\"\"\n    event = Event.from_string_or_event(event)\n    previous = self._msg_handlers[event.type].get(event.tag)\n    self._msg_handlers[event.type][event.tag] = handler\n    return previous\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.BaseDispatcher.unregister_handler","title":"unregister_handler","text":"<pre><code>unregister_handler(event)\n</code></pre> <p>Unregister a handler for the given event</p> <p>It returns the handler that was unregistered or <code>None</code> if no handler was registered for the given event.</p> PARAMETER DESCRIPTION <code>event</code> <p>The event to unregister the handler</p> <p> TYPE: <code>Event | str</code> </p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def unregister_handler(\n    self, event: Annotated[Event | str, Doc(\"The event to unregister the handler\")]\n) -&gt; MessageHandlerType | None:\n    \"\"\"Unregister a handler for the given event\n\n    It returns the handler that was unregistered or `None` if no handler was\n    registered for the given event.\n    \"\"\"\n    event = Event.from_string_or_event(event)\n    return self._msg_handlers[event.type].pop(event.tag, None)\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.BaseDispatcher.get_handlers","title":"get_handlers","text":"<pre><code>get_handlers(message)\n</code></pre> <p>Get all event handlers for the given message</p> <p>This method returns a dictionary of all handlers registered for the given message type. If no handlers are registered for the message type, it returns <code>None</code>.</p> PARAMETER DESCRIPTION <code>message</code> <p>The message to get the handlers for</p> <p> TYPE: <code>MessageType</code> </p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def get_handlers(\n    self,\n    message: Annotated[MessageType, Doc(\"The message to get the handlers for\")],\n) -&gt; dict[str, MessageHandlerType] | None:\n    \"\"\"Get all event handlers for the given message\n\n    This method returns a dictionary of all handlers registered for the given\n    message type. If no handlers are registered for the message type, it returns\n    `None`.\n    \"\"\"\n    event_type = self.event_type(message)\n    return self._msg_handlers.get(event_type)\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.BaseDispatcher.event_type","title":"event_type  <code>abstractmethod</code>","text":"<pre><code>event_type(message)\n</code></pre> <p>return the event type as string</p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>@abstractmethod\ndef event_type(self, message: MessageType) -&gt; str:\n    \"\"\"return the event type as string\"\"\"\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.Dispatcher","title":"fluid.utils.dispatcher.Dispatcher","text":"<pre><code>Dispatcher()\n</code></pre> <p>               Bases: <code>BaseDispatcher[MessageType, Callable[[MessageType], None]]</code></p> <p>Dispatcher for sync handlers</p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._msg_handlers: defaultdict[str, dict[str, MessageHandlerType]] = (\n        defaultdict(\n            dict,\n        )\n    )\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.Dispatcher.register_handler","title":"register_handler","text":"<pre><code>register_handler(event, handler)\n</code></pre> <p>Register a handler for the given event</p> <p>It is possible to register multiple handlers for the same event type by providing a different tag for each handler.</p> <p>For example, to register two handlers for the event type <code>foo</code>:</p> <pre><code>dispatcher.register_handler(\"foo.first\", handler1)\ndispatcher.register_handler(\"foo.second\", handler2)\n</code></pre> PARAMETER DESCRIPTION <code>event</code> <p>The event to register the handler for</p> <p> TYPE: <code>Event | str</code> </p> <code>handler</code> <p>The handler to register</p> <p> TYPE: <code>MessageHandlerType</code> </p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def register_handler(\n    self,\n    event: Annotated[Event | str, Doc(\"The event to register the handler for\")],\n    handler: Annotated[MessageHandlerType, Doc(\"The handler to register\")],\n) -&gt; MessageHandlerType | None:\n    \"\"\"Register a handler for the given event\n\n    It is possible to register multiple handlers for the same event type by\n    providing a different tag for each handler.\n\n    For example, to register two handlers for the event type `foo`:\n\n    ```python\n    dispatcher.register_handler(\"foo.first\", handler1)\n    dispatcher.register_handler(\"foo.second\", handler2)\n    ```\n    \"\"\"\n    event = Event.from_string_or_event(event)\n    previous = self._msg_handlers[event.type].get(event.tag)\n    self._msg_handlers[event.type][event.tag] = handler\n    return previous\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.Dispatcher.unregister_handler","title":"unregister_handler","text":"<pre><code>unregister_handler(event)\n</code></pre> <p>Unregister a handler for the given event</p> <p>It returns the handler that was unregistered or <code>None</code> if no handler was registered for the given event.</p> PARAMETER DESCRIPTION <code>event</code> <p>The event to unregister the handler</p> <p> TYPE: <code>Event | str</code> </p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def unregister_handler(\n    self, event: Annotated[Event | str, Doc(\"The event to unregister the handler\")]\n) -&gt; MessageHandlerType | None:\n    \"\"\"Unregister a handler for the given event\n\n    It returns the handler that was unregistered or `None` if no handler was\n    registered for the given event.\n    \"\"\"\n    event = Event.from_string_or_event(event)\n    return self._msg_handlers[event.type].pop(event.tag, None)\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.Dispatcher.get_handlers","title":"get_handlers","text":"<pre><code>get_handlers(message)\n</code></pre> <p>Get all event handlers for the given message</p> <p>This method returns a dictionary of all handlers registered for the given message type. If no handlers are registered for the message type, it returns <code>None</code>.</p> PARAMETER DESCRIPTION <code>message</code> <p>The message to get the handlers for</p> <p> TYPE: <code>MessageType</code> </p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def get_handlers(\n    self,\n    message: Annotated[MessageType, Doc(\"The message to get the handlers for\")],\n) -&gt; dict[str, MessageHandlerType] | None:\n    \"\"\"Get all event handlers for the given message\n\n    This method returns a dictionary of all handlers registered for the given\n    message type. If no handlers are registered for the message type, it returns\n    `None`.\n    \"\"\"\n    event_type = self.event_type(message)\n    return self._msg_handlers.get(event_type)\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.Dispatcher.event_type","title":"event_type  <code>abstractmethod</code>","text":"<pre><code>event_type(message)\n</code></pre> <p>return the event type as string</p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>@abstractmethod\ndef event_type(self, message: MessageType) -&gt; str:\n    \"\"\"return the event type as string\"\"\"\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.Dispatcher.dispatch","title":"dispatch","text":"<pre><code>dispatch(message)\n</code></pre> <p>dispatch the message to all handlers</p> <p>It returns the number of handlers that were called</p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def dispatch(self, message: MessageType) -&gt; int:\n    \"\"\"dispatch the message to all handlers\n\n    It returns the number of handlers that were called\n    \"\"\"\n    handlers = self.get_handlers(message)\n    if handlers:\n        for handler in handlers.values():\n            handler(message)\n    return len(handlers or ())\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.AsyncDispatcher","title":"fluid.utils.dispatcher.AsyncDispatcher","text":"<pre><code>AsyncDispatcher()\n</code></pre> <p>               Bases: <code>BaseDispatcher[MessageType, Callable[[MessageType], Awaitable[None]]]</code></p> <p>Dispatcher for async handlers</p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._msg_handlers: defaultdict[str, dict[str, MessageHandlerType]] = (\n        defaultdict(\n            dict,\n        )\n    )\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.AsyncDispatcher.register_handler","title":"register_handler","text":"<pre><code>register_handler(event, handler)\n</code></pre> <p>Register a handler for the given event</p> <p>It is possible to register multiple handlers for the same event type by providing a different tag for each handler.</p> <p>For example, to register two handlers for the event type <code>foo</code>:</p> <pre><code>dispatcher.register_handler(\"foo.first\", handler1)\ndispatcher.register_handler(\"foo.second\", handler2)\n</code></pre> PARAMETER DESCRIPTION <code>event</code> <p>The event to register the handler for</p> <p> TYPE: <code>Event | str</code> </p> <code>handler</code> <p>The handler to register</p> <p> TYPE: <code>MessageHandlerType</code> </p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def register_handler(\n    self,\n    event: Annotated[Event | str, Doc(\"The event to register the handler for\")],\n    handler: Annotated[MessageHandlerType, Doc(\"The handler to register\")],\n) -&gt; MessageHandlerType | None:\n    \"\"\"Register a handler for the given event\n\n    It is possible to register multiple handlers for the same event type by\n    providing a different tag for each handler.\n\n    For example, to register two handlers for the event type `foo`:\n\n    ```python\n    dispatcher.register_handler(\"foo.first\", handler1)\n    dispatcher.register_handler(\"foo.second\", handler2)\n    ```\n    \"\"\"\n    event = Event.from_string_or_event(event)\n    previous = self._msg_handlers[event.type].get(event.tag)\n    self._msg_handlers[event.type][event.tag] = handler\n    return previous\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.AsyncDispatcher.unregister_handler","title":"unregister_handler","text":"<pre><code>unregister_handler(event)\n</code></pre> <p>Unregister a handler for the given event</p> <p>It returns the handler that was unregistered or <code>None</code> if no handler was registered for the given event.</p> PARAMETER DESCRIPTION <code>event</code> <p>The event to unregister the handler</p> <p> TYPE: <code>Event | str</code> </p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def unregister_handler(\n    self, event: Annotated[Event | str, Doc(\"The event to unregister the handler\")]\n) -&gt; MessageHandlerType | None:\n    \"\"\"Unregister a handler for the given event\n\n    It returns the handler that was unregistered or `None` if no handler was\n    registered for the given event.\n    \"\"\"\n    event = Event.from_string_or_event(event)\n    return self._msg_handlers[event.type].pop(event.tag, None)\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.AsyncDispatcher.get_handlers","title":"get_handlers","text":"<pre><code>get_handlers(message)\n</code></pre> <p>Get all event handlers for the given message</p> <p>This method returns a dictionary of all handlers registered for the given message type. If no handlers are registered for the message type, it returns <code>None</code>.</p> PARAMETER DESCRIPTION <code>message</code> <p>The message to get the handlers for</p> <p> TYPE: <code>MessageType</code> </p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def get_handlers(\n    self,\n    message: Annotated[MessageType, Doc(\"The message to get the handlers for\")],\n) -&gt; dict[str, MessageHandlerType] | None:\n    \"\"\"Get all event handlers for the given message\n\n    This method returns a dictionary of all handlers registered for the given\n    message type. If no handlers are registered for the message type, it returns\n    `None`.\n    \"\"\"\n    event_type = self.event_type(message)\n    return self._msg_handlers.get(event_type)\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.AsyncDispatcher.event_type","title":"event_type  <code>abstractmethod</code>","text":"<pre><code>event_type(message)\n</code></pre> <p>return the event type as string</p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>@abstractmethod\ndef event_type(self, message: MessageType) -&gt; str:\n    \"\"\"return the event type as string\"\"\"\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.AsyncDispatcher.dispatch","title":"dispatch  <code>async</code>","text":"<pre><code>dispatch(message)\n</code></pre> <p>Dispatch the message and wait for all handlers to complete</p> <p>It returns the number of handlers that were called</p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>async def dispatch(self, message: MessageType) -&gt; int:\n    \"\"\"Dispatch the message and wait for all handlers to complete\n\n    It returns the number of handlers that were called\n    \"\"\"\n    handlers = self.get_handlers(message)\n    if handlers:\n        await asyncio.gather(*[handler(message) for handler in handlers.values()])\n    return len(handlers or ())\n</code></pre>"},{"location":"reference/task/","title":"Task","text":"<p>A Task defines the implementation of a given operation, the inputs required and the scheduling metadata. Usually, a Task is not created directly, but rather through the use of the @task decorator.</p>"},{"location":"reference/task/#example","title":"Example","text":"<p>A task function is decorated vya the @task decorator and must accept the TaskRun object as its first and only argument.</p> <pre><code>from fluid.scheduler import task, TaskRun\n\n@task\ndef hello(ctx: TaskRun) -&gt; None:\n    print(\"Hello, world!\")\n</code></pre>"},{"location":"reference/task/#fluid.scheduler.task","title":"fluid.scheduler.task","text":"<pre><code>task(executor: TaskExecutor) -&gt; Task\n</code></pre><pre><code>task(\n    *,\n    name: str | None = None,\n    schedule: Scheduler | None = None,\n    short_description: str | None = None,\n    description: str | None = None,\n    randomize: RandomizeType | None = None,\n    max_concurrency: int = 0,\n    priority: TaskPriority = medium,\n    cpu_bound: bool = False,\n    k8s_config: K8sConfig | None = None,\n    timeout_seconds: int = 60\n) -&gt; TaskConstructor\n</code></pre> <pre><code>task(executor=None, **kwargs)\n</code></pre> <p>Decorator to create a Task</p> <p>This decorator can be used in two ways:</p> <ul> <li>As a simple decorator of the executor function</li> <li>As a function with keyword arguments</li> </ul> Source code in <code>fluid/scheduler/models.py</code> <pre><code>def task(executor: TaskExecutor | None = None, **kwargs: Any) -&gt; Task | TaskConstructor:\n    \"\"\"Decorator to create a Task\n\n    This decorator can be used in two ways:\n\n    - As a simple decorator of the executor function\n    - As a function with keyword arguments\n    \"\"\"\n    if kwargs and executor:\n        raise TaskDecoratorError(\"cannot use positional parameters\")\n    elif kwargs:\n        return TaskConstructor(**kwargs)\n    elif not executor:\n        raise TaskDecoratorError(\"this is a decorator cannot be invoked in this way\")\n    else:\n        return TaskConstructor()(executor)\n</code></pre>"},{"location":"reference/task/#fluid.scheduler.Task","title":"fluid.scheduler.Task","text":"<p>               Bases: <code>NamedTuple</code>, <code>Generic[TP]</code></p> <p>A Task executes any time it is invoked</p>"},{"location":"reference/task/#fluid.scheduler.Task.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name\n</code></pre> <p>Task name - unique identifier</p>"},{"location":"reference/task/#fluid.scheduler.Task.executor","title":"executor  <code>instance-attribute</code>","text":"<pre><code>executor\n</code></pre> <p>Task executor function</p>"},{"location":"reference/task/#fluid.scheduler.Task.params_model","title":"params_model  <code>instance-attribute</code>","text":"<pre><code>params_model\n</code></pre> <p>Pydantic model for task parameters</p>"},{"location":"reference/task/#fluid.scheduler.Task.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger\n</code></pre> <p>Task logger</p>"},{"location":"reference/task/#fluid.scheduler.Task.module","title":"module  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>module = ''\n</code></pre> <p>Task python module</p>"},{"location":"reference/task/#fluid.scheduler.Task.short_description","title":"short_description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>short_description = ''\n</code></pre> <p>Short task description - one line</p>"},{"location":"reference/task/#fluid.scheduler.Task.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description = ''\n</code></pre> <p>Task description - obtained from the executor docstring if not provided</p>"},{"location":"reference/task/#fluid.scheduler.Task.schedule","title":"schedule  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>schedule = None\n</code></pre> <p>Task schedule - None means the task is not scheduled</p>"},{"location":"reference/task/#fluid.scheduler.Task.randomize","title":"randomize  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>randomize = None\n</code></pre> <p>Randomize function for task schedule</p>"},{"location":"reference/task/#fluid.scheduler.Task.max_concurrency","title":"max_concurrency  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_concurrency = 0\n</code></pre> <p>how many tasks can be run concurrently - 0 means no limit</p>"},{"location":"reference/task/#fluid.scheduler.Task.timeout_seconds","title":"timeout_seconds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timeout_seconds = 60\n</code></pre> <p>Task timeout in seconds - how long the task can run before being aborted</p>"},{"location":"reference/task/#fluid.scheduler.Task.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>priority = medium\n</code></pre> <p>Task priority - high, medium, low</p>"},{"location":"reference/task/#fluid.scheduler.Task.k8s_config","title":"k8s_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>k8s_config = from_env()\n</code></pre>"},{"location":"reference/task/#fluid.scheduler.Task.cpu_bound","title":"cpu_bound  <code>property</code>","text":"<pre><code>cpu_bound\n</code></pre> <p>True if the task is CPU bound</p>"},{"location":"reference/task/#fluid.scheduler.Task.info","title":"info","text":"<pre><code>info(**params)\n</code></pre> <p>Return task info object</p> Source code in <code>fluid/scheduler/models.py</code> <pre><code>def info(self, **params: Any) -&gt; TaskInfo:\n    \"\"\"Return task info object\"\"\"\n    params.update(\n        name=self.name,\n        description=self.description,\n        module=self.module,\n        priority=self.priority,\n        schedule=str(self.schedule) if self.schedule else None,\n    )\n    return TaskInfo(**compact_dict(params))\n</code></pre>"},{"location":"reference/task/#fluid.scheduler.TaskPriority","title":"fluid.scheduler.TaskPriority","text":"<p>               Bases: <code>StrEnum</code></p>"},{"location":"reference/task/#fluid.scheduler.TaskPriority.high","title":"high  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>high = auto()\n</code></pre>"},{"location":"reference/task/#fluid.scheduler.TaskPriority.medium","title":"medium  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>medium = auto()\n</code></pre>"},{"location":"reference/task/#fluid.scheduler.TaskPriority.low","title":"low  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>low = auto()\n</code></pre>"},{"location":"reference/task/#fluid.scheduler.TaskState","title":"fluid.scheduler.TaskState","text":"<p>               Bases: <code>StrEnum</code></p>"},{"location":"reference/task/#fluid.scheduler.TaskState.init","title":"init  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>init = auto()\n</code></pre>"},{"location":"reference/task/#fluid.scheduler.TaskState.queued","title":"queued  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>queued = auto()\n</code></pre>"},{"location":"reference/task/#fluid.scheduler.TaskState.running","title":"running  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>running = auto()\n</code></pre>"},{"location":"reference/task/#fluid.scheduler.TaskState.success","title":"success  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>success = auto()\n</code></pre>"},{"location":"reference/task/#fluid.scheduler.TaskState.failure","title":"failure  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>failure = auto()\n</code></pre>"},{"location":"reference/task/#fluid.scheduler.TaskState.aborted","title":"aborted  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>aborted = auto()\n</code></pre>"},{"location":"reference/task/#fluid.scheduler.TaskState.rate_limited","title":"rate_limited  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rate_limited = auto()\n</code></pre>"},{"location":"reference/task/#fluid.scheduler.TaskState.is_failure","title":"is_failure  <code>property</code>","text":"<pre><code>is_failure\n</code></pre>"},{"location":"reference/task/#fluid.scheduler.TaskState.is_done","title":"is_done  <code>property</code>","text":"<pre><code>is_done\n</code></pre>"},{"location":"reference/task_broker/","title":"Task Broker","text":"<p>It can be imported from <code>fluid.scheduler</code>:</p> <pre><code>from fastapi.scheduler import TaskBroker\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker","title":"fluid.scheduler.TaskBroker","text":"<pre><code>TaskBroker(url)\n</code></pre> <p>               Bases: <code>ABC</code></p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>def __init__(self, url: URL) -&gt; None:\n    self.url: URL = url\n    self.registry: TaskRegistry = TaskRegistry()\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url = url\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.registry","title":"registry  <code>instance-attribute</code>","text":"<pre><code>registry = TaskRegistry()\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.task_queue_names","title":"task_queue_names  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>task_queue_names\n</code></pre> <p>Names of the task queues</p>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.queue_task","title":"queue_task  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>queue_task(task_run)\n</code></pre> <p>Queue a task</p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>@abstractmethod\nasync def queue_task(self, task_run: TaskRun) -&gt; None:\n    \"\"\"Queue a task\"\"\"\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.get_task_run","title":"get_task_run  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get_task_run(task_manager)\n</code></pre> <p>Get a Task run from the task queue</p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>@abstractmethod\nasync def get_task_run(self, task_manager: TaskManager) -&gt; TaskRun | None:\n    \"\"\"Get a Task run from the task queue\"\"\"\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.queue_length","title":"queue_length  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>queue_length()\n</code></pre> <p>Length of task queues</p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>@abstractmethod\nasync def queue_length(self) -&gt; dict[str, int]:\n    \"\"\"Length of task queues\"\"\"\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.get_tasks_info","title":"get_tasks_info  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get_tasks_info(*task_names)\n</code></pre> <p>List of TaskInfo objects</p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>@abstractmethod\nasync def get_tasks_info(self, *task_names: str) -&gt; list[TaskInfo]:\n    \"\"\"List of TaskInfo objects\"\"\"\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.update_task","title":"update_task  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>update_task(task, params)\n</code></pre> <p>Update a task dynamic parameters</p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>@abstractmethod\nasync def update_task(self, task: Task, params: dict[str, Any]) -&gt; TaskInfo:\n    \"\"\"Update a task dynamic parameters\"\"\"\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.add_task_run","title":"add_task_run  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>add_task_run(task_run)\n</code></pre> <p>Add a task run to the broker</p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>@abstractmethod\nasync def add_task_run(self, task_run: TaskRun) -&gt; None:\n    \"\"\"Add a task run to the broker\"\"\"\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.remove_task_run","title":"remove_task_run  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>remove_task_run(task_run)\n</code></pre> <p>Remove a task run from the broker</p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>@abstractmethod\nasync def remove_task_run(self, task_run: TaskRun) -&gt; None:\n    \"\"\"Remove a task run from the broker\"\"\"\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.current_task_runs","title":"current_task_runs  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>current_task_runs(task_name)\n</code></pre> <p>The number of current task runs for a given task_name</p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>@abstractmethod\nasync def current_task_runs(self, task_name: str) -&gt; int:\n    \"\"\"The number of current task runs for a given task_name\"\"\"\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.close","title":"close  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Close the broker on shutdown</p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>@abstractmethod\nasync def close(self) -&gt; None:\n    \"\"\"Close the broker on shutdown\"\"\"\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.lock","title":"lock  <code>abstractmethod</code>","text":"<pre><code>lock(name, timeout=None)\n</code></pre> <p>Create a lock</p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>@abstractmethod\ndef lock(self, name: str, timeout: float | None = None) -&gt; Lock:\n    \"\"\"Create a lock\"\"\"\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.new_uuid","title":"new_uuid","text":"<pre><code>new_uuid()\n</code></pre> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>def new_uuid(self) -&gt; str:\n    return uuid4().hex\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.filter_tasks","title":"filter_tasks  <code>async</code>","text":"<pre><code>filter_tasks(scheduled=None, enabled=None)\n</code></pre> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>async def filter_tasks(\n    self,\n    scheduled: bool | None = None,\n    enabled: bool | None = None,\n) -&gt; list[Task]:\n    task_info = await self.get_tasks_info()\n    task_map = {info.name: info for info in task_info}\n    tasks = []\n    for task in self.registry.values():\n        if scheduled is not None and bool(task.schedule) is not scheduled:\n            continue\n        if enabled is not None and task_map[task.name].enabled is not enabled:\n            continue\n        tasks.append(task)\n    return tasks\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.task_from_registry","title":"task_from_registry","text":"<pre><code>task_from_registry(task)\n</code></pre> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>def task_from_registry(self, task: str | Task) -&gt; Task:\n    if isinstance(task, Task):\n        self.register_task(task)\n        return task\n    else:\n        if task_ := self.registry.get(task):\n            return task_\n        raise UnknownTaskError(task)\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.register_task","title":"register_task","text":"<pre><code>register_task(task)\n</code></pre> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>def register_task(self, task: Task) -&gt; None:\n    self.registry[task.name] = task\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.enable_task","title":"enable_task  <code>async</code>","text":"<pre><code>enable_task(task, enable=True)\n</code></pre> <p>Enable or disable a registered task</p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>async def enable_task(self, task: str | Task, enable: bool = True) -&gt; TaskInfo:\n    \"\"\"Enable or disable a registered task\"\"\"\n    task_ = self.task_from_registry(task)\n    return await self.update_task(task_, dict(enabled=enable))\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.from_url","title":"from_url  <code>classmethod</code>","text":"<pre><code>from_url(url='')\n</code></pre> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>@classmethod\ndef from_url(cls, url: str = \"\") -&gt; TaskBroker:\n    p = URL(url or broker_url_from_env())\n    if factory := _brokers.get(p.scheme):\n        return factory(p)\n    raise RuntimeError(f\"Invalid broker {p}\")\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.register_broker","title":"register_broker  <code>classmethod</code>","text":"<pre><code>register_broker(name, factory)\n</code></pre> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>@classmethod\ndef register_broker(cls, name: str, factory: type[TaskBroker]) -&gt; None:\n    _brokers[name] = factory\n</code></pre>"},{"location":"reference/task_cli/","title":"Task Manager Cli","text":"<p>Command line tools for task manager applications.</p> <p>This modules requires the <code>cli</code> extra to be installed.</p> <p><pre><code>$ pip install aio-fluid[cli]\n</code></pre> It can be imported from <code>fluid.scheduler.cli</code>:</p> <pre><code>from fastapi.scheduler.cli import TaskManagerCLI\n\nif __name__ == \"__main__\":\n    cli = TaskManagerCLI(\"path.to:task_app\")\n    cli()\n</code></pre>"},{"location":"reference/task_cli/#fluid.scheduler.cli.TaskManagerCLI","title":"fluid.scheduler.cli.TaskManagerCLI","text":"<pre><code>TaskManagerCLI(task_manager_app, **kwargs)\n</code></pre> <p>               Bases: <code>LazyGroup</code></p> <p>CLI for TaskManager</p> <p>This class provides a CLI for a TaskManager Application.</p> <p>It requires to install the <code>cli</code> extra dependencies.</p> Source code in <code>fluid/scheduler/cli.py</code> <pre><code>def __init__(\n    self,\n    task_manager_app: TaskManagerApp,\n    **kwargs: Any,\n):\n    kwargs.setdefault(\"commands\", DEFAULT_COMMANDS)\n    super().__init__(**kwargs)\n    self.task_manager_app = task_manager_app\n</code></pre>"},{"location":"reference/task_cli/#fluid.scheduler.cli.TaskManagerCLI.lazy_subcommands","title":"lazy_subcommands  <code>instance-attribute</code>","text":"<pre><code>lazy_subcommands = lazy_subcommands or {}\n</code></pre>"},{"location":"reference/task_cli/#fluid.scheduler.cli.TaskManagerCLI.task_manager_app","title":"task_manager_app  <code>instance-attribute</code>","text":"<pre><code>task_manager_app = task_manager_app\n</code></pre>"},{"location":"reference/task_cli/#fluid.scheduler.cli.TaskManagerCLI.list_commands","title":"list_commands","text":"<pre><code>list_commands(ctx)\n</code></pre> Source code in <code>fluid/utils/lazy.py</code> <pre><code>def list_commands(self, ctx: click.Context) -&gt; list[str]:\n    commands = super().list_commands(ctx)\n    commands.extend(self.lazy_subcommands)\n    return sorted(commands)\n</code></pre>"},{"location":"reference/task_cli/#fluid.scheduler.cli.TaskManagerCLI.get_command","title":"get_command","text":"<pre><code>get_command(ctx, cmd_name)\n</code></pre> Source code in <code>fluid/utils/lazy.py</code> <pre><code>def get_command(self, ctx: click.Context, cmd_name: str) -&gt; click.Command | None:\n    if cmd_name in self.lazy_subcommands:\n        return self._lazy_load(cmd_name)\n    return super().get_command(ctx, cmd_name)\n</code></pre>"},{"location":"reference/task_manager/","title":"Task Manager","text":"<p>The Task Manager is a component that manages the execution of tasks. It is the simplest way to run tasks and it is the base class for the TaskConsumer and theTaskScheduler.</p> <p>It can be imported from <code>fluid.scheduler</code>:</p> <pre><code>from fastapi.scheduler import TaskManager\n</code></pre> <p>The Task Manager is useful if you want to execute tasks in a synchronous or asynchronous way.</p>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager","title":"fluid.scheduler.TaskManager","text":"<pre><code>TaskManager(*, deps=None, config=None, **kwargs)\n</code></pre> <p>The task manager is the main class for managing tasks</p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def __init__(\n    self,\n    *,\n    deps: Any = None,\n    config: TaskManagerConfig | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    self.deps: Annotated[\n        Any,\n        Doc(\n            \"\"\"\n            Dependencies for the task manager.\n\n            Production applications requires global dependencies to be\n            available to all tasks. This can be achieved by setting\n            the `deps` attribute of the task manager to an object\n            with the required dependencies.\n\n            Each task can cast the dependencies to the required type.\n            \"\"\"\n        ),\n    ] = (\n        deps if deps is not None else State()\n    )\n    self.config: Annotated[\n        TaskManagerConfig, Doc(\"\"\"Task manager configuration\"\"\")\n    ] = config or TaskManagerConfig(**kwargs)\n    self.dispatcher: Annotated[\n        TaskDispatcher,\n        Doc(\n            \"\"\"\n            A dispatcher of [TaskRun][fluid.scheduler.TaskRun] events.\n\n            Application can register handlers to listen for events\n            happening during the lifecycle of a task run.\n            \"\"\"\n        ),\n    ] = TaskDispatcher()\n    self.broker = TaskBroker.from_url(self.config.broker_url)\n    self._async_contexts: list[Any] = []\n    self._stack = AsyncExitStack()\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.deps","title":"deps  <code>instance-attribute</code>","text":"<pre><code>deps = deps if deps is not None else State()\n</code></pre> <p>Dependencies for the task manager.</p> <p>Production applications requires global dependencies to be available to all tasks. This can be achieved by setting the <code>deps</code> attribute of the task manager to an object with the required dependencies.</p> <p>Each task can cast the dependencies to the required type.</p>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config = config or TaskManagerConfig(**kwargs)\n</code></pre> <p>Task manager configuration</p>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.dispatcher","title":"dispatcher  <code>instance-attribute</code>","text":"<pre><code>dispatcher = TaskDispatcher()\n</code></pre> <p>A dispatcher of TaskRun events.</p> <p>Application can register handlers to listen for events happening during the lifecycle of a task run.</p>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.broker","title":"broker  <code>instance-attribute</code>","text":"<pre><code>broker = from_url(broker_url)\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.registry","title":"registry  <code>property</code>","text":"<pre><code>registry\n</code></pre> <p>The task registry</p>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.type","title":"type  <code>property</code>","text":"<pre><code>type\n</code></pre> <p>The type of the task manager</p>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.on_startup","title":"on_startup  <code>async</code>","text":"<pre><code>on_startup()\n</code></pre> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>async def on_startup(self) -&gt; None:\n    await self.__aenter__()\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.on_shutdown","title":"on_shutdown  <code>async</code>","text":"<pre><code>on_shutdown()\n</code></pre> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>async def on_shutdown(self) -&gt; None:\n    await self.__aexit__(None, None, None)\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.add_async_context_manager","title":"add_async_context_manager","text":"<pre><code>add_async_context_manager(cm)\n</code></pre> <p>Add an async context manager to the task manager</p> <p>These context managers are entered when the task manager starts</p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def add_async_context_manager(self, cm: Any) -&gt; None:\n    \"\"\"Add an async context manager to the task manager\n\n    These context managers are entered when the task manager starts\n    \"\"\"\n    self._async_contexts.append(cm)\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.register_task","title":"register_task","text":"<pre><code>register_task(task)\n</code></pre> <p>Register a task with the task manager</p> PARAMETER DESCRIPTION <code>task</code> <p>Task to register</p> <p> TYPE: <code>Task</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def register_task(self, task: Annotated[Task, Doc(\"Task to register\")]) -&gt; None:\n    \"\"\"Register a task with the task manager\"\"\"\n    self.broker.register_task(task)\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.execute","title":"execute  <code>async</code>","text":"<pre><code>execute(task, *, run_id='', priority=None, **params)\n</code></pre> <p>Execute a task and wait for it to finish</p> PARAMETER DESCRIPTION <code>task</code> <p>The task or task name, if a task name it must be registered with the task manager.</p> <p> TYPE: <code>str | Task</code> </p> <code>run_id</code> <p>Unique ID for the task run. If not provided a new UUID is generated.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>priority</code> <p>Override the default task priority if provided</p> <p> TYPE: <code>TaskPriority | None</code> DEFAULT: <code>None</code> </p> <code>**params</code> <p>The optional parameters for the task run. They must match the task params model</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>async def execute(\n    self,\n    task: Annotated[\n        str | Task,\n        Doc(\n            \"The task or task name,\"\n            \" if a task name it must be registered with the task manager.\"\n        ),\n    ],\n    *,\n    run_id: Annotated[\n        str,\n        Doc(\"Unique ID for the task run. If not provided a new UUID is generated.\"),\n    ] = \"\",\n    priority: Annotated[\n        TaskPriority | None, Doc(\"Override the default task priority if provided\")\n    ] = None,\n    **params: Annotated[\n        Any,\n        Doc(\n            \"The optional parameters for the task run. \"\n            \"They must match the task params model\"\n        ),\n    ],\n) -&gt; TaskRun:\n    \"\"\"Execute a task and wait for it to finish\"\"\"\n    task_run = self.create_task_run(\n        task,\n        run_id=run_id,\n        priority=priority,\n        **params,\n    )\n    await task_run.execute()\n    return task_run\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.execute_sync","title":"execute_sync","text":"<pre><code>execute_sync(task, *, run_id='', priority=None, **params)\n</code></pre> <p>Execute a task synchronously</p> <p>This method is a blocking method that should be used in a synchronous context.</p> PARAMETER DESCRIPTION <code>task</code> <p>The task or task name, if a task name it must be registered with the task manager.</p> <p> TYPE: <code>str | Task</code> </p> <code>run_id</code> <p>Unique ID for the task run. If not provided a new UUID is generated.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>priority</code> <p>Override the default task priority if provided</p> <p> TYPE: <code>TaskPriority | None</code> DEFAULT: <code>None</code> </p> <code>**params</code> <p>The optional parameters for the task run. They must match the task params model</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def execute_sync(\n    self,\n    task: Annotated[\n        str | Task,\n        Doc(\n            \"The task or task name,\"\n            \" if a task name it must be registered with the task manager.\"\n        ),\n    ],\n    *,\n    run_id: Annotated[\n        str,\n        Doc(\"Unique ID for the task run. If not provided a new UUID is generated.\"),\n    ] = \"\",\n    priority: Annotated[\n        TaskPriority | None, Doc(\"Override the default task priority if provided\")\n    ] = None,\n    **params: Annotated[\n        Any,\n        Doc(\n            \"The optional parameters for the task run. \"\n            \"They must match the task params model\"\n        ),\n    ],\n) -&gt; TaskRun:\n    \"\"\"Execute a task synchronously\n\n    This method is a blocking method that should be used in a synchronous\n    context.\n    \"\"\"\n    return asyncio.run(\n        self._execute_and_exit(\n            task,\n            run_id=run_id,\n            priority=priority,\n            **params,\n        )\n    )\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.queue","title":"queue  <code>async</code>","text":"<pre><code>queue(task, *, run_id='', priority=None, **params)\n</code></pre> <p>Queue a task for execution</p> <p>This methods fires two events:</p> <ul> <li><code>init</code>: when the task run is created</li> <li><code>queued</code>: after the task is queued</li> </ul> <p>It returns the TaskRun object</p> PARAMETER DESCRIPTION <code>task</code> <p>The task or task name, if a task name it must be registered with the task manager.</p> <p> TYPE: <code>str | Task</code> </p> <code>run_id</code> <p>Unique ID for the task run. If not provided a new UUID is generated.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>priority</code> <p>Override the default task priority if provided</p> <p> TYPE: <code>TaskPriority | None</code> DEFAULT: <code>None</code> </p> <code>**params</code> <p>The optional parameters for the task run. They must match the task params model</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>async def queue(\n    self,\n    task: Annotated[\n        str | Task,\n        Doc(\n            \"The task or task name,\"\n            \" if a task name it must be registered with the task manager.\"\n        ),\n    ],\n    *,\n    run_id: Annotated[\n        str,\n        Doc(\"Unique ID for the task run. If not provided a new UUID is generated.\"),\n    ] = \"\",\n    priority: Annotated[\n        TaskPriority | None, Doc(\"Override the default task priority if provided\")\n    ] = None,\n    **params: Annotated[\n        Any,\n        Doc(\n            \"The optional parameters for the task run. \"\n            \"They must match the task params model\"\n        ),\n    ],\n) -&gt; TaskRun:\n    \"\"\"Queue a task for execution\n\n    This methods fires two events:\n\n    - `init`: when the task run is created\n    - `queued`: after the task is queued\n\n    It returns the [TaskRun][fluid.scheduler.TaskRun] object\n    \"\"\"\n    task_run = self.create_task_run(\n        task,\n        run_id=run_id,\n        priority=priority,\n        **params,\n    )\n    self.dispatcher.dispatch(task_run)\n    task_run.set_state(TaskState.queued)\n    await self.broker.queue_task(task_run)\n    return task_run\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.create_task_run","title":"create_task_run","text":"<pre><code>create_task_run(\n    task, *, run_id=\"\", priority=None, **params\n)\n</code></pre> <p>Create a TaskRun in <code>init</code> state</p> PARAMETER DESCRIPTION <code>task</code> <p>The task or task name, if a task name it must be registered with the task manager.</p> <p> TYPE: <code>str | Task</code> </p> <code>run_id</code> <p>Unique ID for the task run. If not provided a new UUID is generated.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>priority</code> <p>Override the default task priority if provided</p> <p> TYPE: <code>TaskPriority | None</code> DEFAULT: <code>None</code> </p> <code>**params</code> <p>The optional parameters for the task run. They must match the task params model</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def create_task_run(\n    self,\n    task: Annotated[\n        str | Task,\n        Doc(\n            \"The task or task name,\"\n            \" if a task name it must be registered with the task manager.\"\n        ),\n    ],\n    *,\n    run_id: Annotated[\n        str,\n        Doc(\"Unique ID for the task run. If not provided a new UUID is generated.\"),\n    ] = \"\",\n    priority: Annotated[\n        TaskPriority | None, Doc(\"Override the default task priority if provided\")\n    ] = None,\n    **params: Annotated[\n        Any,\n        Doc(\n            \"The optional parameters for the task run. \"\n            \"They must match the task params model\"\n        ),\n    ],\n) -&gt; TaskRun:\n    \"\"\"Create a [TaskRun][fluid.scheduler.TaskRun] in `init` state\"\"\"\n    task = self.broker.task_from_registry(task)\n    run_id = run_id or self.broker.new_uuid()\n    return TaskRun(\n        id=run_id,\n        task=task,\n        priority=priority or task.priority,\n        params=task.params_model(**params),\n        task_manager=self,\n    )\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.register_from_module","title":"register_from_module","text":"<pre><code>register_from_module(module)\n</code></pre> <p>Register tasks from a python module</p> PARAMETER DESCRIPTION <code>module</code> <p>Python module with tasks implementations - can contain any object, only instances of Task are registered</p> <p> TYPE: <code>ModuleType</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def register_from_module(\n    self,\n    module: Annotated[\n        ModuleType,\n        Doc(\n            \"Python module with tasks implementations \"\n            \"- can contain any object, only instances of Task are registered\"\n        ),\n    ],\n) -&gt; None:\n    \"\"\"Register tasks from a python module\"\"\"\n    for name in dir(module):\n        if name.startswith(\"_\"):\n            continue\n        if isinstance(obj := getattr(module, name), Task):\n            self.register_task(obj)\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.register_from_dict","title":"register_from_dict","text":"<pre><code>register_from_dict(data)\n</code></pre> <p>Register tasks from a python dictionary</p> PARAMETER DESCRIPTION <code>data</code> <p>Python dictionary with tasks implementations - can contain any object, only instances of Task are registered</p> <p> TYPE: <code>dict[str, Any]</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def register_from_dict(\n    self,\n    data: Annotated[\n        dict[str, Any],\n        Doc(\n            \"Python dictionary with tasks implementations \"\n            \"- can contain any object, only instances of Task are registered\"\n        ),\n    ],\n) -&gt; None:\n    \"\"\"Register tasks from a python dictionary\"\"\"\n    for name, obj in data.items():\n        if name.startswith(\"_\"):\n            continue\n        if isinstance(obj, Task):\n            self.register_task(obj)\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.register_async_handler","title":"register_async_handler","text":"<pre><code>register_async_handler(event, handler)\n</code></pre> <p>Register an async handler for a given event</p> <p>This method is a no op for a TaskManager that is not a worker</p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def register_async_handler(self, event: str, handler: AsyncHandler) -&gt; None:\n    \"\"\"Register an async handler for a given event\n\n    This method is a no op for a TaskManager that is not a worker\n    \"\"\"\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.unregister_async_handler","title":"unregister_async_handler","text":"<pre><code>unregister_async_handler(event)\n</code></pre> <p>Unregister an async handler for a given event</p> <p>This method is a no op for a TaskManager that is not a worker</p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def unregister_async_handler(self, event: Event | str) -&gt; AsyncHandler | None:\n    \"\"\"Unregister an async handler for a given event\n\n    This method is a no op for a TaskManager that is not a worker\n    \"\"\"\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManagerConfig","title":"fluid.scheduler.TaskManagerConfig  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Task manager configuration</p> <p>Fields:</p> <ul> <li> <code>schedule_tasks</code>                 (<code>bool</code>)             </li> <li> <code>consume_tasks</code>                 (<code>bool</code>)             </li> <li> <code>max_concurrent_tasks</code>                 (<code>int</code>)             </li> <li> <code>sleep_millis</code>                 (<code>int</code>)             </li> <li> <code>broker_url</code>                 (<code>str</code>)             </li> </ul>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManagerConfig.schedule_tasks","title":"schedule_tasks  <code>pydantic-field</code>","text":"<pre><code>schedule_tasks = True\n</code></pre> <p>Schedule tasks or sleep</p>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManagerConfig.consume_tasks","title":"consume_tasks  <code>pydantic-field</code>","text":"<pre><code>consume_tasks = True\n</code></pre> <p>Consume tasks or sleep</p>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManagerConfig.max_concurrent_tasks","title":"max_concurrent_tasks  <code>pydantic-field</code>","text":"<pre><code>max_concurrent_tasks = MAX_CONCURRENT_TASKS\n</code></pre> <p>The number of coroutine workers consuming tasks. Each worker consumes one task at a time, therefore, this number is the maximum number of tasks that can run concurrently.It can be configured via the <code>FLUID_MAX_CONCURRENT_TASKS</code> environment variable, and by default is set to 5.</p>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManagerConfig.sleep_millis","title":"sleep_millis  <code>pydantic-field</code>","text":"<pre><code>sleep_millis = SLEEP_MILLIS\n</code></pre> <p>Milliseconds to async sleep when no tasks available to consume.This value can be configured via the <code>FLUID_SLEEP_MILLIS</code> environment variable, and by default is set to 1000 milliseconds (1 second).</p>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManagerConfig.broker_url","title":"broker_url  <code>pydantic-field</code>","text":"<pre><code>broker_url = ''\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManagerConfig.sleep","title":"sleep  <code>property</code>","text":"<pre><code>sleep\n</code></pre> <p>Sleep time in seconds</p>"},{"location":"reference/task_manager/#fluid.scheduler.consumer.TaskDispatcher","title":"fluid.scheduler.consumer.TaskDispatcher","text":"<pre><code>TaskDispatcher()\n</code></pre> <p>               Bases: <code>Dispatcher[TaskRun]</code></p> <p>The task dispatcher is responsible for dispatching task run messages</p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._msg_handlers: defaultdict[str, dict[str, MessageHandlerType]] = (\n        defaultdict(\n            dict,\n        )\n    )\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.consumer.TaskDispatcher.register_handler","title":"register_handler","text":"<pre><code>register_handler(event, handler)\n</code></pre> <p>Register a handler for the given event</p> <p>It is possible to register multiple handlers for the same event type by providing a different tag for each handler.</p> <p>For example, to register two handlers for the event type <code>foo</code>:</p> <pre><code>dispatcher.register_handler(\"foo.first\", handler1)\ndispatcher.register_handler(\"foo.second\", handler2)\n</code></pre> PARAMETER DESCRIPTION <code>event</code> <p>The event to register the handler for</p> <p> TYPE: <code>Event | str</code> </p> <code>handler</code> <p>The handler to register</p> <p> TYPE: <code>MessageHandlerType</code> </p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def register_handler(\n    self,\n    event: Annotated[Event | str, Doc(\"The event to register the handler for\")],\n    handler: Annotated[MessageHandlerType, Doc(\"The handler to register\")],\n) -&gt; MessageHandlerType | None:\n    \"\"\"Register a handler for the given event\n\n    It is possible to register multiple handlers for the same event type by\n    providing a different tag for each handler.\n\n    For example, to register two handlers for the event type `foo`:\n\n    ```python\n    dispatcher.register_handler(\"foo.first\", handler1)\n    dispatcher.register_handler(\"foo.second\", handler2)\n    ```\n    \"\"\"\n    event = Event.from_string_or_event(event)\n    previous = self._msg_handlers[event.type].get(event.tag)\n    self._msg_handlers[event.type][event.tag] = handler\n    return previous\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.consumer.TaskDispatcher.unregister_handler","title":"unregister_handler","text":"<pre><code>unregister_handler(event)\n</code></pre> <p>Unregister a handler for the given event</p> <p>It returns the handler that was unregistered or <code>None</code> if no handler was registered for the given event.</p> PARAMETER DESCRIPTION <code>event</code> <p>The event to unregister the handler</p> <p> TYPE: <code>Event | str</code> </p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def unregister_handler(\n    self, event: Annotated[Event | str, Doc(\"The event to unregister the handler\")]\n) -&gt; MessageHandlerType | None:\n    \"\"\"Unregister a handler for the given event\n\n    It returns the handler that was unregistered or `None` if no handler was\n    registered for the given event.\n    \"\"\"\n    event = Event.from_string_or_event(event)\n    return self._msg_handlers[event.type].pop(event.tag, None)\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.consumer.TaskDispatcher.get_handlers","title":"get_handlers","text":"<pre><code>get_handlers(message)\n</code></pre> <p>Get all event handlers for the given message</p> <p>This method returns a dictionary of all handlers registered for the given message type. If no handlers are registered for the message type, it returns <code>None</code>.</p> PARAMETER DESCRIPTION <code>message</code> <p>The message to get the handlers for</p> <p> TYPE: <code>MessageType</code> </p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def get_handlers(\n    self,\n    message: Annotated[MessageType, Doc(\"The message to get the handlers for\")],\n) -&gt; dict[str, MessageHandlerType] | None:\n    \"\"\"Get all event handlers for the given message\n\n    This method returns a dictionary of all handlers registered for the given\n    message type. If no handlers are registered for the message type, it returns\n    `None`.\n    \"\"\"\n    event_type = self.event_type(message)\n    return self._msg_handlers.get(event_type)\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.consumer.TaskDispatcher.dispatch","title":"dispatch","text":"<pre><code>dispatch(message)\n</code></pre> <p>dispatch the message to all handlers</p> <p>It returns the number of handlers that were called</p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def dispatch(self, message: MessageType) -&gt; int:\n    \"\"\"dispatch the message to all handlers\n\n    It returns the number of handlers that were called\n    \"\"\"\n    handlers = self.get_handlers(message)\n    if handlers:\n        for handler in handlers.values():\n            handler(message)\n    return len(handlers or ())\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.consumer.TaskDispatcher.event_type","title":"event_type","text":"<pre><code>event_type(message)\n</code></pre> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def event_type(self, message: TaskRun) -&gt; str:\n    return message.state\n</code></pre>"},{"location":"reference/task_registry/","title":"Task Registry","text":""},{"location":"reference/task_registry/#fluid.scheduler.broker.TaskRegistry","title":"fluid.scheduler.broker.TaskRegistry","text":"<p>               Bases: <code>dict[str, Task[TP]]</code></p> <p>A registry of tasks</p>"},{"location":"reference/task_registry/#fluid.scheduler.broker.TaskRegistry.periodic","title":"periodic","text":"<pre><code>periodic()\n</code></pre> <p>Iterate over periodic tasks</p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>def periodic(self) -&gt; Iterable[Task]:\n    \"\"\"Iterate over periodic tasks\"\"\"\n    for task in self.values():\n        yield task\n</code></pre>"},{"location":"reference/task_run/","title":"Task Run","text":"<p>It can be imported from <code>fluid.scheduler</code>:</p> <pre><code>from fastapi.scheduler import TaskRun\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun","title":"fluid.scheduler.TaskRun  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[TP]</code></p> <p>A TaskRun contains all the data generated by a Task run</p> <p>This model is never initialized directly, it is created by the TaskManager</p> <p>Fields:</p> <ul> <li> <code>id</code>                 (<code>str</code>)             </li> <li> <code>task</code>                 (<code>Task</code>)             </li> <li> <code>priority</code>                 (<code>TaskPriority</code>)             </li> <li> <code>params</code>                 (<code>TP</code>)             </li> <li> <code>state</code>                 (<code>TaskState</code>)             </li> <li> <code>task_manager</code>                 (<code>TaskManager</code>)             </li> <li> <code>queued</code>                 (<code>datetime | None</code>)             </li> <li> <code>start</code>                 (<code>datetime | None</code>)             </li> <li> <code>end</code>                 (<code>datetime | None</code>)             </li> </ul>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.id","title":"id  <code>pydantic-field</code>","text":"<pre><code>id\n</code></pre> <p>Unique task run id</p>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.task","title":"task  <code>pydantic-field</code>","text":"<pre><code>task\n</code></pre> <p>Task to be executed</p>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.priority","title":"priority  <code>pydantic-field</code>","text":"<pre><code>priority\n</code></pre> <p>Task priority</p>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.params","title":"params  <code>pydantic-field</code>","text":"<pre><code>params\n</code></pre> <p>Task parameters</p>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.state","title":"state  <code>pydantic-field</code>","text":"<pre><code>state = init\n</code></pre> <p>Task state</p>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.task_manager","title":"task_manager  <code>pydantic-field</code>","text":"<pre><code>task_manager\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.queued","title":"queued  <code>pydantic-field</code>","text":"<pre><code>queued = None\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.start","title":"start  <code>pydantic-field</code>","text":"<pre><code>start = None\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.end","title":"end  <code>pydantic-field</code>","text":"<pre><code>end = None\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.logger","title":"logger  <code>property</code>","text":"<pre><code>logger\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.in_queue","title":"in_queue  <code>property</code>","text":"<pre><code>in_queue\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.duration","title":"duration  <code>property</code>","text":"<pre><code>duration\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.duration_ms","title":"duration_ms  <code>property</code>","text":"<pre><code>duration_ms\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.total","title":"total  <code>property</code>","text":"<pre><code>total\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.name","title":"name  <code>property</code>","text":"<pre><code>name\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.name_id","title":"name_id  <code>property</code>","text":"<pre><code>name_id\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.is_done","title":"is_done  <code>property</code>","text":"<pre><code>is_done\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.is_failure","title":"is_failure  <code>property</code>","text":"<pre><code>is_failure\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.deps","title":"deps  <code>property</code>","text":"<pre><code>deps\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.execute","title":"execute  <code>async</code>","text":"<pre><code>execute()\n</code></pre> <p>Execute the task</p> Source code in <code>fluid/scheduler/models.py</code> <pre><code>async def execute(self) -&gt; None:\n    \"\"\"Execute the task\"\"\"\n    try:\n        self.set_state(TaskState.running)\n        async with asyncio.timeout(self.task.timeout_seconds):\n            await self.task.executor(self)  # type: ignore [arg-type]\n    except Exception:\n        self.set_state(TaskState.failure)\n        raise\n    else:\n        self.set_state(TaskState.success)\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.set_state","title":"set_state","text":"<pre><code>set_state(state, state_time=None)\n</code></pre> Source code in <code>fluid/scheduler/models.py</code> <pre><code>def set_state(\n    self,\n    state: TaskState,\n    state_time: datetime | None = None,\n) -&gt; None:\n    if self.state == state:\n        return\n    state_time = as_utc(state_time)\n    match (self.state, state):\n        case (TaskState.init, TaskState.queued):\n            self.queued = state_time\n            self.state = state\n            self._dispatch()\n        case (TaskState.init, _):\n            self.set_state(TaskState.queued, state_time)\n            self.set_state(state, state_time)\n        case (TaskState.queued, TaskState.running):\n            self.start = state_time\n            self.state = state\n            self._dispatch()\n        case (\n            TaskState.queued,\n            TaskState.success\n            | TaskState.aborted\n            | TaskState.rate_limited\n            | TaskState.failure,\n        ):\n            self.set_state(TaskState.running, state_time)\n            self.set_state(state, state_time)\n        case (\n            TaskState.running,\n            TaskState.success\n            | TaskState.aborted\n            | TaskState.rate_limited\n            | TaskState.failure,\n        ):\n            self.end = state_time\n            self.state = state\n            self._dispatch()\n        case _:\n            raise TaskRunError(f\"invalid state transition {self.state} -&gt; {state}\")\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.lock","title":"lock","text":"<pre><code>lock(timeout)\n</code></pre> Source code in <code>fluid/scheduler/models.py</code> <pre><code>def lock(self, timeout: float | None) -&gt; Lock:\n    return self.task_manager.broker.lock(self.name, timeout=timeout)\n</code></pre>"},{"location":"reference/task_scheduler/","title":"Task Scheduler","text":"<p>The task scheduler TaskScheduler inherits from the TaskConsumer to add scheduling of periodic tasks.</p> <p>It can be imported from <code>fluid.scheduler</code>:</p> <pre><code>from fastapi.scheduler import TaskScheduler\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler","title":"fluid.scheduler.TaskScheduler","text":"<pre><code>TaskScheduler(**kwargs)\n</code></pre> <p>               Bases: <code>TaskConsumer</code></p> <p>A task manager for scheduling tasks</p> Source code in <code>fluid/scheduler/scheduler.py</code> <pre><code>def __init__(self, **kwargs: Any) -&gt; None:\n    super().__init__(**kwargs)\n    self.add_workers(ScheduleTasks(self))\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.worker_state","title":"worker_state  <code>property</code>","text":"<pre><code>worker_state\n</code></pre> <p>The running state of the worker</p>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.worker_name","title":"worker_name  <code>property</code>","text":"<pre><code>worker_name\n</code></pre> <p>The name of the worker</p>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.num_workers","title":"num_workers  <code>property</code>","text":"<pre><code>num_workers\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.deps","title":"deps  <code>instance-attribute</code>","text":"<pre><code>deps = deps if deps is not None else State()\n</code></pre> <p>Dependencies for the task manager.</p> <p>Production applications requires global dependencies to be available to all tasks. This can be achieved by setting the <code>deps</code> attribute of the task manager to an object with the required dependencies.</p> <p>Each task can cast the dependencies to the required type.</p>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config = config or TaskManagerConfig(**kwargs)\n</code></pre> <p>Task manager configuration</p>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.dispatcher","title":"dispatcher  <code>instance-attribute</code>","text":"<pre><code>dispatcher = TaskDispatcher()\n</code></pre> <p>A dispatcher of TaskRun events.</p> <p>Application can register handlers to listen for events happening during the lifecycle of a task run.</p>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.broker","title":"broker  <code>instance-attribute</code>","text":"<pre><code>broker = from_url(broker_url)\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.registry","title":"registry  <code>property</code>","text":"<pre><code>registry\n</code></pre> <p>The task registry</p>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.type","title":"type  <code>property</code>","text":"<pre><code>type\n</code></pre> <p>The type of the task manager</p>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.has_started","title":"has_started","text":"<pre><code>has_started()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def has_started(self) -&gt; bool:\n    return self._worker_state != WorkerState.INIT\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.is_running","title":"is_running","text":"<pre><code>is_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_running(self) -&gt; bool:\n    return self._worker_state == WorkerState.RUNNING\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.is_stopping","title":"is_stopping","text":"<pre><code>is_stopping()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_stopping(self) -&gt; bool:\n    return self._worker_state == WorkerState.STOPPING\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.is_stopped","title":"is_stopped","text":"<pre><code>is_stopped()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_stopped(self) -&gt; bool:\n    return self._worker_state in (WorkerState.STOPPED, WorkerState.FORCE_STOPPED)\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.gracefully_stop","title":"gracefully_stop","text":"<pre><code>gracefully_stop()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def gracefully_stop(self) -&gt; None:\n    super().gracefully_stop()\n    for worker in self._workers:\n        worker.gracefully_stop()\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.after_shutdown","title":"after_shutdown","text":"<pre><code>after_shutdown(reason, code)\n</code></pre> <p>Called after shutdown of worker</p> <p>By default it does nothing, but can be overriden to do something such as exit the process.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def after_shutdown(self, reason: str, code: int) -&gt; None:  # noqa: B027\n    \"\"\"Called after shutdown of worker\n\n    By default it does nothing, but can be overriden to do something such as\n    exit the process.\n    \"\"\"\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.status","title":"status  <code>async</code>","text":"<pre><code>status()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def status(self) -&gt; dict:\n    status_workers = await asyncio.gather(\n        *[worker.status() for worker in self._workers],\n    )\n    return {\n        worker.worker_name: status\n        for worker, status in zip(self._workers, status_workers, strict=False)\n    }\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.on_startup","title":"on_startup  <code>async</code>","text":"<pre><code>on_startup()\n</code></pre> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>async def on_startup(self) -&gt; None:\n    await self.__aenter__()\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.on_shutdown","title":"on_shutdown  <code>async</code>","text":"<pre><code>on_shutdown()\n</code></pre> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>async def on_shutdown(self) -&gt; None:\n    await self.__aexit__(None, None, None)\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.startup","title":"startup  <code>async</code>","text":"<pre><code>startup()\n</code></pre> <p>start the worker</p> <p>This method creates a task to run the worker.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def startup(self) -&gt; None:\n    \"\"\"start the worker\n\n    This method creates a task to run the worker.\n    \"\"\"\n    if self.has_started():\n        raise WorkerStartError(\n            \"worker %s already started: %s\", self.worker_name, self._worker_state\n        )\n    else:\n        self._worker_task_runner = await WorkerTaskRunner.start(self)\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.shutdown","title":"shutdown  <code>async</code>","text":"<pre><code>shutdown()\n</code></pre> <p>Shutdown a running worker and wait for it to stop</p> <p>This method will try to gracefully stop the worker and wait for it to stop. If the worker does not stop in the grace period, it will force shutdown by cancelling the task.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def shutdown(self) -&gt; None:\n    \"\"\"Shutdown a running worker and wait for it to stop\n\n    This method will try to gracefully stop the worker and wait for it to stop.\n    If the worker does not stop in the grace period, it will force shutdown\n    by cancelling the task.\n    \"\"\"\n    if self._worker_task_runner is not None:\n        await self._worker_task_runner.shutdown()\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.wait_for_shutdown","title":"wait_for_shutdown  <code>async</code>","text":"<pre><code>wait_for_shutdown()\n</code></pre> <p>Wait for the worker to stop</p> <p>This method will wait for the worker to stop running, but doesn't try to gracefully stop it nor force shutdown.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def wait_for_shutdown(self) -&gt; None:\n    \"\"\"Wait for the worker to stop\n\n    This method will wait for the worker to stop running, but doesn't\n    try to gracefully stop it nor force shutdown.\n    \"\"\"\n    if self._worker_task_runner is not None:\n        await self._worker_task_runner.wait_for_shutdown()\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.workers","title":"workers","text":"<pre><code>workers()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def workers(self) -&gt; Iterator[Worker]:\n    return iter(self._workers)\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.run","title":"run  <code>async</code>","text":"<pre><code>run()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def run(self) -&gt; None:\n    while self.is_running():\n        for worker in self._workers:\n            if not worker.has_started():\n                await worker.startup()\n            if not worker.is_running():\n                self.gracefully_stop()\n                break\n        await asyncio.sleep(self._heartbeat)\n    await self._wait_for_workers()\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.add_workers","title":"add_workers","text":"<pre><code>add_workers(*workers)\n</code></pre> <p>add workers to the workers</p> <p>They can be added while the worker is running.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def add_workers(self, *workers: Worker) -&gt; None:\n    \"\"\"add workers to the workers\n\n    They can be added while the worker is running.\n    \"\"\"\n    for worker in workers:\n        if worker not in self._workers:\n            self._workers.append(worker)\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.add_async_context_manager","title":"add_async_context_manager","text":"<pre><code>add_async_context_manager(cm)\n</code></pre> <p>Add an async context manager to the task manager</p> <p>These context managers are entered when the task manager starts</p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def add_async_context_manager(self, cm: Any) -&gt; None:\n    \"\"\"Add an async context manager to the task manager\n\n    These context managers are entered when the task manager starts\n    \"\"\"\n    self._async_contexts.append(cm)\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.register_task","title":"register_task","text":"<pre><code>register_task(task)\n</code></pre> <p>Register a task with the task manager</p> PARAMETER DESCRIPTION <code>task</code> <p>Task to register</p> <p> TYPE: <code>Task</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def register_task(self, task: Annotated[Task, Doc(\"Task to register\")]) -&gt; None:\n    \"\"\"Register a task with the task manager\"\"\"\n    self.broker.register_task(task)\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.execute","title":"execute  <code>async</code>","text":"<pre><code>execute(task, *, run_id='', priority=None, **params)\n</code></pre> <p>Execute a task and wait for it to finish</p> PARAMETER DESCRIPTION <code>task</code> <p>The task or task name, if a task name it must be registered with the task manager.</p> <p> TYPE: <code>str | Task</code> </p> <code>run_id</code> <p>Unique ID for the task run. If not provided a new UUID is generated.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>priority</code> <p>Override the default task priority if provided</p> <p> TYPE: <code>TaskPriority | None</code> DEFAULT: <code>None</code> </p> <code>**params</code> <p>The optional parameters for the task run. They must match the task params model</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>async def execute(\n    self,\n    task: Annotated[\n        str | Task,\n        Doc(\n            \"The task or task name,\"\n            \" if a task name it must be registered with the task manager.\"\n        ),\n    ],\n    *,\n    run_id: Annotated[\n        str,\n        Doc(\"Unique ID for the task run. If not provided a new UUID is generated.\"),\n    ] = \"\",\n    priority: Annotated[\n        TaskPriority | None, Doc(\"Override the default task priority if provided\")\n    ] = None,\n    **params: Annotated[\n        Any,\n        Doc(\n            \"The optional parameters for the task run. \"\n            \"They must match the task params model\"\n        ),\n    ],\n) -&gt; TaskRun:\n    \"\"\"Execute a task and wait for it to finish\"\"\"\n    task_run = self.create_task_run(\n        task,\n        run_id=run_id,\n        priority=priority,\n        **params,\n    )\n    await task_run.execute()\n    return task_run\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.execute_sync","title":"execute_sync","text":"<pre><code>execute_sync(task, *, run_id='', priority=None, **params)\n</code></pre> <p>Execute a task synchronously</p> <p>This method is a blocking method that should be used in a synchronous context.</p> PARAMETER DESCRIPTION <code>task</code> <p>The task or task name, if a task name it must be registered with the task manager.</p> <p> TYPE: <code>str | Task</code> </p> <code>run_id</code> <p>Unique ID for the task run. If not provided a new UUID is generated.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>priority</code> <p>Override the default task priority if provided</p> <p> TYPE: <code>TaskPriority | None</code> DEFAULT: <code>None</code> </p> <code>**params</code> <p>The optional parameters for the task run. They must match the task params model</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def execute_sync(\n    self,\n    task: Annotated[\n        str | Task,\n        Doc(\n            \"The task or task name,\"\n            \" if a task name it must be registered with the task manager.\"\n        ),\n    ],\n    *,\n    run_id: Annotated[\n        str,\n        Doc(\"Unique ID for the task run. If not provided a new UUID is generated.\"),\n    ] = \"\",\n    priority: Annotated[\n        TaskPriority | None, Doc(\"Override the default task priority if provided\")\n    ] = None,\n    **params: Annotated[\n        Any,\n        Doc(\n            \"The optional parameters for the task run. \"\n            \"They must match the task params model\"\n        ),\n    ],\n) -&gt; TaskRun:\n    \"\"\"Execute a task synchronously\n\n    This method is a blocking method that should be used in a synchronous\n    context.\n    \"\"\"\n    return asyncio.run(\n        self._execute_and_exit(\n            task,\n            run_id=run_id,\n            priority=priority,\n            **params,\n        )\n    )\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.queue","title":"queue  <code>async</code>","text":"<pre><code>queue(task, *, run_id='', priority=None, **params)\n</code></pre> <p>Queue a task for execution</p> <p>This methods fires two events:</p> <ul> <li><code>init</code>: when the task run is created</li> <li><code>queued</code>: after the task is queued</li> </ul> <p>It returns the TaskRun object</p> PARAMETER DESCRIPTION <code>task</code> <p>The task or task name, if a task name it must be registered with the task manager.</p> <p> TYPE: <code>str | Task</code> </p> <code>run_id</code> <p>Unique ID for the task run. If not provided a new UUID is generated.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>priority</code> <p>Override the default task priority if provided</p> <p> TYPE: <code>TaskPriority | None</code> DEFAULT: <code>None</code> </p> <code>**params</code> <p>The optional parameters for the task run. They must match the task params model</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>async def queue(\n    self,\n    task: Annotated[\n        str | Task,\n        Doc(\n            \"The task or task name,\"\n            \" if a task name it must be registered with the task manager.\"\n        ),\n    ],\n    *,\n    run_id: Annotated[\n        str,\n        Doc(\"Unique ID for the task run. If not provided a new UUID is generated.\"),\n    ] = \"\",\n    priority: Annotated[\n        TaskPriority | None, Doc(\"Override the default task priority if provided\")\n    ] = None,\n    **params: Annotated[\n        Any,\n        Doc(\n            \"The optional parameters for the task run. \"\n            \"They must match the task params model\"\n        ),\n    ],\n) -&gt; TaskRun:\n    \"\"\"Queue a task for execution\n\n    This methods fires two events:\n\n    - `init`: when the task run is created\n    - `queued`: after the task is queued\n\n    It returns the [TaskRun][fluid.scheduler.TaskRun] object\n    \"\"\"\n    task_run = self.create_task_run(\n        task,\n        run_id=run_id,\n        priority=priority,\n        **params,\n    )\n    self.dispatcher.dispatch(task_run)\n    task_run.set_state(TaskState.queued)\n    await self.broker.queue_task(task_run)\n    return task_run\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.create_task_run","title":"create_task_run","text":"<pre><code>create_task_run(\n    task, *, run_id=\"\", priority=None, **params\n)\n</code></pre> <p>Create a TaskRun in <code>init</code> state</p> PARAMETER DESCRIPTION <code>task</code> <p>The task or task name, if a task name it must be registered with the task manager.</p> <p> TYPE: <code>str | Task</code> </p> <code>run_id</code> <p>Unique ID for the task run. If not provided a new UUID is generated.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>priority</code> <p>Override the default task priority if provided</p> <p> TYPE: <code>TaskPriority | None</code> DEFAULT: <code>None</code> </p> <code>**params</code> <p>The optional parameters for the task run. They must match the task params model</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def create_task_run(\n    self,\n    task: Annotated[\n        str | Task,\n        Doc(\n            \"The task or task name,\"\n            \" if a task name it must be registered with the task manager.\"\n        ),\n    ],\n    *,\n    run_id: Annotated[\n        str,\n        Doc(\"Unique ID for the task run. If not provided a new UUID is generated.\"),\n    ] = \"\",\n    priority: Annotated[\n        TaskPriority | None, Doc(\"Override the default task priority if provided\")\n    ] = None,\n    **params: Annotated[\n        Any,\n        Doc(\n            \"The optional parameters for the task run. \"\n            \"They must match the task params model\"\n        ),\n    ],\n) -&gt; TaskRun:\n    \"\"\"Create a [TaskRun][fluid.scheduler.TaskRun] in `init` state\"\"\"\n    task = self.broker.task_from_registry(task)\n    run_id = run_id or self.broker.new_uuid()\n    return TaskRun(\n        id=run_id,\n        task=task,\n        priority=priority or task.priority,\n        params=task.params_model(**params),\n        task_manager=self,\n    )\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.register_from_module","title":"register_from_module","text":"<pre><code>register_from_module(module)\n</code></pre> <p>Register tasks from a python module</p> PARAMETER DESCRIPTION <code>module</code> <p>Python module with tasks implementations - can contain any object, only instances of Task are registered</p> <p> TYPE: <code>ModuleType</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def register_from_module(\n    self,\n    module: Annotated[\n        ModuleType,\n        Doc(\n            \"Python module with tasks implementations \"\n            \"- can contain any object, only instances of Task are registered\"\n        ),\n    ],\n) -&gt; None:\n    \"\"\"Register tasks from a python module\"\"\"\n    for name in dir(module):\n        if name.startswith(\"_\"):\n            continue\n        if isinstance(obj := getattr(module, name), Task):\n            self.register_task(obj)\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.register_from_dict","title":"register_from_dict","text":"<pre><code>register_from_dict(data)\n</code></pre> <p>Register tasks from a python dictionary</p> PARAMETER DESCRIPTION <code>data</code> <p>Python dictionary with tasks implementations - can contain any object, only instances of Task are registered</p> <p> TYPE: <code>dict[str, Any]</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def register_from_dict(\n    self,\n    data: Annotated[\n        dict[str, Any],\n        Doc(\n            \"Python dictionary with tasks implementations \"\n            \"- can contain any object, only instances of Task are registered\"\n        ),\n    ],\n) -&gt; None:\n    \"\"\"Register tasks from a python dictionary\"\"\"\n    for name, obj in data.items():\n        if name.startswith(\"_\"):\n            continue\n        if isinstance(obj, Task):\n            self.register_task(obj)\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.register_async_handler","title":"register_async_handler","text":"<pre><code>register_async_handler(event, handler)\n</code></pre> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def register_async_handler(self, event: Event | str, handler: AsyncHandler) -&gt; None:\n    event = Event.from_string_or_event(event)\n    self.dispatcher.register_handler(\n        f\"{event.type}.async_dispatch\",\n        self._async_dispatcher_worker.send,\n    )\n    self._async_dispatcher_worker.dispatcher.register_handler(event, handler)\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.unregister_async_handler","title":"unregister_async_handler","text":"<pre><code>unregister_async_handler(event)\n</code></pre> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def unregister_async_handler(self, event: Event | str) -&gt; AsyncHandler | None:\n    return self._async_dispatcher_worker.dispatcher.unregister_handler(event)\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.sync_queue","title":"sync_queue","text":"<pre><code>sync_queue(task)\n</code></pre> <p>Queue a task synchronously</p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def sync_queue(self, task: str | Task) -&gt; None:\n    \"\"\"Queue a task synchronously\"\"\"\n    self._task_to_queue.appendleft(task)\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.queue_and_wait","title":"queue_and_wait  <code>async</code>","text":"<pre><code>queue_and_wait(task, *, timeout=None, **params)\n</code></pre> <p>Queue a task and wait for it to finish</p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>async def queue_and_wait(\n    self, task: str | Task, *, timeout: int | None = None, **params: Any\n) -&gt; TaskRun:\n    \"\"\"Queue a task and wait for it to finish\"\"\"\n    with TaskRunWaiter(self) as waiter:\n        task_run = await self.queue(task, **params)\n        return await waiter.wait(task_run, timeout=timeout)\n</code></pre>"},{"location":"reference/task_scheduling/","title":"Task Scheduling","text":"<p>Scheduling functions for tasks. They can be imported from <code>fluid.scheduler</code>:</p> <pre><code>from fastapi.scheduler import every, crontab\n</code></pre>"},{"location":"reference/task_scheduling/#fluid.scheduler.Scheduler","title":"fluid.scheduler.Scheduler","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for all schedulers.</p>"},{"location":"reference/task_scheduling/#fluid.scheduler.Scheduler.info","title":"info  <code>abstractmethod</code>","text":"<pre><code>info()\n</code></pre> <p>Return a string representation of the schedule.</p> Source code in <code>fluid/scheduler/scheduler_crontab.py</code> <pre><code>@abstractmethod\ndef info(self) -&gt; str:\n    \"\"\"Return a string representation of the schedule.\"\"\"\n</code></pre>"},{"location":"reference/task_scheduling/#fluid.scheduler.every","title":"fluid.scheduler.every","text":"<pre><code>every(delta, delay=timedelta(), jitter=timedelta())\n</code></pre> <p>               Bases: <code>Scheduler</code></p> Source code in <code>fluid/scheduler/scheduler_every.py</code> <pre><code>def __init__(\n    self,\n    delta: timedelta,\n    delay: timedelta = timedelta(),\n    jitter: timedelta = timedelta(),\n) -&gt; None:\n    self.delta: timedelta = delta\n    self.delay: timedelta = delay\n    self.jitter: timedelta = jitter\n    self._delta: timedelta = self.next_delta()\n    self._started: datetime | None = None\n</code></pre>"},{"location":"reference/task_scheduling/#fluid.scheduler.every.delta","title":"delta  <code>instance-attribute</code>","text":"<pre><code>delta = delta\n</code></pre>"},{"location":"reference/task_scheduling/#fluid.scheduler.every.delay","title":"delay  <code>instance-attribute</code>","text":"<pre><code>delay = delay\n</code></pre>"},{"location":"reference/task_scheduling/#fluid.scheduler.every.jitter","title":"jitter  <code>instance-attribute</code>","text":"<pre><code>jitter = jitter\n</code></pre>"},{"location":"reference/task_scheduling/#fluid.scheduler.every.info","title":"info","text":"<pre><code>info()\n</code></pre> Source code in <code>fluid/scheduler/scheduler_every.py</code> <pre><code>def info(self) -&gt; str:\n    return str(self.delta)\n</code></pre>"},{"location":"reference/task_scheduling/#fluid.scheduler.every.next_delta","title":"next_delta","text":"<pre><code>next_delta()\n</code></pre> Source code in <code>fluid/scheduler/scheduler_every.py</code> <pre><code>def next_delta(self) -&gt; timedelta:\n    return self.delta + random.uniform(0, 1) * self.jitter\n</code></pre>"},{"location":"reference/task_scheduling/#fluid.scheduler.crontab","title":"fluid.scheduler.crontab","text":"<pre><code>crontab(\n    minute=\"*\",\n    hour=\"*\",\n    day=\"*\",\n    month=\"*\",\n    day_of_week=\"*\",\n    tz=utc,\n)\n</code></pre> <p>               Bases: <code>Scheduler</code></p> <p>Convert a \"crontab\"-style set of parameters into a test function that will return True when the given datetime matches the parameters set forth in the crontab. For day-of-week, 0=Sunday and 6=Saturday. Acceptable inputs: * = every distinct value /n = run every \"n\" times, i.e. hours='/4' == 0, 4, 8, 12, 16, 20 m-n = run every time m..n m,n = run on m and n</p> Source code in <code>fluid/scheduler/scheduler_crontab.py</code> <pre><code>def __init__(\n    self,\n    minute: CI = \"*\",\n    hour: CI = \"*\",\n    day: CI = \"*\",\n    month: CI = \"*\",\n    day_of_week: CI = \"*\",\n    tz: tzinfo = timezone.utc,\n) -&gt; None:\n    self.tz: tzinfo = tz\n    self._info = (\n        f\"minute {minute}; hour {hour}; day {day}; month {month}; \"\n        f\"day_of_week {day_of_week}\"\n    )\n    validation = (\n        (\"m\", month, range(1, 13)),\n        (\"d\", day, range(1, 32)),\n        (\"w\", day_of_week, range(8)),  # 0-6, but also 7 for Sunday.\n        (\"H\", hour, range(24)),\n        (\"M\", minute, range(60)),\n    )\n    cron_settings = []\n\n    for date_str, value, acceptable in validation:\n        settings: Set[int] = set()\n\n        if isinstance(value, int):\n            value = str(value)\n\n        for piece in value.split(\",\"):\n            if piece == \"*\":\n                settings.update(acceptable)\n                continue\n\n            if piece.isdigit():\n                digit = int(piece)\n                if digit not in acceptable:\n                    raise ValueError(\"%d is not a valid input\" % digit)\n                elif date_str == \"w\":\n                    digit %= 7\n                settings.add(digit)\n\n            else:\n                dash_match = dash_re.match(piece)\n                if dash_match:\n                    lhs, rhs = map(int, dash_match.groups())\n                    if lhs not in acceptable or rhs not in acceptable:\n                        raise ValueError(\"%s is not a valid input\" % piece)\n                    elif date_str == \"w\":\n                        lhs %= 7\n                        rhs %= 7\n                    settings.update(range(lhs, rhs + 1))\n                    continue\n\n                # Handle stuff like */3, */6.\n                every_match = every_re.match(piece)\n                if every_match:\n                    if date_str == \"w\":\n                        raise ValueError(\n                            \"Cannot perform this kind of matching\"\n                            \" on day-of-week.\"\n                        )\n                    interval = int(every_match.groups()[0])\n                    settings.update(acceptable[::interval])\n\n        cron_settings.append(sorted(list(settings)))\n    self.cron_settings = tuple(cron_settings)\n</code></pre>"},{"location":"reference/task_scheduling/#fluid.scheduler.crontab.tz","title":"tz  <code>instance-attribute</code>","text":"<pre><code>tz = tz\n</code></pre>"},{"location":"reference/task_scheduling/#fluid.scheduler.crontab.cron_settings","title":"cron_settings  <code>instance-attribute</code>","text":"<pre><code>cron_settings = tuple(cron_settings)\n</code></pre>"},{"location":"reference/task_scheduling/#fluid.scheduler.crontab.info","title":"info","text":"<pre><code>info()\n</code></pre> Source code in <code>fluid/scheduler/scheduler_crontab.py</code> <pre><code>def info(self) -&gt; str:\n    return self._info\n</code></pre>"},{"location":"reference/tast_consumer/","title":"Task Consumer","text":"<p>The task consumer is a TaskManager which is also a Workers that consumes tasks from the task queue and executes them. It can be imported from <code>fluid.scheduler</code>:</p> <pre><code>from fastapi.scheduler import TaskConsumer\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer","title":"fluid.scheduler.TaskConsumer","text":"<pre><code>TaskConsumer(**config)\n</code></pre> <p>               Bases: <code>TaskManager</code>, <code>Workers</code></p> <p>The Task Consumer is a Task Manager responsible for consuming tasks from a task queue</p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def __init__(self, **config: Any) -&gt; None:\n    super().__init__(**config)\n    Workers.__init__(self)\n    self._async_dispatcher_worker = AsyncConsumer(AsyncTaskDispatcher())\n    self._task_to_queue: deque[str | Task] = deque()\n    self._queue_tasks_worker = WorkerFunction(\n        self._queue_task, name=\"queue-task-worker\"\n    )\n    self.add_workers(self._queue_tasks_worker)\n    self.add_workers(self._async_dispatcher_worker)\n    for i in range(self.config.max_concurrent_tasks):\n        worker_name = f\"task-worker-{i+1}\"\n        self.add_workers(\n            WorkerFunction(\n                partial(self._consume_tasks, worker_name), name=worker_name\n            )\n        )\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.worker_state","title":"worker_state  <code>property</code>","text":"<pre><code>worker_state\n</code></pre> <p>The running state of the worker</p>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.worker_name","title":"worker_name  <code>property</code>","text":"<pre><code>worker_name\n</code></pre> <p>The name of the worker</p>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.num_workers","title":"num_workers  <code>property</code>","text":"<pre><code>num_workers\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.deps","title":"deps  <code>instance-attribute</code>","text":"<pre><code>deps = deps if deps is not None else State()\n</code></pre> <p>Dependencies for the task manager.</p> <p>Production applications requires global dependencies to be available to all tasks. This can be achieved by setting the <code>deps</code> attribute of the task manager to an object with the required dependencies.</p> <p>Each task can cast the dependencies to the required type.</p>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config = config or TaskManagerConfig(**kwargs)\n</code></pre> <p>Task manager configuration</p>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.dispatcher","title":"dispatcher  <code>instance-attribute</code>","text":"<pre><code>dispatcher = TaskDispatcher()\n</code></pre> <p>A dispatcher of TaskRun events.</p> <p>Application can register handlers to listen for events happening during the lifecycle of a task run.</p>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.broker","title":"broker  <code>instance-attribute</code>","text":"<pre><code>broker = from_url(broker_url)\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.registry","title":"registry  <code>property</code>","text":"<pre><code>registry\n</code></pre> <p>The task registry</p>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.type","title":"type  <code>property</code>","text":"<pre><code>type\n</code></pre> <p>The type of the task manager</p>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.has_started","title":"has_started","text":"<pre><code>has_started()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def has_started(self) -&gt; bool:\n    return self._worker_state != WorkerState.INIT\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.is_running","title":"is_running","text":"<pre><code>is_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_running(self) -&gt; bool:\n    return self._worker_state == WorkerState.RUNNING\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.is_stopping","title":"is_stopping","text":"<pre><code>is_stopping()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_stopping(self) -&gt; bool:\n    return self._worker_state == WorkerState.STOPPING\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.is_stopped","title":"is_stopped","text":"<pre><code>is_stopped()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_stopped(self) -&gt; bool:\n    return self._worker_state in (WorkerState.STOPPED, WorkerState.FORCE_STOPPED)\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.gracefully_stop","title":"gracefully_stop","text":"<pre><code>gracefully_stop()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def gracefully_stop(self) -&gt; None:\n    super().gracefully_stop()\n    for worker in self._workers:\n        worker.gracefully_stop()\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.after_shutdown","title":"after_shutdown","text":"<pre><code>after_shutdown(reason, code)\n</code></pre> <p>Called after shutdown of worker</p> <p>By default it does nothing, but can be overriden to do something such as exit the process.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def after_shutdown(self, reason: str, code: int) -&gt; None:  # noqa: B027\n    \"\"\"Called after shutdown of worker\n\n    By default it does nothing, but can be overriden to do something such as\n    exit the process.\n    \"\"\"\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.status","title":"status  <code>async</code>","text":"<pre><code>status()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def status(self) -&gt; dict:\n    status_workers = await asyncio.gather(\n        *[worker.status() for worker in self._workers],\n    )\n    return {\n        worker.worker_name: status\n        for worker, status in zip(self._workers, status_workers, strict=False)\n    }\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.on_startup","title":"on_startup  <code>async</code>","text":"<pre><code>on_startup()\n</code></pre> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>async def on_startup(self) -&gt; None:\n    await self.__aenter__()\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.on_shutdown","title":"on_shutdown  <code>async</code>","text":"<pre><code>on_shutdown()\n</code></pre> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>async def on_shutdown(self) -&gt; None:\n    await self.__aexit__(None, None, None)\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.startup","title":"startup  <code>async</code>","text":"<pre><code>startup()\n</code></pre> <p>start the worker</p> <p>This method creates a task to run the worker.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def startup(self) -&gt; None:\n    \"\"\"start the worker\n\n    This method creates a task to run the worker.\n    \"\"\"\n    if self.has_started():\n        raise WorkerStartError(\n            \"worker %s already started: %s\", self.worker_name, self._worker_state\n        )\n    else:\n        self._worker_task_runner = await WorkerTaskRunner.start(self)\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.shutdown","title":"shutdown  <code>async</code>","text":"<pre><code>shutdown()\n</code></pre> <p>Shutdown a running worker and wait for it to stop</p> <p>This method will try to gracefully stop the worker and wait for it to stop. If the worker does not stop in the grace period, it will force shutdown by cancelling the task.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def shutdown(self) -&gt; None:\n    \"\"\"Shutdown a running worker and wait for it to stop\n\n    This method will try to gracefully stop the worker and wait for it to stop.\n    If the worker does not stop in the grace period, it will force shutdown\n    by cancelling the task.\n    \"\"\"\n    if self._worker_task_runner is not None:\n        await self._worker_task_runner.shutdown()\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.wait_for_shutdown","title":"wait_for_shutdown  <code>async</code>","text":"<pre><code>wait_for_shutdown()\n</code></pre> <p>Wait for the worker to stop</p> <p>This method will wait for the worker to stop running, but doesn't try to gracefully stop it nor force shutdown.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def wait_for_shutdown(self) -&gt; None:\n    \"\"\"Wait for the worker to stop\n\n    This method will wait for the worker to stop running, but doesn't\n    try to gracefully stop it nor force shutdown.\n    \"\"\"\n    if self._worker_task_runner is not None:\n        await self._worker_task_runner.wait_for_shutdown()\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.workers","title":"workers","text":"<pre><code>workers()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def workers(self) -&gt; Iterator[Worker]:\n    return iter(self._workers)\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.run","title":"run  <code>async</code>","text":"<pre><code>run()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def run(self) -&gt; None:\n    while self.is_running():\n        for worker in self._workers:\n            if not worker.has_started():\n                await worker.startup()\n            if not worker.is_running():\n                self.gracefully_stop()\n                break\n        await asyncio.sleep(self._heartbeat)\n    await self._wait_for_workers()\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.add_workers","title":"add_workers","text":"<pre><code>add_workers(*workers)\n</code></pre> <p>add workers to the workers</p> <p>They can be added while the worker is running.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def add_workers(self, *workers: Worker) -&gt; None:\n    \"\"\"add workers to the workers\n\n    They can be added while the worker is running.\n    \"\"\"\n    for worker in workers:\n        if worker not in self._workers:\n            self._workers.append(worker)\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.add_async_context_manager","title":"add_async_context_manager","text":"<pre><code>add_async_context_manager(cm)\n</code></pre> <p>Add an async context manager to the task manager</p> <p>These context managers are entered when the task manager starts</p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def add_async_context_manager(self, cm: Any) -&gt; None:\n    \"\"\"Add an async context manager to the task manager\n\n    These context managers are entered when the task manager starts\n    \"\"\"\n    self._async_contexts.append(cm)\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.register_task","title":"register_task","text":"<pre><code>register_task(task)\n</code></pre> <p>Register a task with the task manager</p> PARAMETER DESCRIPTION <code>task</code> <p>Task to register</p> <p> TYPE: <code>Task</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def register_task(self, task: Annotated[Task, Doc(\"Task to register\")]) -&gt; None:\n    \"\"\"Register a task with the task manager\"\"\"\n    self.broker.register_task(task)\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.execute","title":"execute  <code>async</code>","text":"<pre><code>execute(task, *, run_id='', priority=None, **params)\n</code></pre> <p>Execute a task and wait for it to finish</p> PARAMETER DESCRIPTION <code>task</code> <p>The task or task name, if a task name it must be registered with the task manager.</p> <p> TYPE: <code>str | Task</code> </p> <code>run_id</code> <p>Unique ID for the task run. If not provided a new UUID is generated.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>priority</code> <p>Override the default task priority if provided</p> <p> TYPE: <code>TaskPriority | None</code> DEFAULT: <code>None</code> </p> <code>**params</code> <p>The optional parameters for the task run. They must match the task params model</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>async def execute(\n    self,\n    task: Annotated[\n        str | Task,\n        Doc(\n            \"The task or task name,\"\n            \" if a task name it must be registered with the task manager.\"\n        ),\n    ],\n    *,\n    run_id: Annotated[\n        str,\n        Doc(\"Unique ID for the task run. If not provided a new UUID is generated.\"),\n    ] = \"\",\n    priority: Annotated[\n        TaskPriority | None, Doc(\"Override the default task priority if provided\")\n    ] = None,\n    **params: Annotated[\n        Any,\n        Doc(\n            \"The optional parameters for the task run. \"\n            \"They must match the task params model\"\n        ),\n    ],\n) -&gt; TaskRun:\n    \"\"\"Execute a task and wait for it to finish\"\"\"\n    task_run = self.create_task_run(\n        task,\n        run_id=run_id,\n        priority=priority,\n        **params,\n    )\n    await task_run.execute()\n    return task_run\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.execute_sync","title":"execute_sync","text":"<pre><code>execute_sync(task, *, run_id='', priority=None, **params)\n</code></pre> <p>Execute a task synchronously</p> <p>This method is a blocking method that should be used in a synchronous context.</p> PARAMETER DESCRIPTION <code>task</code> <p>The task or task name, if a task name it must be registered with the task manager.</p> <p> TYPE: <code>str | Task</code> </p> <code>run_id</code> <p>Unique ID for the task run. If not provided a new UUID is generated.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>priority</code> <p>Override the default task priority if provided</p> <p> TYPE: <code>TaskPriority | None</code> DEFAULT: <code>None</code> </p> <code>**params</code> <p>The optional parameters for the task run. They must match the task params model</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def execute_sync(\n    self,\n    task: Annotated[\n        str | Task,\n        Doc(\n            \"The task or task name,\"\n            \" if a task name it must be registered with the task manager.\"\n        ),\n    ],\n    *,\n    run_id: Annotated[\n        str,\n        Doc(\"Unique ID for the task run. If not provided a new UUID is generated.\"),\n    ] = \"\",\n    priority: Annotated[\n        TaskPriority | None, Doc(\"Override the default task priority if provided\")\n    ] = None,\n    **params: Annotated[\n        Any,\n        Doc(\n            \"The optional parameters for the task run. \"\n            \"They must match the task params model\"\n        ),\n    ],\n) -&gt; TaskRun:\n    \"\"\"Execute a task synchronously\n\n    This method is a blocking method that should be used in a synchronous\n    context.\n    \"\"\"\n    return asyncio.run(\n        self._execute_and_exit(\n            task,\n            run_id=run_id,\n            priority=priority,\n            **params,\n        )\n    )\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.queue","title":"queue  <code>async</code>","text":"<pre><code>queue(task, *, run_id='', priority=None, **params)\n</code></pre> <p>Queue a task for execution</p> <p>This methods fires two events:</p> <ul> <li><code>init</code>: when the task run is created</li> <li><code>queued</code>: after the task is queued</li> </ul> <p>It returns the TaskRun object</p> PARAMETER DESCRIPTION <code>task</code> <p>The task or task name, if a task name it must be registered with the task manager.</p> <p> TYPE: <code>str | Task</code> </p> <code>run_id</code> <p>Unique ID for the task run. If not provided a new UUID is generated.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>priority</code> <p>Override the default task priority if provided</p> <p> TYPE: <code>TaskPriority | None</code> DEFAULT: <code>None</code> </p> <code>**params</code> <p>The optional parameters for the task run. They must match the task params model</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>async def queue(\n    self,\n    task: Annotated[\n        str | Task,\n        Doc(\n            \"The task or task name,\"\n            \" if a task name it must be registered with the task manager.\"\n        ),\n    ],\n    *,\n    run_id: Annotated[\n        str,\n        Doc(\"Unique ID for the task run. If not provided a new UUID is generated.\"),\n    ] = \"\",\n    priority: Annotated[\n        TaskPriority | None, Doc(\"Override the default task priority if provided\")\n    ] = None,\n    **params: Annotated[\n        Any,\n        Doc(\n            \"The optional parameters for the task run. \"\n            \"They must match the task params model\"\n        ),\n    ],\n) -&gt; TaskRun:\n    \"\"\"Queue a task for execution\n\n    This methods fires two events:\n\n    - `init`: when the task run is created\n    - `queued`: after the task is queued\n\n    It returns the [TaskRun][fluid.scheduler.TaskRun] object\n    \"\"\"\n    task_run = self.create_task_run(\n        task,\n        run_id=run_id,\n        priority=priority,\n        **params,\n    )\n    self.dispatcher.dispatch(task_run)\n    task_run.set_state(TaskState.queued)\n    await self.broker.queue_task(task_run)\n    return task_run\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.create_task_run","title":"create_task_run","text":"<pre><code>create_task_run(\n    task, *, run_id=\"\", priority=None, **params\n)\n</code></pre> <p>Create a TaskRun in <code>init</code> state</p> PARAMETER DESCRIPTION <code>task</code> <p>The task or task name, if a task name it must be registered with the task manager.</p> <p> TYPE: <code>str | Task</code> </p> <code>run_id</code> <p>Unique ID for the task run. If not provided a new UUID is generated.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>priority</code> <p>Override the default task priority if provided</p> <p> TYPE: <code>TaskPriority | None</code> DEFAULT: <code>None</code> </p> <code>**params</code> <p>The optional parameters for the task run. They must match the task params model</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def create_task_run(\n    self,\n    task: Annotated[\n        str | Task,\n        Doc(\n            \"The task or task name,\"\n            \" if a task name it must be registered with the task manager.\"\n        ),\n    ],\n    *,\n    run_id: Annotated[\n        str,\n        Doc(\"Unique ID for the task run. If not provided a new UUID is generated.\"),\n    ] = \"\",\n    priority: Annotated[\n        TaskPriority | None, Doc(\"Override the default task priority if provided\")\n    ] = None,\n    **params: Annotated[\n        Any,\n        Doc(\n            \"The optional parameters for the task run. \"\n            \"They must match the task params model\"\n        ),\n    ],\n) -&gt; TaskRun:\n    \"\"\"Create a [TaskRun][fluid.scheduler.TaskRun] in `init` state\"\"\"\n    task = self.broker.task_from_registry(task)\n    run_id = run_id or self.broker.new_uuid()\n    return TaskRun(\n        id=run_id,\n        task=task,\n        priority=priority or task.priority,\n        params=task.params_model(**params),\n        task_manager=self,\n    )\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.register_from_module","title":"register_from_module","text":"<pre><code>register_from_module(module)\n</code></pre> <p>Register tasks from a python module</p> PARAMETER DESCRIPTION <code>module</code> <p>Python module with tasks implementations - can contain any object, only instances of Task are registered</p> <p> TYPE: <code>ModuleType</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def register_from_module(\n    self,\n    module: Annotated[\n        ModuleType,\n        Doc(\n            \"Python module with tasks implementations \"\n            \"- can contain any object, only instances of Task are registered\"\n        ),\n    ],\n) -&gt; None:\n    \"\"\"Register tasks from a python module\"\"\"\n    for name in dir(module):\n        if name.startswith(\"_\"):\n            continue\n        if isinstance(obj := getattr(module, name), Task):\n            self.register_task(obj)\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.register_from_dict","title":"register_from_dict","text":"<pre><code>register_from_dict(data)\n</code></pre> <p>Register tasks from a python dictionary</p> PARAMETER DESCRIPTION <code>data</code> <p>Python dictionary with tasks implementations - can contain any object, only instances of Task are registered</p> <p> TYPE: <code>dict[str, Any]</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def register_from_dict(\n    self,\n    data: Annotated[\n        dict[str, Any],\n        Doc(\n            \"Python dictionary with tasks implementations \"\n            \"- can contain any object, only instances of Task are registered\"\n        ),\n    ],\n) -&gt; None:\n    \"\"\"Register tasks from a python dictionary\"\"\"\n    for name, obj in data.items():\n        if name.startswith(\"_\"):\n            continue\n        if isinstance(obj, Task):\n            self.register_task(obj)\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.sync_queue","title":"sync_queue","text":"<pre><code>sync_queue(task)\n</code></pre> <p>Queue a task synchronously</p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def sync_queue(self, task: str | Task) -&gt; None:\n    \"\"\"Queue a task synchronously\"\"\"\n    self._task_to_queue.appendleft(task)\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.queue_and_wait","title":"queue_and_wait  <code>async</code>","text":"<pre><code>queue_and_wait(task, *, timeout=None, **params)\n</code></pre> <p>Queue a task and wait for it to finish</p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>async def queue_and_wait(\n    self, task: str | Task, *, timeout: int | None = None, **params: Any\n) -&gt; TaskRun:\n    \"\"\"Queue a task and wait for it to finish\"\"\"\n    with TaskRunWaiter(self) as waiter:\n        task_run = await self.queue(task, **params)\n        return await waiter.wait(task_run, timeout=timeout)\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.register_async_handler","title":"register_async_handler","text":"<pre><code>register_async_handler(event, handler)\n</code></pre> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def register_async_handler(self, event: Event | str, handler: AsyncHandler) -&gt; None:\n    event = Event.from_string_or_event(event)\n    self.dispatcher.register_handler(\n        f\"{event.type}.async_dispatch\",\n        self._async_dispatcher_worker.send,\n    )\n    self._async_dispatcher_worker.dispatcher.register_handler(event, handler)\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.unregister_async_handler","title":"unregister_async_handler","text":"<pre><code>unregister_async_handler(event)\n</code></pre> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def unregister_async_handler(self, event: Event | str) -&gt; AsyncHandler | None:\n    return self._async_dispatcher_worker.dispatcher.unregister_handler(event)\n</code></pre>"},{"location":"reference/utils/","title":"Utils","text":""},{"location":"reference/utils/#fluid.utils.lazy.LazyGroup","title":"fluid.utils.lazy.LazyGroup","text":"<pre><code>LazyGroup(*, lazy_subcommands=None, **kwargs)\n</code></pre> <p>               Bases: <code>Group</code></p> <p>A click Group that can lazily load subcommands</p> <p>This class extends the click.Group class to allow for subcommands to be lazily loaded from a module path.</p> <p>It is useful when you have a large number of subcommands that you don't want to load until they are actually needed.</p> <p>Available with the <code>cli</code> extra dependencies.</p> Source code in <code>fluid/utils/lazy.py</code> <pre><code>def __init__(\n    self,\n    *,\n    lazy_subcommands: dict[str, str] | None = None,\n    **kwargs: Any,\n):\n    super().__init__(**kwargs)\n    self.lazy_subcommands = lazy_subcommands or {}\n</code></pre>"},{"location":"reference/utils/#fluid.utils.lazy.LazyGroup.lazy_subcommands","title":"lazy_subcommands  <code>instance-attribute</code>","text":"<pre><code>lazy_subcommands = lazy_subcommands or {}\n</code></pre>"},{"location":"reference/utils/#fluid.utils.lazy.LazyGroup.list_commands","title":"list_commands","text":"<pre><code>list_commands(ctx)\n</code></pre> Source code in <code>fluid/utils/lazy.py</code> <pre><code>def list_commands(self, ctx: click.Context) -&gt; list[str]:\n    commands = super().list_commands(ctx)\n    commands.extend(self.lazy_subcommands)\n    return sorted(commands)\n</code></pre>"},{"location":"reference/utils/#fluid.utils.lazy.LazyGroup.get_command","title":"get_command","text":"<pre><code>get_command(ctx, cmd_name)\n</code></pre> Source code in <code>fluid/utils/lazy.py</code> <pre><code>def get_command(self, ctx: click.Context, cmd_name: str) -&gt; click.Command | None:\n    if cmd_name in self.lazy_subcommands:\n        return self._lazy_load(cmd_name)\n    return super().get_command(ctx, cmd_name)\n</code></pre>"},{"location":"reference/workers/","title":"Workers","text":"<p>Workers are the main building block for asynchronous programming with <code>aio-fluid</code>. They are responsible for running asynchronous tasks and managing their lifecycle. There are several worker classes which can be imported from <code>fluid.utils.worker</code>, and they aall derive from the abstract <code>fluid.utils.worker.Worker</code> class.</p> <pre><code>from fluid.utils.worker import Worker\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.WorkerState","title":"fluid.utils.worker.WorkerState","text":"<p>               Bases: <code>StrEnum</code></p> <p>The state of a worker</p>"},{"location":"reference/workers/#fluid.utils.worker.WorkerState.INIT","title":"INIT  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>INIT = auto()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.WorkerState.RUNNING","title":"RUNNING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RUNNING = auto()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.WorkerState.STOPPING","title":"STOPPING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STOPPING = auto()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.WorkerState.STOPPED","title":"STOPPED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>STOPPED = auto()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.WorkerState.FORCE_STOPPED","title":"FORCE_STOPPED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>FORCE_STOPPED = auto()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Worker","title":"fluid.utils.worker.Worker","text":"<pre><code>Worker(\n    name=\"\", stopping_grace_period=STOPPING_GRACE_PERIOD\n)\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>An Abstract Worker that can be started and stopped</p> <p>All other workers derive from this class.</p> PARAMETER DESCRIPTION <code>name</code> <p>Worker's name, if not provided it is evaluated from the class name</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>stopping_grace_period</code> <p>Grace period in seconds to wait for workers to stop running when this worker is shutdown. It defaults to the <code>FLUID_STOPPING_GRACE_PERIOD</code> environment variable or 10 seconds.</p> <p> TYPE: <code>int</code> DEFAULT: <code>STOPPING_GRACE_PERIOD</code> </p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def __init__(\n    self,\n    name: Annotated[\n        str,\n        Doc(\"Worker's name, if not provided it is evaluated from the class name\"),\n    ] = \"\",\n    stopping_grace_period: Annotated[\n        int,\n        Doc(\n            \"Grace period in seconds to wait for workers to stop running \"\n            \"when this worker is shutdown. \"\n            \"It defaults to the `FLUID_STOPPING_GRACE_PERIOD` \"\n            \"environment variable or 10 seconds.\"\n        ),\n    ] = settings.STOPPING_GRACE_PERIOD,\n) -&gt; None:\n    self._worker_name: str = name or underscore(type(self).__name__)\n    self._worker_state: WorkerState = WorkerState.INIT\n    self._stopping_grace_period = stopping_grace_period\n    self._worker_task_runner: WorkerTaskRunner | None = None\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Worker.worker_state","title":"worker_state  <code>property</code>","text":"<pre><code>worker_state\n</code></pre> <p>The running state of the worker</p>"},{"location":"reference/workers/#fluid.utils.worker.Worker.worker_name","title":"worker_name  <code>property</code>","text":"<pre><code>worker_name\n</code></pre> <p>The name of the worker</p>"},{"location":"reference/workers/#fluid.utils.worker.Worker.num_workers","title":"num_workers  <code>property</code>","text":"<pre><code>num_workers\n</code></pre> <p>The number of workers in this worker</p>"},{"location":"reference/workers/#fluid.utils.worker.Worker.has_started","title":"has_started","text":"<pre><code>has_started()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def has_started(self) -&gt; bool:\n    return self._worker_state != WorkerState.INIT\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Worker.is_running","title":"is_running","text":"<pre><code>is_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_running(self) -&gt; bool:\n    return self._worker_state == WorkerState.RUNNING\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Worker.is_stopping","title":"is_stopping","text":"<pre><code>is_stopping()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_stopping(self) -&gt; bool:\n    return self._worker_state == WorkerState.STOPPING\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Worker.is_stopped","title":"is_stopped","text":"<pre><code>is_stopped()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_stopped(self) -&gt; bool:\n    return self._worker_state in (WorkerState.STOPPED, WorkerState.FORCE_STOPPED)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Worker.gracefully_stop","title":"gracefully_stop","text":"<pre><code>gracefully_stop()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def gracefully_stop(self) -&gt; None:\n    if self.is_running():\n        self._worker_state = WorkerState.STOPPING\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Worker.after_shutdown","title":"after_shutdown","text":"<pre><code>after_shutdown(reason, code)\n</code></pre> <p>Called after shutdown of worker</p> <p>By default it does nothing, but can be overriden to do something such as exit the process.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def after_shutdown(self, reason: str, code: int) -&gt; None:  # noqa: B027\n    \"\"\"Called after shutdown of worker\n\n    By default it does nothing, but can be overriden to do something such as\n    exit the process.\n    \"\"\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Worker.status","title":"status  <code>async</code>","text":"<pre><code>status()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def status(self) -&gt; dict:\n    return {\"stopping\": self.is_stopping(), \"running\": self.is_running()}\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Worker.on_startup","title":"on_startup  <code>async</code>","text":"<pre><code>on_startup()\n</code></pre> <p>Called when the worker starts running</p> <p>Use this function to initialize other async resources connected with the worker</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def on_startup(self) -&gt; None:  # noqa: B027\n    \"\"\"Called when the worker starts running\n\n    Use this function to initialize other async resources connected with the worker\n    \"\"\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Worker.on_shutdown","title":"on_shutdown  <code>async</code>","text":"<pre><code>on_shutdown()\n</code></pre> <p>called after the worker stopped running</p> <p>Use this function to cleanup resources connected with the worker</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def on_shutdown(self) -&gt; None:  # noqa: B027\n    \"\"\"called after the worker stopped running\n\n    Use this function to cleanup resources connected with the worker\n    \"\"\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Worker.startup","title":"startup  <code>async</code>","text":"<pre><code>startup()\n</code></pre> <p>start the worker</p> <p>This method creates a task to run the worker.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def startup(self) -&gt; None:\n    \"\"\"start the worker\n\n    This method creates a task to run the worker.\n    \"\"\"\n    if self.has_started():\n        raise WorkerStartError(\n            \"worker %s already started: %s\", self.worker_name, self._worker_state\n        )\n    else:\n        self._worker_task_runner = await WorkerTaskRunner.start(self)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Worker.shutdown","title":"shutdown  <code>async</code>","text":"<pre><code>shutdown()\n</code></pre> <p>Shutdown a running worker and wait for it to stop</p> <p>This method will try to gracefully stop the worker and wait for it to stop. If the worker does not stop in the grace period, it will force shutdown by cancelling the task.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def shutdown(self) -&gt; None:\n    \"\"\"Shutdown a running worker and wait for it to stop\n\n    This method will try to gracefully stop the worker and wait for it to stop.\n    If the worker does not stop in the grace period, it will force shutdown\n    by cancelling the task.\n    \"\"\"\n    if self._worker_task_runner is not None:\n        await self._worker_task_runner.shutdown()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Worker.wait_for_shutdown","title":"wait_for_shutdown  <code>async</code>","text":"<pre><code>wait_for_shutdown()\n</code></pre> <p>Wait for the worker to stop</p> <p>This method will wait for the worker to stop running, but doesn't try to gracefully stop it nor force shutdown.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def wait_for_shutdown(self) -&gt; None:\n    \"\"\"Wait for the worker to stop\n\n    This method will wait for the worker to stop running, but doesn't\n    try to gracefully stop it nor force shutdown.\n    \"\"\"\n    if self._worker_task_runner is not None:\n        await self._worker_task_runner.wait_for_shutdown()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Worker.workers","title":"workers","text":"<pre><code>workers()\n</code></pre> <p>An iterator of workers in this worker</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def workers(self) -&gt; Iterator[Worker]:\n    \"\"\"An iterator of workers in this worker\"\"\"\n    yield self\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Worker.run","title":"run  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>run()\n</code></pre> <p>run the worker</p> <p>This is the only abstract method and that needs implementing. It is the coroutine that mantains the worker running.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>@abstractmethod\nasync def run(self) -&gt; None:\n    \"\"\"run the worker\n\n    This is the only abstract method and that needs implementing.\n    It is the coroutine that mantains the worker running.\n    \"\"\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.WorkerFunction","title":"fluid.utils.worker.WorkerFunction","text":"<pre><code>WorkerFunction(run_function, heartbeat=0, name='')\n</code></pre> <p>               Bases: <code>Worker</code></p> <p>A Worker that runs and wait a coroutine function in a loop</p> PARAMETER DESCRIPTION <code>run_function</code> <p>The coroutine function tuo run and await at each iteration of the worker loop</p> <p> TYPE: <code>Callable[[], Awaitable[None]]</code> </p> <code>heartbeat</code> <p>The time to wait between each coroutine function run</p> <p> TYPE: <code>float | int</code> DEFAULT: <code>0</code> </p> <code>name</code> <p>Worker's name, if not provided it is evaluated from the class name</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def __init__(\n    self,\n    run_function: Annotated[\n        Callable[[], Awaitable[None]],\n        Doc(\n            \"The coroutine function tuo run and await at each iteration \"\n            \"of the worker loop\"\n        ),\n    ],\n    heartbeat: Annotated[\n        float | int, Doc(\"The time to wait between each coroutine function run\")\n    ] = 0,\n    name: Annotated[\n        str,\n        Doc(\"Worker's name, if not provided it is evaluated from the class name\"),\n    ] = \"\",\n) -&gt; None:\n    super().__init__(name=name)\n    self._run_function = run_function\n    self._heartbeat = heartbeat\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.WorkerFunction.worker_state","title":"worker_state  <code>property</code>","text":"<pre><code>worker_state\n</code></pre> <p>The running state of the worker</p>"},{"location":"reference/workers/#fluid.utils.worker.WorkerFunction.worker_name","title":"worker_name  <code>property</code>","text":"<pre><code>worker_name\n</code></pre> <p>The name of the worker</p>"},{"location":"reference/workers/#fluid.utils.worker.WorkerFunction.num_workers","title":"num_workers  <code>property</code>","text":"<pre><code>num_workers\n</code></pre> <p>The number of workers in this worker</p>"},{"location":"reference/workers/#fluid.utils.worker.WorkerFunction.has_started","title":"has_started","text":"<pre><code>has_started()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def has_started(self) -&gt; bool:\n    return self._worker_state != WorkerState.INIT\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.WorkerFunction.is_running","title":"is_running","text":"<pre><code>is_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_running(self) -&gt; bool:\n    return self._worker_state == WorkerState.RUNNING\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.WorkerFunction.is_stopping","title":"is_stopping","text":"<pre><code>is_stopping()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_stopping(self) -&gt; bool:\n    return self._worker_state == WorkerState.STOPPING\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.WorkerFunction.is_stopped","title":"is_stopped","text":"<pre><code>is_stopped()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_stopped(self) -&gt; bool:\n    return self._worker_state in (WorkerState.STOPPED, WorkerState.FORCE_STOPPED)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.WorkerFunction.gracefully_stop","title":"gracefully_stop","text":"<pre><code>gracefully_stop()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def gracefully_stop(self) -&gt; None:\n    if self.is_running():\n        self._worker_state = WorkerState.STOPPING\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.WorkerFunction.after_shutdown","title":"after_shutdown","text":"<pre><code>after_shutdown(reason, code)\n</code></pre> <p>Called after shutdown of worker</p> <p>By default it does nothing, but can be overriden to do something such as exit the process.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def after_shutdown(self, reason: str, code: int) -&gt; None:  # noqa: B027\n    \"\"\"Called after shutdown of worker\n\n    By default it does nothing, but can be overriden to do something such as\n    exit the process.\n    \"\"\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.WorkerFunction.status","title":"status  <code>async</code>","text":"<pre><code>status()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def status(self) -&gt; dict:\n    return {\"stopping\": self.is_stopping(), \"running\": self.is_running()}\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.WorkerFunction.on_startup","title":"on_startup  <code>async</code>","text":"<pre><code>on_startup()\n</code></pre> <p>Called when the worker starts running</p> <p>Use this function to initialize other async resources connected with the worker</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def on_startup(self) -&gt; None:  # noqa: B027\n    \"\"\"Called when the worker starts running\n\n    Use this function to initialize other async resources connected with the worker\n    \"\"\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.WorkerFunction.on_shutdown","title":"on_shutdown  <code>async</code>","text":"<pre><code>on_shutdown()\n</code></pre> <p>called after the worker stopped running</p> <p>Use this function to cleanup resources connected with the worker</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def on_shutdown(self) -&gt; None:  # noqa: B027\n    \"\"\"called after the worker stopped running\n\n    Use this function to cleanup resources connected with the worker\n    \"\"\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.WorkerFunction.startup","title":"startup  <code>async</code>","text":"<pre><code>startup()\n</code></pre> <p>start the worker</p> <p>This method creates a task to run the worker.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def startup(self) -&gt; None:\n    \"\"\"start the worker\n\n    This method creates a task to run the worker.\n    \"\"\"\n    if self.has_started():\n        raise WorkerStartError(\n            \"worker %s already started: %s\", self.worker_name, self._worker_state\n        )\n    else:\n        self._worker_task_runner = await WorkerTaskRunner.start(self)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.WorkerFunction.shutdown","title":"shutdown  <code>async</code>","text":"<pre><code>shutdown()\n</code></pre> <p>Shutdown a running worker and wait for it to stop</p> <p>This method will try to gracefully stop the worker and wait for it to stop. If the worker does not stop in the grace period, it will force shutdown by cancelling the task.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def shutdown(self) -&gt; None:\n    \"\"\"Shutdown a running worker and wait for it to stop\n\n    This method will try to gracefully stop the worker and wait for it to stop.\n    If the worker does not stop in the grace period, it will force shutdown\n    by cancelling the task.\n    \"\"\"\n    if self._worker_task_runner is not None:\n        await self._worker_task_runner.shutdown()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.WorkerFunction.wait_for_shutdown","title":"wait_for_shutdown  <code>async</code>","text":"<pre><code>wait_for_shutdown()\n</code></pre> <p>Wait for the worker to stop</p> <p>This method will wait for the worker to stop running, but doesn't try to gracefully stop it nor force shutdown.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def wait_for_shutdown(self) -&gt; None:\n    \"\"\"Wait for the worker to stop\n\n    This method will wait for the worker to stop running, but doesn't\n    try to gracefully stop it nor force shutdown.\n    \"\"\"\n    if self._worker_task_runner is not None:\n        await self._worker_task_runner.wait_for_shutdown()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.WorkerFunction.workers","title":"workers","text":"<pre><code>workers()\n</code></pre> <p>An iterator of workers in this worker</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def workers(self) -&gt; Iterator[Worker]:\n    \"\"\"An iterator of workers in this worker\"\"\"\n    yield self\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.WorkerFunction.run","title":"run  <code>async</code>","text":"<pre><code>run()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def run(self) -&gt; None:\n    while self.is_running():\n        await self._run_function()\n        await asyncio.sleep(self._heartbeat)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer","title":"fluid.utils.worker.QueueConsumer","text":"<pre><code>QueueConsumer(name='')\n</code></pre> <p>               Bases: <code>Worker</code>, <code>MessageProducer[MessageType]</code></p> <p>An Abstract Worker that can receive messages</p> <p>This worker can receive messages but not consume them.</p> PARAMETER DESCRIPTION <code>name</code> <p>Worker's name, if not provided it is evaluated from the class name</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def __init__(\n    self,\n    name: Annotated[\n        str,\n        Doc(\"Worker's name, if not provided it is evaluated from the class name\"),\n    ] = \"\",\n) -&gt; None:\n    super().__init__(name=name)\n    self._queue: asyncio.Queue[MessageType | None] = asyncio.Queue()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer.worker_state","title":"worker_state  <code>property</code>","text":"<pre><code>worker_state\n</code></pre> <p>The running state of the worker</p>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer.worker_name","title":"worker_name  <code>property</code>","text":"<pre><code>worker_name\n</code></pre> <p>The name of the worker</p>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer.num_workers","title":"num_workers  <code>property</code>","text":"<pre><code>num_workers\n</code></pre> <p>The number of workers in this worker</p>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer.has_started","title":"has_started","text":"<pre><code>has_started()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def has_started(self) -&gt; bool:\n    return self._worker_state != WorkerState.INIT\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer.is_running","title":"is_running","text":"<pre><code>is_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_running(self) -&gt; bool:\n    return self._worker_state == WorkerState.RUNNING\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer.is_stopping","title":"is_stopping","text":"<pre><code>is_stopping()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_stopping(self) -&gt; bool:\n    return self._worker_state == WorkerState.STOPPING\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer.is_stopped","title":"is_stopped","text":"<pre><code>is_stopped()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_stopped(self) -&gt; bool:\n    return self._worker_state in (WorkerState.STOPPED, WorkerState.FORCE_STOPPED)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer.gracefully_stop","title":"gracefully_stop","text":"<pre><code>gracefully_stop()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def gracefully_stop(self) -&gt; None:\n    if self.is_running():\n        self._worker_state = WorkerState.STOPPING\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer.after_shutdown","title":"after_shutdown","text":"<pre><code>after_shutdown(reason, code)\n</code></pre> <p>Called after shutdown of worker</p> <p>By default it does nothing, but can be overriden to do something such as exit the process.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def after_shutdown(self, reason: str, code: int) -&gt; None:  # noqa: B027\n    \"\"\"Called after shutdown of worker\n\n    By default it does nothing, but can be overriden to do something such as\n    exit the process.\n    \"\"\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer.on_startup","title":"on_startup  <code>async</code>","text":"<pre><code>on_startup()\n</code></pre> <p>Called when the worker starts running</p> <p>Use this function to initialize other async resources connected with the worker</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def on_startup(self) -&gt; None:  # noqa: B027\n    \"\"\"Called when the worker starts running\n\n    Use this function to initialize other async resources connected with the worker\n    \"\"\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer.on_shutdown","title":"on_shutdown  <code>async</code>","text":"<pre><code>on_shutdown()\n</code></pre> <p>called after the worker stopped running</p> <p>Use this function to cleanup resources connected with the worker</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def on_shutdown(self) -&gt; None:  # noqa: B027\n    \"\"\"called after the worker stopped running\n\n    Use this function to cleanup resources connected with the worker\n    \"\"\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer.startup","title":"startup  <code>async</code>","text":"<pre><code>startup()\n</code></pre> <p>start the worker</p> <p>This method creates a task to run the worker.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def startup(self) -&gt; None:\n    \"\"\"start the worker\n\n    This method creates a task to run the worker.\n    \"\"\"\n    if self.has_started():\n        raise WorkerStartError(\n            \"worker %s already started: %s\", self.worker_name, self._worker_state\n        )\n    else:\n        self._worker_task_runner = await WorkerTaskRunner.start(self)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer.shutdown","title":"shutdown  <code>async</code>","text":"<pre><code>shutdown()\n</code></pre> <p>Shutdown a running worker and wait for it to stop</p> <p>This method will try to gracefully stop the worker and wait for it to stop. If the worker does not stop in the grace period, it will force shutdown by cancelling the task.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def shutdown(self) -&gt; None:\n    \"\"\"Shutdown a running worker and wait for it to stop\n\n    This method will try to gracefully stop the worker and wait for it to stop.\n    If the worker does not stop in the grace period, it will force shutdown\n    by cancelling the task.\n    \"\"\"\n    if self._worker_task_runner is not None:\n        await self._worker_task_runner.shutdown()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer.wait_for_shutdown","title":"wait_for_shutdown  <code>async</code>","text":"<pre><code>wait_for_shutdown()\n</code></pre> <p>Wait for the worker to stop</p> <p>This method will wait for the worker to stop running, but doesn't try to gracefully stop it nor force shutdown.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def wait_for_shutdown(self) -&gt; None:\n    \"\"\"Wait for the worker to stop\n\n    This method will wait for the worker to stop running, but doesn't\n    try to gracefully stop it nor force shutdown.\n    \"\"\"\n    if self._worker_task_runner is not None:\n        await self._worker_task_runner.wait_for_shutdown()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer.workers","title":"workers","text":"<pre><code>workers()\n</code></pre> <p>An iterator of workers in this worker</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def workers(self) -&gt; Iterator[Worker]:\n    \"\"\"An iterator of workers in this worker\"\"\"\n    yield self\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer.run","title":"run  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>run()\n</code></pre> <p>run the worker</p> <p>This is the only abstract method and that needs implementing. It is the coroutine that mantains the worker running.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>@abstractmethod\nasync def run(self) -&gt; None:\n    \"\"\"run the worker\n\n    This is the only abstract method and that needs implementing.\n    It is the coroutine that mantains the worker running.\n    \"\"\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer.get_message","title":"get_message  <code>async</code>","text":"<pre><code>get_message(timeout=0.5)\n</code></pre> <p>Get the next message from the queue</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def get_message(self, timeout: float = 0.5) -&gt; MessageType | None:\n    \"\"\"Get the next message from the queue\"\"\"\n    try:\n        async with asyncio.timeout(timeout):\n            return await self._queue.get()\n    except asyncio.TimeoutError:\n        return None\n    except (asyncio.CancelledError, RuntimeError):\n        if not self.is_stopping():\n            raise\n    return None\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer.queue_size","title":"queue_size","text":"<pre><code>queue_size()\n</code></pre> <p>Get the size of the queue</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def queue_size(self) -&gt; int:\n    \"\"\"Get the size of the queue\"\"\"\n    return self._queue.qsize()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer.status","title":"status  <code>async</code>","text":"<pre><code>status()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def status(self) -&gt; dict:\n    status = await super().status()\n    status.update(queue_size=self.queue_size())\n    return status\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer.send","title":"send","text":"<pre><code>send(message)\n</code></pre> <p>Send a message into the worker</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def send(self, message: MessageType | None) -&gt; None:\n    \"\"\"Send a message into the worker\"\"\"\n    self._queue.put_nowait(message)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker","title":"fluid.utils.worker.QueueConsumerWorker","text":"<pre><code>QueueConsumerWorker(on_message, name='')\n</code></pre> <p>               Bases: <code>QueueConsumer[MessageType]</code></p> <p>A Worker that can receive and consume messages</p> PARAMETER DESCRIPTION <code>on_message</code> <p>The async callback to call when a message is received</p> <p> TYPE: <code>Callable[[MessageType], Awaitable[None]]</code> </p> <code>name</code> <p>Worker's name, if not provided it is evaluated from the class name</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def __init__(\n    self,\n    on_message: Annotated[\n        Callable[[MessageType], Awaitable[None]],\n        Doc(\"The async callback to call when a message is received\"),\n    ],\n    name: Annotated[\n        str,\n        Doc(\"Worker's name, if not provided it is evaluated from the class name\"),\n    ] = \"\",\n) -&gt; None:\n    super().__init__(name=name)\n    self.on_message = on_message\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.worker_state","title":"worker_state  <code>property</code>","text":"<pre><code>worker_state\n</code></pre> <p>The running state of the worker</p>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.worker_name","title":"worker_name  <code>property</code>","text":"<pre><code>worker_name\n</code></pre> <p>The name of the worker</p>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.num_workers","title":"num_workers  <code>property</code>","text":"<pre><code>num_workers\n</code></pre> <p>The number of workers in this worker</p>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.on_message","title":"on_message  <code>instance-attribute</code>","text":"<pre><code>on_message = on_message\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.send","title":"send","text":"<pre><code>send(message)\n</code></pre> <p>Send a message into the worker</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def send(self, message: MessageType | None) -&gt; None:\n    \"\"\"Send a message into the worker\"\"\"\n    self._queue.put_nowait(message)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.has_started","title":"has_started","text":"<pre><code>has_started()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def has_started(self) -&gt; bool:\n    return self._worker_state != WorkerState.INIT\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.is_running","title":"is_running","text":"<pre><code>is_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_running(self) -&gt; bool:\n    return self._worker_state == WorkerState.RUNNING\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.is_stopping","title":"is_stopping","text":"<pre><code>is_stopping()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_stopping(self) -&gt; bool:\n    return self._worker_state == WorkerState.STOPPING\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.is_stopped","title":"is_stopped","text":"<pre><code>is_stopped()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_stopped(self) -&gt; bool:\n    return self._worker_state in (WorkerState.STOPPED, WorkerState.FORCE_STOPPED)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.gracefully_stop","title":"gracefully_stop","text":"<pre><code>gracefully_stop()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def gracefully_stop(self) -&gt; None:\n    if self.is_running():\n        self._worker_state = WorkerState.STOPPING\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.after_shutdown","title":"after_shutdown","text":"<pre><code>after_shutdown(reason, code)\n</code></pre> <p>Called after shutdown of worker</p> <p>By default it does nothing, but can be overriden to do something such as exit the process.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def after_shutdown(self, reason: str, code: int) -&gt; None:  # noqa: B027\n    \"\"\"Called after shutdown of worker\n\n    By default it does nothing, but can be overriden to do something such as\n    exit the process.\n    \"\"\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.status","title":"status  <code>async</code>","text":"<pre><code>status()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def status(self) -&gt; dict:\n    status = await super().status()\n    status.update(queue_size=self.queue_size())\n    return status\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.on_startup","title":"on_startup  <code>async</code>","text":"<pre><code>on_startup()\n</code></pre> <p>Called when the worker starts running</p> <p>Use this function to initialize other async resources connected with the worker</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def on_startup(self) -&gt; None:  # noqa: B027\n    \"\"\"Called when the worker starts running\n\n    Use this function to initialize other async resources connected with the worker\n    \"\"\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.on_shutdown","title":"on_shutdown  <code>async</code>","text":"<pre><code>on_shutdown()\n</code></pre> <p>called after the worker stopped running</p> <p>Use this function to cleanup resources connected with the worker</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def on_shutdown(self) -&gt; None:  # noqa: B027\n    \"\"\"called after the worker stopped running\n\n    Use this function to cleanup resources connected with the worker\n    \"\"\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.startup","title":"startup  <code>async</code>","text":"<pre><code>startup()\n</code></pre> <p>start the worker</p> <p>This method creates a task to run the worker.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def startup(self) -&gt; None:\n    \"\"\"start the worker\n\n    This method creates a task to run the worker.\n    \"\"\"\n    if self.has_started():\n        raise WorkerStartError(\n            \"worker %s already started: %s\", self.worker_name, self._worker_state\n        )\n    else:\n        self._worker_task_runner = await WorkerTaskRunner.start(self)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.shutdown","title":"shutdown  <code>async</code>","text":"<pre><code>shutdown()\n</code></pre> <p>Shutdown a running worker and wait for it to stop</p> <p>This method will try to gracefully stop the worker and wait for it to stop. If the worker does not stop in the grace period, it will force shutdown by cancelling the task.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def shutdown(self) -&gt; None:\n    \"\"\"Shutdown a running worker and wait for it to stop\n\n    This method will try to gracefully stop the worker and wait for it to stop.\n    If the worker does not stop in the grace period, it will force shutdown\n    by cancelling the task.\n    \"\"\"\n    if self._worker_task_runner is not None:\n        await self._worker_task_runner.shutdown()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.wait_for_shutdown","title":"wait_for_shutdown  <code>async</code>","text":"<pre><code>wait_for_shutdown()\n</code></pre> <p>Wait for the worker to stop</p> <p>This method will wait for the worker to stop running, but doesn't try to gracefully stop it nor force shutdown.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def wait_for_shutdown(self) -&gt; None:\n    \"\"\"Wait for the worker to stop\n\n    This method will wait for the worker to stop running, but doesn't\n    try to gracefully stop it nor force shutdown.\n    \"\"\"\n    if self._worker_task_runner is not None:\n        await self._worker_task_runner.wait_for_shutdown()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.workers","title":"workers","text":"<pre><code>workers()\n</code></pre> <p>An iterator of workers in this worker</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def workers(self) -&gt; Iterator[Worker]:\n    \"\"\"An iterator of workers in this worker\"\"\"\n    yield self\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.get_message","title":"get_message  <code>async</code>","text":"<pre><code>get_message(timeout=0.5)\n</code></pre> <p>Get the next message from the queue</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def get_message(self, timeout: float = 0.5) -&gt; MessageType | None:\n    \"\"\"Get the next message from the queue\"\"\"\n    try:\n        async with asyncio.timeout(timeout):\n            return await self._queue.get()\n    except asyncio.TimeoutError:\n        return None\n    except (asyncio.CancelledError, RuntimeError):\n        if not self.is_stopping():\n            raise\n    return None\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.queue_size","title":"queue_size","text":"<pre><code>queue_size()\n</code></pre> <p>Get the size of the queue</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def queue_size(self) -&gt; int:\n    \"\"\"Get the size of the queue\"\"\"\n    return self._queue.qsize()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.run","title":"run  <code>async</code>","text":"<pre><code>run()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def run(self) -&gt; None:\n    while not self.is_stopping():\n        message = await self.get_message()\n        if message is not None:\n            await self.on_message(message)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer","title":"fluid.utils.worker.AsyncConsumer","text":"<pre><code>AsyncConsumer(dispatcher, name='')\n</code></pre> <p>               Bases: <code>QueueConsumer[MessageType]</code></p> <p>A Worker that can dispatch to async callbacks</p> PARAMETER DESCRIPTION <code>dispatcher</code> <p>Async message dispatcher to dispatch messages</p> <p> TYPE: <code>AsyncDispatcher[MessageType]</code> </p> <code>name</code> <p>Worker's name, if not provided it is evaluated from the class name</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def __init__(\n    self,\n    dispatcher: Annotated[\n        AsyncDispatcher[MessageType],\n        Doc(\"Async message dispatcher to dispatch messages\"),\n    ],\n    name: Annotated[\n        str,\n        Doc(\"Worker's name, if not provided it is evaluated from the class name\"),\n    ] = \"\",\n) -&gt; None:\n    super().__init__(name)\n    self.dispatcher: AsyncDispatcher[MessageType] = dispatcher\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.worker_state","title":"worker_state  <code>property</code>","text":"<pre><code>worker_state\n</code></pre> <p>The running state of the worker</p>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.worker_name","title":"worker_name  <code>property</code>","text":"<pre><code>worker_name\n</code></pre> <p>The name of the worker</p>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.num_workers","title":"num_workers  <code>property</code>","text":"<pre><code>num_workers\n</code></pre> <p>The number of workers in this worker</p>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.dispatcher","title":"dispatcher  <code>instance-attribute</code>","text":"<pre><code>dispatcher = dispatcher\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.send","title":"send","text":"<pre><code>send(message)\n</code></pre> <p>Send a message into the worker</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def send(self, message: MessageType | None) -&gt; None:\n    \"\"\"Send a message into the worker\"\"\"\n    self._queue.put_nowait(message)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.has_started","title":"has_started","text":"<pre><code>has_started()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def has_started(self) -&gt; bool:\n    return self._worker_state != WorkerState.INIT\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.is_running","title":"is_running","text":"<pre><code>is_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_running(self) -&gt; bool:\n    return self._worker_state == WorkerState.RUNNING\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.is_stopping","title":"is_stopping","text":"<pre><code>is_stopping()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_stopping(self) -&gt; bool:\n    return self._worker_state == WorkerState.STOPPING\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.is_stopped","title":"is_stopped","text":"<pre><code>is_stopped()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_stopped(self) -&gt; bool:\n    return self._worker_state in (WorkerState.STOPPED, WorkerState.FORCE_STOPPED)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.gracefully_stop","title":"gracefully_stop","text":"<pre><code>gracefully_stop()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def gracefully_stop(self) -&gt; None:\n    if self.is_running():\n        self._worker_state = WorkerState.STOPPING\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.after_shutdown","title":"after_shutdown","text":"<pre><code>after_shutdown(reason, code)\n</code></pre> <p>Called after shutdown of worker</p> <p>By default it does nothing, but can be overriden to do something such as exit the process.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def after_shutdown(self, reason: str, code: int) -&gt; None:  # noqa: B027\n    \"\"\"Called after shutdown of worker\n\n    By default it does nothing, but can be overriden to do something such as\n    exit the process.\n    \"\"\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.status","title":"status  <code>async</code>","text":"<pre><code>status()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def status(self) -&gt; dict:\n    status = await super().status()\n    status.update(queue_size=self.queue_size())\n    return status\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.on_startup","title":"on_startup  <code>async</code>","text":"<pre><code>on_startup()\n</code></pre> <p>Called when the worker starts running</p> <p>Use this function to initialize other async resources connected with the worker</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def on_startup(self) -&gt; None:  # noqa: B027\n    \"\"\"Called when the worker starts running\n\n    Use this function to initialize other async resources connected with the worker\n    \"\"\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.on_shutdown","title":"on_shutdown  <code>async</code>","text":"<pre><code>on_shutdown()\n</code></pre> <p>called after the worker stopped running</p> <p>Use this function to cleanup resources connected with the worker</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def on_shutdown(self) -&gt; None:  # noqa: B027\n    \"\"\"called after the worker stopped running\n\n    Use this function to cleanup resources connected with the worker\n    \"\"\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.startup","title":"startup  <code>async</code>","text":"<pre><code>startup()\n</code></pre> <p>start the worker</p> <p>This method creates a task to run the worker.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def startup(self) -&gt; None:\n    \"\"\"start the worker\n\n    This method creates a task to run the worker.\n    \"\"\"\n    if self.has_started():\n        raise WorkerStartError(\n            \"worker %s already started: %s\", self.worker_name, self._worker_state\n        )\n    else:\n        self._worker_task_runner = await WorkerTaskRunner.start(self)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.shutdown","title":"shutdown  <code>async</code>","text":"<pre><code>shutdown()\n</code></pre> <p>Shutdown a running worker and wait for it to stop</p> <p>This method will try to gracefully stop the worker and wait for it to stop. If the worker does not stop in the grace period, it will force shutdown by cancelling the task.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def shutdown(self) -&gt; None:\n    \"\"\"Shutdown a running worker and wait for it to stop\n\n    This method will try to gracefully stop the worker and wait for it to stop.\n    If the worker does not stop in the grace period, it will force shutdown\n    by cancelling the task.\n    \"\"\"\n    if self._worker_task_runner is not None:\n        await self._worker_task_runner.shutdown()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.wait_for_shutdown","title":"wait_for_shutdown  <code>async</code>","text":"<pre><code>wait_for_shutdown()\n</code></pre> <p>Wait for the worker to stop</p> <p>This method will wait for the worker to stop running, but doesn't try to gracefully stop it nor force shutdown.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def wait_for_shutdown(self) -&gt; None:\n    \"\"\"Wait for the worker to stop\n\n    This method will wait for the worker to stop running, but doesn't\n    try to gracefully stop it nor force shutdown.\n    \"\"\"\n    if self._worker_task_runner is not None:\n        await self._worker_task_runner.wait_for_shutdown()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.workers","title":"workers","text":"<pre><code>workers()\n</code></pre> <p>An iterator of workers in this worker</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def workers(self) -&gt; Iterator[Worker]:\n    \"\"\"An iterator of workers in this worker\"\"\"\n    yield self\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.get_message","title":"get_message  <code>async</code>","text":"<pre><code>get_message(timeout=0.5)\n</code></pre> <p>Get the next message from the queue</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def get_message(self, timeout: float = 0.5) -&gt; MessageType | None:\n    \"\"\"Get the next message from the queue\"\"\"\n    try:\n        async with asyncio.timeout(timeout):\n            return await self._queue.get()\n    except asyncio.TimeoutError:\n        return None\n    except (asyncio.CancelledError, RuntimeError):\n        if not self.is_stopping():\n            raise\n    return None\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.queue_size","title":"queue_size","text":"<pre><code>queue_size()\n</code></pre> <p>Get the size of the queue</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def queue_size(self) -&gt; int:\n    \"\"\"Get the size of the queue\"\"\"\n    return self._queue.qsize()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.run","title":"run  <code>async</code>","text":"<pre><code>run()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def run(self) -&gt; None:\n    while not self.is_stopping():\n        message = await self.get_message()\n        if message is not None:\n            await self.dispatcher.dispatch(message)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers","title":"fluid.utils.worker.Workers","text":"<pre><code>Workers(\n    *workers,\n    name=\"\",\n    heartbeat=0.1,\n    stopping_grace_period=STOPPING_GRACE_PERIOD\n)\n</code></pre> <p>               Bases: <code>Worker</code></p> <p>An worker managing several workers</p> PARAMETER DESCRIPTION <code>*workers</code> <p>Workers to manage, they can also be added later via <code>add_workers</code> method</p> <p> TYPE: <code>Worker</code> DEFAULT: <code>()</code> </p> <code>name</code> <p>Worker's name, if not provided it is evaluated from the class name</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>heartbeat</code> <p>The time to wait between each workers status check</p> <p> TYPE: <code>float | int</code> DEFAULT: <code>0.1</code> </p> <code>stopping_grace_period</code> <p>Grace period in seconds to wait for workers to stop running when this worker is shutdown. It defaults to the <code>FLUID_STOPPING_GRACE_PERIOD</code> environment variable or 10 seconds.</p> <p> TYPE: <code>int</code> DEFAULT: <code>STOPPING_GRACE_PERIOD</code> </p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def __init__(\n    self,\n    *workers: Annotated[\n        Worker,\n        Doc(\n            \"Workers to manage, they can also be added later \"\n            \"via `add_workers` method\"\n        ),\n    ],\n    name: Annotated[\n        str,\n        Doc(\"Worker's name, if not provided it is evaluated from the class name\"),\n    ] = \"\",\n    heartbeat: Annotated[\n        float | int,\n        Doc(\"The time to wait between each workers status check\"),\n    ] = 0.1,\n    stopping_grace_period: Annotated[\n        int,\n        Doc(\n            \"Grace period in seconds to wait for workers to stop running \"\n            \"when this worker is shutdown. \"\n            \"It defaults to the `FLUID_STOPPING_GRACE_PERIOD` \"\n            \"environment variable or 10 seconds.\"\n        ),\n    ] = settings.STOPPING_GRACE_PERIOD,\n) -&gt; None:\n    super().__init__(name, stopping_grace_period=stopping_grace_period)\n    self._heartbeat = heartbeat\n    self._workers: list[Worker] = []\n    self.add_workers(*workers)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.worker_state","title":"worker_state  <code>property</code>","text":"<pre><code>worker_state\n</code></pre> <p>The running state of the worker</p>"},{"location":"reference/workers/#fluid.utils.worker.Workers.worker_name","title":"worker_name  <code>property</code>","text":"<pre><code>worker_name\n</code></pre> <p>The name of the worker</p>"},{"location":"reference/workers/#fluid.utils.worker.Workers.num_workers","title":"num_workers  <code>property</code>","text":"<pre><code>num_workers\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.has_started","title":"has_started","text":"<pre><code>has_started()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def has_started(self) -&gt; bool:\n    return self._worker_state != WorkerState.INIT\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.is_running","title":"is_running","text":"<pre><code>is_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_running(self) -&gt; bool:\n    return self._worker_state == WorkerState.RUNNING\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.is_stopping","title":"is_stopping","text":"<pre><code>is_stopping()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_stopping(self) -&gt; bool:\n    return self._worker_state == WorkerState.STOPPING\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.is_stopped","title":"is_stopped","text":"<pre><code>is_stopped()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_stopped(self) -&gt; bool:\n    return self._worker_state in (WorkerState.STOPPED, WorkerState.FORCE_STOPPED)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.after_shutdown","title":"after_shutdown","text":"<pre><code>after_shutdown(reason, code)\n</code></pre> <p>Called after shutdown of worker</p> <p>By default it does nothing, but can be overriden to do something such as exit the process.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def after_shutdown(self, reason: str, code: int) -&gt; None:  # noqa: B027\n    \"\"\"Called after shutdown of worker\n\n    By default it does nothing, but can be overriden to do something such as\n    exit the process.\n    \"\"\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.on_startup","title":"on_startup  <code>async</code>","text":"<pre><code>on_startup()\n</code></pre> <p>Called when the worker starts running</p> <p>Use this function to initialize other async resources connected with the worker</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def on_startup(self) -&gt; None:  # noqa: B027\n    \"\"\"Called when the worker starts running\n\n    Use this function to initialize other async resources connected with the worker\n    \"\"\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.on_shutdown","title":"on_shutdown  <code>async</code>","text":"<pre><code>on_shutdown()\n</code></pre> <p>called after the worker stopped running</p> <p>Use this function to cleanup resources connected with the worker</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def on_shutdown(self) -&gt; None:  # noqa: B027\n    \"\"\"called after the worker stopped running\n\n    Use this function to cleanup resources connected with the worker\n    \"\"\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.startup","title":"startup  <code>async</code>","text":"<pre><code>startup()\n</code></pre> <p>start the worker</p> <p>This method creates a task to run the worker.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def startup(self) -&gt; None:\n    \"\"\"start the worker\n\n    This method creates a task to run the worker.\n    \"\"\"\n    if self.has_started():\n        raise WorkerStartError(\n            \"worker %s already started: %s\", self.worker_name, self._worker_state\n        )\n    else:\n        self._worker_task_runner = await WorkerTaskRunner.start(self)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.shutdown","title":"shutdown  <code>async</code>","text":"<pre><code>shutdown()\n</code></pre> <p>Shutdown a running worker and wait for it to stop</p> <p>This method will try to gracefully stop the worker and wait for it to stop. If the worker does not stop in the grace period, it will force shutdown by cancelling the task.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def shutdown(self) -&gt; None:\n    \"\"\"Shutdown a running worker and wait for it to stop\n\n    This method will try to gracefully stop the worker and wait for it to stop.\n    If the worker does not stop in the grace period, it will force shutdown\n    by cancelling the task.\n    \"\"\"\n    if self._worker_task_runner is not None:\n        await self._worker_task_runner.shutdown()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.wait_for_shutdown","title":"wait_for_shutdown  <code>async</code>","text":"<pre><code>wait_for_shutdown()\n</code></pre> <p>Wait for the worker to stop</p> <p>This method will wait for the worker to stop running, but doesn't try to gracefully stop it nor force shutdown.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def wait_for_shutdown(self) -&gt; None:\n    \"\"\"Wait for the worker to stop\n\n    This method will wait for the worker to stop running, but doesn't\n    try to gracefully stop it nor force shutdown.\n    \"\"\"\n    if self._worker_task_runner is not None:\n        await self._worker_task_runner.wait_for_shutdown()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.add_workers","title":"add_workers","text":"<pre><code>add_workers(*workers)\n</code></pre> <p>add workers to the workers</p> <p>They can be added while the worker is running.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def add_workers(self, *workers: Worker) -&gt; None:\n    \"\"\"add workers to the workers\n\n    They can be added while the worker is running.\n    \"\"\"\n    for worker in workers:\n        if worker not in self._workers:\n            self._workers.append(worker)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.workers","title":"workers","text":"<pre><code>workers()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def workers(self) -&gt; Iterator[Worker]:\n    return iter(self._workers)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.gracefully_stop","title":"gracefully_stop","text":"<pre><code>gracefully_stop()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def gracefully_stop(self) -&gt; None:\n    super().gracefully_stop()\n    for worker in self._workers:\n        worker.gracefully_stop()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.status","title":"status  <code>async</code>","text":"<pre><code>status()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def status(self) -&gt; dict:\n    status_workers = await asyncio.gather(\n        *[worker.status() for worker in self._workers],\n    )\n    return {\n        worker.worker_name: status\n        for worker, status in zip(self._workers, status_workers, strict=False)\n    }\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.run","title":"run  <code>async</code>","text":"<pre><code>run()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def run(self) -&gt; None:\n    while self.is_running():\n        for worker in self._workers:\n            if not worker.has_started():\n                await worker.startup()\n            if not worker.is_running():\n                self.gracefully_stop()\n                break\n        await asyncio.sleep(self._heartbeat)\n    await self._wait_for_workers()\n</code></pre>"},{"location":"tutorials/","title":"Tutorials","text":"<p>The step-by-step guides, the how-to's, the recipes, and all the Aio Fluid parts you can use in your back-end applications.</p> <p>Each section gradually builds on the previous ones, but it's structured to separate topics, so that you can go directly to any specific one to solve your specific needs.</p>"},{"location":"tutorials/#install-aio-fluid","title":"Install Aio Fluid","text":"<p>To install Aio Fluid, you can use the following command:</p> <pre><code>pip install aio-fluid\n</code></pre> <p>if you want to use the async database module, you can install it with the following command:</p> <pre><code>pip install aio-fluid[db]\n</code></pre> <p>if you want to use the command line interface (highly recommended), you can install it with the following command:</p> <pre><code>pip install aio-fluid[cli]\n</code></pre>"},{"location":"tutorials/db/","title":"Async Database","text":"<p>The <code>fluid.db</code> module provides a simple asynchronous interface to interact with postgres databases. It is built on top of the sqlalchemy and asyncpg libraries.</p>"},{"location":"tutorials/db/#database","title":"Database","text":"<p>Create a database container with the Database class:</p> <pre><code>from fluid.db import Database\n\ndb = Database(\"postgresql+asyncpg://postgres:postgres@localhost:5432/fluid\")\n</code></pre> <p>Note the use of the <code>postgresql+asyncpg</code> driver in the connection string. This is required to use the asyncpg driver.</p>"},{"location":"tutorials/db/#register-a-table","title":"Register a Table","text":"<p>To interact with a table, you need to register it with the database container:</p> <pre><code>import sqlalchemy as sa\n\nusers = sa.Table(\n    \"users\",\n    db.metadata,\n    sa.Column(\"id\", sa.Integer, primary_key=True),\n    sa.Column(\"name\", sa.String),\n)\n</code></pre>"},{"location":"tutorials/dispatchers/","title":"Event Dispatchers","text":"<p>Event dispatchers are a way to decouple the event source from the event handler. This is useful when you want to have multiple handlers for the same event, or when you want to have a single handler for multiple events.</p>"},{"location":"tutorials/dispatchers/#a-simple-dispatcher","title":"A Simple Dispatcher","text":"<p>In this example we will create a simple dispatcher that will dispatch strings to a list of handlers.</p> <p>The only requirement for the implementation of a Dispatcher is to implement the <code>event_type</code> method.</p> <pre><code>from fluid.utils.dispatcher import Dispatcher\n\n\nclass SimpleDispatcher(Dispatcher[str]):\n    def event_type(self, message: str) -&gt; str:\n        return \"*\"\n\n\nsimple = SimpleDispatcher()\n\nassert simple.dispatch(\"you can dispatch strings to this dispatcher\") == 0\n\n\ndef count_words(x: str) -&gt; None:\n    words = [x.strip() for w in x.split(\" \") if w.strip()]\n    print(f\"number of words {len(words)}\")\n\n\nsimple.register_handler(\"*\", count_words)\n\nassert simple.dispatch(\"you can dispatch strings to this dispatcher\") == 1\n\n\ndef count_letters(x: str) -&gt; None:\n    letters = set(x)\n    print(f\"number of letters {len(letters)}\")\n\n\nsimple.register_handler(\"*.count_letters\", count_letters)\n\n\nassert simple.dispatch(\"you can dispatch strings to this dispatcher\") == 2\n</code></pre> <p>In this example we have a simple dispatcher that will dispatch strings to a list of handlers. The <code>event_type</code> method returns the type of the event, in this case always a \"*\" string.</p> <p>The registration of multiple handlers is done via the use of tags (see the <code>count_letters</code> registration).</p>"},{"location":"tutorials/dispatchers/#a-data-dispatcher","title":"A Data Dispatcher","text":"<p>In this example we will create a dispatcher that will dispatch data to a list of handlers. The event type of the message is given by the type of the data.</p> <pre><code>from typing import Any\n\nfrom fluid.utils.dispatcher import Dispatcher\n\n\nclass MessageDispatcher(Dispatcher[Any]):\n    def event_type(self, data: Any) -&gt; str:\n        return type(data).__name__\n\n\ndispatcher = MessageDispatcher()\n\nassert dispatcher.dispatch({}) == 0\n\n\ndef count_keys(data: Any) -&gt; None:\n    print(f\"number of keys {len(data)}\")\n\n\ndispatcher.register_handler(\"dict\", count_keys)\n\n\nassert dispatcher.dispatch(dict(a=1, b=2)) == 1\n</code></pre>"},{"location":"tutorials/task_app/","title":"Task Queue App","text":"<p>The <code>fluid.scheduler</code> module is a simple yet powerful distributed task producer (TaskScheduler) and consumer (TaskConsumer) system for executing tasks. The middleware for distributing tasks can be configured via the TaskBroker interface.</p> <p>A redis task broker is provided for convenience.</p>"},{"location":"tutorials/task_app/#tasks-consumer","title":"Tasks Consumer","text":"<p>Create a task consumer, register tasks from modules, and run the consumer.</p> <pre><code>import asyncio\nfrom typing import Any\nfrom fluid.scheduler import TaskConsumer\nimport task_module_a, task_module_b\n\n\ndef task_consumer(**kwargs: Any) -&gt; TaskConsumer:\n    consumer = TaskConsumer(**kwargs)\n    consumer.register_from_module(task_module_a)\n    consumer.register_from_module(task_module_b)\n    return consumer\n\n\nif __name__ == \"__main__\":\n    consumer = task_consumer()\n    asyncio.run(consumer.run())\n</code></pre>"},{"location":"tutorials/task_app/#fastapi-integration","title":"FastAPI Integration","text":"<p>The <code>TaskConsumer</code> can be integrated with FastAPI so that tasks can be queued via HTTP requests.</p> <pre><code>import uvicorn\nfrom fluid.scheduler.endpoints import setup_fastapi\n\nif __name__ == \"__main__\":\n    consumer = task_consumer()\n    app = setup_fastapi(consumer)\n    uvicorn.run(app)\n</code></pre> <p>You can test via the example provided</p> <pre><code>$ python -m examples.simple_fastapi\n</code></pre> <p>and check the openapi UI at http://127.0.0.1:8000/docs.</p>"},{"location":"tutorials/task_app/#task-app-command-line","title":"Task App Command Line","text":"<p>The TaskConsumer or TaskScheduler can be run with the command line tool to allow for an even richer API.</p> <pre><code>from fluid.scheduler.cli import TaskManagerCLI\n\nif __name__ == \"__main__\":\n    consumer = task_consumer()\n    TaskManagerCLI(setup_fastapi(consumer))()\n</code></pre> <p>This features requires to install the package with the <code>cli</code> extra.</p> <pre><code>$ pip install aio-fluid[cli]\n</code></pre> <pre><code>$ python -m examples.simple_cli\nUsage: python -m examples.simple_cli [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  enable  Enable or disable a task\n  exec    Execute a registered task\n  ls      List all tasks with their schedules\n  serve   Start app server.\n</code></pre> <p>The command line tool provides a powerful interface to execute tasks, parameters are passed as optional arguments using the standard click interface.</p>"},{"location":"tutorials/task_broker/","title":"Task Broker","text":"<p>A TaskBroker needs to implement three abstract methods</p> <pre><code>  @abstractmethod\n  async def queue_task(self, task_run: TaskRun) -&gt; None:\n      \"\"\"Queue a task\"\"\"\n\n  @abstractmethod\n  async def get_task_run(self) -&gt; Optional[TaskRun]:\n      \"\"\"Get a Task run from the task queue\"\"\"\n\n  @abstractmethod\n  async def queue_length(self) -&gt; Dict[str, int]:\n      \"\"\"Length of task queues\"\"\"\n\n  @abstractmethod\n    async def update_task(self, task: Task, params: dict[str, Any]) -&gt; TaskInfo:\n        \"\"\"Update a task dynamic parameters\"\"\"\n\n  @abstractmethod\n  async def close(self) -&gt; None:\n      \"\"\"Close the broker on shutdown\"\"\"\n\n  @abstractmethod\n  def lock(self, name: str, timeout: float | None = None) -&gt; Lock:\n      \"\"\"Create a lock\"\"\"\n</code></pre> <p>The library ships a Redis broker for convenience.</p> <pre><code>from fluid.scheduler import Broker\n\nredis_broker = Broker.from_url(\"redis://localhost:6349\")\n</code></pre> <p>By default the broker uses the url provided in the <code>FLUID_BROKER_URL</code> environment variable and falls back to <code>redis://localhost:6349</code>.</p> <pre><code>broker = Broker.from_url()\nbroker.url == \"redis://localhost:6349\"\n</code></pre>"},{"location":"tutorials/task_queue/","title":"Tasks","text":"<p>Tasks are standard python async functions decorated with the @task decorator.</p> <pre><code>from fluid.scheduler import task, TaskRun\n\n@task\nasync def say_hi(ctx: TaskRun) -&gt; None:\n    print(\"Hi!\")\n</code></pre> <p>The TaskRun object is passed to the task function and contains the task metadata, including optional parameters, and the TaskManager.</p>"},{"location":"tutorials/task_queue/#task-parameters","title":"Task Parameters","text":"<p>It is possible to pass parameters to the task, to do so, create a pydantic model for the task parameters</p> <pre><code>from pydantic import BaseModel\n\nclass TaskParams(BaseModel):\n    name: str\n</code></pre> <p>and pass it to the <code>task</code> decorator</p> <pre><code>from fluid.scheduler import task, TaskRun\n\n@task\nasync def say_hi(ctx: TaskRun[TaskParams]) -&gt; None:\n    print(f\"Hi {ctx.params.name}!\")\n</code></pre>"},{"location":"tutorials/task_queue/#task-types","title":"Task Types","text":"<p>There are few types of tasks implemented, lets take a look at them.</p>"},{"location":"tutorials/task_queue/#io-bound-tasks","title":"IO Bound Tasks","text":"<p>They run concurrently with the TaskConsumer. They must perform non blocking IO operations (no heavy CPU bound operations that blocks the event loop).</p> <pre><code>from fluid.scheduler import task, TaskRun\nfrom pydantic import BaseModel\n\n\nclass Scrape(BaseModel):\n    url: str = \"https://\"\n\n\n@task\nasync def fecth_data(ctx: TaskRun[Scrape]) -&gt; None:\n    # fetch data\n    data = await http_cli.get(ctx.params.url)\n    data_id = await datastore_cli.stote(data)\n    # trigger another task\n    ctx.task_manager.queue(\"heavy_calculation\", data_id=data_id)\n</code></pre>"},{"location":"tutorials/task_queue/#cpu-bound-tasks","title":"CPU bound tasks","text":"<p>They run on a subprocess</p> <pre><code>from fluid.scheduler import task, TaskRun\n\n@task(cpu_bound=True)\nasync def heavy_calculation(ctx: TaskRun) -&gt; None:\n    data = await datastore_cli.get(ctx.params[\"data_id\"])\n    # perform some heavy calculation\n    ...\n    # trigger another task\n    ctx.task_manager.queue(\"fetch_data\")\n</code></pre>"},{"location":"tutorials/task_queue/#scheduled-tasks","title":"Scheduled Tasks","text":"<p>Both IO and CPU bound tasks can be periodically scheduled via the <code>schedule</code> keyword argument.</p> <p>There are two types of scheduling, the most common is the every function that takes a <code>timedelta</code> object.</p> <pre><code>import asyncio\nfrom datetime import timedelta\nfrom fluid.scheduler import task, TaskRun, every\n\n@task(schedule=every(timedelta(seconds=1)))\nasync def scheduled(ctx: TaskRun) -&gt; None:\n    await asyncio.sleep(0.1)\n</code></pre> <p>You can also use the crontab function to schedule tasks using cron expressions.</p> <pre><code>import asyncio\nfrom fluid.scheduler import task, TaskRun, crontab\n\n@task(schedule=crontab(hours='*/2'))\nasync def scheduled(ctx: TaskRun) -&gt; None:\n    await asyncio.sleep(0.1)\n</code></pre>"},{"location":"tutorials/workers/","title":"Workers","text":"<p>Workers are the main building block for asynchronous programming with <code>aio-fluid</code>. They are responsible for running tasks and managing their lifecycle. All workers implemented derive from the base abstract class Worker where the main method to implement is the Worker.run method.</p>"},{"location":"tutorials/workers/#worker-lifecycle","title":"Worker Lifecycle","text":"<p>The lifecycle of a worker is managed by the WorkerState class which provides a set of states that a worker can be in. The worker starts in an inital state and than it can be started and stopped.</p>"},{"location":"tutorials/workers/#startup","title":"Startup","text":"<p>To start a worker one uses the async method Worker.startup which create the task running the worker. The task will transition the worker from WorkerState.INIT to the WorkerState.RUNNING state. The worker will then run the Worker.on_startup coroutine method (which by default is a no-op) follow by the main worker coroutine method Worker.run method until it is stopped.</p> <p>This is a very simple example of a worker that prints a message every second until it is stopped:</p> <pre><code>import asyncio\n\nfrom fluid.utils.worker import Worker\n\n\nclass SimpleWorker(Worker):\n    async def run(self):\n        while self.is_running():\n            self.print_message()\n            await asyncio.sleep(1)\n\n    def print_message(self):\n        print(f\"Hello from {self.worker_name} in state {self.worker_state}\")\n\n\nasync def main():\n    worker = SimpleWorker()\n    worker.print_message()\n    await worker.startup()\n    asyncio.get_event_loop().call_later(5, worker.gracefully_stop)\n    await worker.wait_for_shutdown()\n    worker.print_message()\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"tutorials/workers/#shutdown","title":"Shutdown","text":"<p>To shut down a worker there are few possibilities.</p> <ul> <li>Direct call to the async Worker.shutdown method which will trigger the graceful shutdown and wait for the worker to finish its work.</li> <li>Call the Worker.gracefully_stop method which will trigger the graceful shutdown. Importantly, this method does not wait for the worker to finish its work, ti simply transition from the WorkerState.RUNNING to WorkerState.STOPPING state. To wait for the worker exit one should call the async Worker.wait_for_shutdown method (as in the example above)</li> </ul>"}]}