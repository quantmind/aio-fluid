{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Aio Fluid</p> <p>Async utilities for backend python services developed by Quantmind.</p> <p> </p> <p>Documentation: fluid.quantmind.com</p> <p>Source Code: github.com/quantmind/aio-fluid</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Async tasks scheduler and consumer: A task scheduler and consumer for async and CPU bound tasks.</li> <li>Async CRUD database operations: An async CRUD interface for postgres databases.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>This is a simple python package you can install via pip:</p> <pre><code>pip install aio-fluid\n</code></pre> <p>To install all the dependencies:</p> <p><pre><code>pip install aio-fluid[cli, db, http, log]\n</code></pre> this includes the following extra dependencies:</p> <ul> <li><code>cli</code> for the command line interface using click and rich</li> <li><code>db</code> for database support with asyncpg and sqlalchemy</li> <li><code>http</code> for http client support with httpx and aiohttp</li> <li><code>log</code> for JSON logging support with python-json-logger</li> </ul>"},{"location":"#development","title":"Development","text":"<p>You can run the examples via</p> <pre><code>poetry run python -m examples.main\n</code></pre>"},{"location":"reference/","title":"Introduction","text":"<p>Here's the reference or code API, the classes, functions, parameters, attributes, and all the <code>aio-fluid</code> parts you can use in your applications.</p>"},{"location":"reference/db/","title":"Database","text":"<p>It can be imported from <code>fluid.db</code>:</p> <pre><code>from fluid.db import Database\n</code></pre>"},{"location":"reference/db/#fluid.db.Database","title":"fluid.db.Database  <code>dataclass</code>","text":"<pre><code>Database(\n    dsn,\n    echo=DBECHO,\n    pool_size=DBPOOL_MAX_SIZE,\n    max_overflow=DBPOOL_MAX_OVERFLOW,\n    metadata=MetaData(),\n    migration_path=\"\",\n    app_name=APP_NAME,\n    _engine=None,\n)\n</code></pre> <p>A container for tables in a database and a manager of asynchronous connections to a postgresql database</p>"},{"location":"reference/db/#fluid.db.Database.dsn","title":"dsn  <code>instance-attribute</code>","text":"<pre><code>dsn\n</code></pre> <p>data source name, aka connection string</p> <p>Example: \"postgresql+asyncpg://user:password@localhost/dbname\"</p>"},{"location":"reference/db/#fluid.db.Database.echo","title":"echo  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>echo = DBECHO\n</code></pre>"},{"location":"reference/db/#fluid.db.Database.pool_size","title":"pool_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pool_size = DBPOOL_MAX_SIZE\n</code></pre>"},{"location":"reference/db/#fluid.db.Database.max_overflow","title":"max_overflow  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_overflow = DBPOOL_MAX_OVERFLOW\n</code></pre>"},{"location":"reference/db/#fluid.db.Database.metadata","title":"metadata  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metadata = field(default_factory=MetaData)\n</code></pre>"},{"location":"reference/db/#fluid.db.Database.migration_path","title":"migration_path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>migration_path = ''\n</code></pre>"},{"location":"reference/db/#fluid.db.Database.app_name","title":"app_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>app_name = APP_NAME\n</code></pre>"},{"location":"reference/db/#fluid.db.Database.tables","title":"tables  <code>property</code>","text":"<pre><code>tables\n</code></pre> <p>A dictionary of tables in the database</p>"},{"location":"reference/db/#fluid.db.Database.engine","title":"engine  <code>property</code>","text":"<pre><code>engine\n</code></pre> <p>The :class:<code>sqlalchemy.ext.asyncio.AsyncEngine</code> creating connection and transactions</p>"},{"location":"reference/db/#fluid.db.Database.sync_engine","title":"sync_engine  <code>property</code>","text":"<pre><code>sync_engine\n</code></pre> <p>The :class:<code>sqlalchemy.engine.Engine</code> for synchrouns operations</p>"},{"location":"reference/db/#fluid.db.Database.from_env","title":"from_env  <code>classmethod</code>","text":"<pre><code>from_env(*, dsn=DATABASE, schema=DATABASE_SCHEMA, **kwargs)\n</code></pre> <p>Create a new database container from environment variables as defaults</p> PARAMETER DESCRIPTION <code>dsn</code> <p> TYPE: <code>str</code> DEFAULT: <code>DATABASE</code> </p> <code>schema</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>DATABASE_SCHEMA</code> </p> <code>**kwargs</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>fluid/db/container.py</code> <pre><code>@classmethod\ndef from_env(\n    cls,\n    *,\n    dsn: str = settings.DATABASE,\n    schema: str | None = settings.DATABASE_SCHEMA,\n    **kwargs: Any,\n) -&gt; Self:\n    \"\"\"Create a new database container from environment variables as defaults\"\"\"\n    return cls(dsn=dsn, metadata=sa.MetaData(schema=schema), **kwargs)\n</code></pre>"},{"location":"reference/db/#fluid.db.Database.cli","title":"cli","text":"<pre><code>cli(**kwargs)\n</code></pre> <p>Create a new click group for database commands</p> PARAMETER DESCRIPTION <code>**kwargs</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>fluid/db/container.py</code> <pre><code>def cli(self, **kwargs: Any) -&gt; DbGroup:\n    \"\"\"Create a new click group for database commands\"\"\"\n    return DbGroup(self, **kwargs)\n</code></pre>"},{"location":"reference/db/#fluid.db.Database.connection","title":"connection  <code>async</code>","text":"<pre><code>connection()\n</code></pre> <p>Context manager for obtaining an asynchronous connection</p> Source code in <code>fluid/db/container.py</code> <pre><code>@asynccontextmanager\nasync def connection(self) -&gt; AsyncIterator[AsyncConnection]:\n    \"\"\"Context manager for obtaining an asynchronous connection\"\"\"\n    async with self.engine.connect() as conn:\n        yield conn\n</code></pre>"},{"location":"reference/db/#fluid.db.Database.ensure_connection","title":"ensure_connection  <code>async</code>","text":"<pre><code>ensure_connection(conn=None)\n</code></pre> <p>Context manager for obtaining an asynchronous connection</p> PARAMETER DESCRIPTION <code>conn</code> <p> TYPE: <code>AsyncConnection | None</code> DEFAULT: <code>None</code> </p> Source code in <code>fluid/db/container.py</code> <pre><code>@asynccontextmanager\nasync def ensure_connection(\n    self,\n    conn: AsyncConnection | None = None,\n) -&gt; AsyncIterator[AsyncConnection]:\n    \"\"\"Context manager for obtaining an asynchronous connection\"\"\"\n    if conn:\n        yield conn\n    else:\n        async with self.engine.connect() as conn:\n            yield conn\n</code></pre>"},{"location":"reference/db/#fluid.db.Database.transaction","title":"transaction  <code>async</code>","text":"<pre><code>transaction()\n</code></pre> <p>Context manager for initializing an asynchronous database transaction</p> Source code in <code>fluid/db/container.py</code> <pre><code>@asynccontextmanager\nasync def transaction(self) -&gt; AsyncIterator[AsyncConnection]:\n    \"\"\"Context manager for initializing an asynchronous database transaction\"\"\"\n    async with self.engine.begin() as conn:\n        yield conn\n</code></pre>"},{"location":"reference/db/#fluid.db.Database.ensure_transaction","title":"ensure_transaction  <code>async</code>","text":"<pre><code>ensure_transaction(conn=None)\n</code></pre> <p>Context manager for ensuring we a connection has initialized a database transaction</p> PARAMETER DESCRIPTION <code>conn</code> <p> TYPE: <code>AsyncConnection | None</code> DEFAULT: <code>None</code> </p> Source code in <code>fluid/db/container.py</code> <pre><code>@asynccontextmanager\nasync def ensure_transaction(\n    self,\n    conn: AsyncConnection | None = None,\n) -&gt; AsyncIterator[AsyncConnection]:\n    \"\"\"Context manager for ensuring we a connection has initialized\n    a database transaction\"\"\"\n    if conn:\n        if not conn.in_transaction():\n            async with conn.begin():\n                yield conn\n        else:\n            yield conn\n    else:\n        async with self.transaction() as conn:\n            yield conn\n</code></pre>"},{"location":"reference/db/#fluid.db.Database.close","title":"close  <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Close the asynchronous db engine if opened</p> Source code in <code>fluid/db/container.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close the asynchronous db engine if opened\"\"\"\n    if self._engine is not None:\n        engine, self._engine = self._engine, None\n        await engine.dispose()\n</code></pre>"},{"location":"reference/db/#fluid.db.Database.ping","title":"ping  <code>async</code>","text":"<pre><code>ping()\n</code></pre> <p>Ping the database</p> Source code in <code>fluid/db/container.py</code> <pre><code>async def ping(self) -&gt; str:\n    \"\"\"Ping the database\"\"\"\n    # TODO: we need a custom ping query\n    async with self.connection() as conn:\n        await conn.execute(sa.text(\"SELECT 1\"))\n    return \"ok\"\n</code></pre>"},{"location":"reference/db/#fluid.db.Database.migration","title":"migration","text":"<pre><code>migration()\n</code></pre> <p>Create a new migration manager for this database</p> Source code in <code>fluid/db/container.py</code> <pre><code>def migration(self) -&gt; Migration:\n    \"\"\"Create a new migration manager for this database\"\"\"\n    return Migration(self)\n</code></pre>"},{"location":"reference/db_crud/","title":"CrudDB","text":"<p>The CrudDB class inherits from Database to provide standard CRUD operations for a database table.</p> <p>It can be imported from <code>fluid.db</code>:</p> <pre><code>from fluid.db import CrudDB\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB","title":"fluid.db.CrudDB  <code>dataclass</code>","text":"<pre><code>CrudDB(\n    dsn,\n    echo=DBECHO,\n    pool_size=DBPOOL_MAX_SIZE,\n    max_overflow=DBPOOL_MAX_OVERFLOW,\n    metadata=MetaData(),\n    migration_path=\"\",\n    app_name=APP_NAME,\n    _engine=None,\n)\n</code></pre> <p>               Bases: <code>Database</code></p> <p>A :class:<code>.Database</code> with additional methods for CRUD operations</p>"},{"location":"reference/db_crud/#fluid.db.CrudDB.dsn","title":"dsn  <code>instance-attribute</code>","text":"<pre><code>dsn\n</code></pre> <p>data source name, aka connection string</p> <p>Example: \"postgresql+asyncpg://user:password@localhost/dbname\"</p>"},{"location":"reference/db_crud/#fluid.db.CrudDB.echo","title":"echo  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>echo = DBECHO\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.pool_size","title":"pool_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pool_size = DBPOOL_MAX_SIZE\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.max_overflow","title":"max_overflow  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_overflow = DBPOOL_MAX_OVERFLOW\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.metadata","title":"metadata  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metadata = field(default_factory=MetaData)\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.migration_path","title":"migration_path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>migration_path = ''\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.app_name","title":"app_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>app_name = APP_NAME\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.tables","title":"tables  <code>property</code>","text":"<pre><code>tables\n</code></pre> <p>A dictionary of tables in the database</p>"},{"location":"reference/db_crud/#fluid.db.CrudDB.engine","title":"engine  <code>property</code>","text":"<pre><code>engine\n</code></pre> <p>The :class:<code>sqlalchemy.ext.asyncio.AsyncEngine</code> creating connection and transactions</p>"},{"location":"reference/db_crud/#fluid.db.CrudDB.sync_engine","title":"sync_engine  <code>property</code>","text":"<pre><code>sync_engine\n</code></pre> <p>The :class:<code>sqlalchemy.engine.Engine</code> for synchrouns operations</p>"},{"location":"reference/db_crud/#fluid.db.CrudDB.from_env","title":"from_env  <code>classmethod</code>","text":"<pre><code>from_env(*, dsn=DATABASE, schema=DATABASE_SCHEMA, **kwargs)\n</code></pre> <p>Create a new database container from environment variables as defaults</p> PARAMETER DESCRIPTION <code>dsn</code> <p> TYPE: <code>str</code> DEFAULT: <code>DATABASE</code> </p> <code>schema</code> <p> TYPE: <code>str | None</code> DEFAULT: <code>DATABASE_SCHEMA</code> </p> <code>**kwargs</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>fluid/db/container.py</code> <pre><code>@classmethod\ndef from_env(\n    cls,\n    *,\n    dsn: str = settings.DATABASE,\n    schema: str | None = settings.DATABASE_SCHEMA,\n    **kwargs: Any,\n) -&gt; Self:\n    \"\"\"Create a new database container from environment variables as defaults\"\"\"\n    return cls(dsn=dsn, metadata=sa.MetaData(schema=schema), **kwargs)\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.cli","title":"cli","text":"<pre><code>cli(**kwargs)\n</code></pre> <p>Create a new click group for database commands</p> PARAMETER DESCRIPTION <code>**kwargs</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>fluid/db/container.py</code> <pre><code>def cli(self, **kwargs: Any) -&gt; DbGroup:\n    \"\"\"Create a new click group for database commands\"\"\"\n    return DbGroup(self, **kwargs)\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.connection","title":"connection  <code>async</code>","text":"<pre><code>connection()\n</code></pre> <p>Context manager for obtaining an asynchronous connection</p> Source code in <code>fluid/db/container.py</code> <pre><code>@asynccontextmanager\nasync def connection(self) -&gt; AsyncIterator[AsyncConnection]:\n    \"\"\"Context manager for obtaining an asynchronous connection\"\"\"\n    async with self.engine.connect() as conn:\n        yield conn\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.ensure_connection","title":"ensure_connection  <code>async</code>","text":"<pre><code>ensure_connection(conn=None)\n</code></pre> <p>Context manager for obtaining an asynchronous connection</p> PARAMETER DESCRIPTION <code>conn</code> <p> TYPE: <code>AsyncConnection | None</code> DEFAULT: <code>None</code> </p> Source code in <code>fluid/db/container.py</code> <pre><code>@asynccontextmanager\nasync def ensure_connection(\n    self,\n    conn: AsyncConnection | None = None,\n) -&gt; AsyncIterator[AsyncConnection]:\n    \"\"\"Context manager for obtaining an asynchronous connection\"\"\"\n    if conn:\n        yield conn\n    else:\n        async with self.engine.connect() as conn:\n            yield conn\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.transaction","title":"transaction  <code>async</code>","text":"<pre><code>transaction()\n</code></pre> <p>Context manager for initializing an asynchronous database transaction</p> Source code in <code>fluid/db/container.py</code> <pre><code>@asynccontextmanager\nasync def transaction(self) -&gt; AsyncIterator[AsyncConnection]:\n    \"\"\"Context manager for initializing an asynchronous database transaction\"\"\"\n    async with self.engine.begin() as conn:\n        yield conn\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.ensure_transaction","title":"ensure_transaction  <code>async</code>","text":"<pre><code>ensure_transaction(conn=None)\n</code></pre> <p>Context manager for ensuring we a connection has initialized a database transaction</p> PARAMETER DESCRIPTION <code>conn</code> <p> TYPE: <code>AsyncConnection | None</code> DEFAULT: <code>None</code> </p> Source code in <code>fluid/db/container.py</code> <pre><code>@asynccontextmanager\nasync def ensure_transaction(\n    self,\n    conn: AsyncConnection | None = None,\n) -&gt; AsyncIterator[AsyncConnection]:\n    \"\"\"Context manager for ensuring we a connection has initialized\n    a database transaction\"\"\"\n    if conn:\n        if not conn.in_transaction():\n            async with conn.begin():\n                yield conn\n        else:\n            yield conn\n    else:\n        async with self.transaction() as conn:\n            yield conn\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.close","title":"close  <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Close the asynchronous db engine if opened</p> Source code in <code>fluid/db/container.py</code> <pre><code>async def close(self) -&gt; None:\n    \"\"\"Close the asynchronous db engine if opened\"\"\"\n    if self._engine is not None:\n        engine, self._engine = self._engine, None\n        await engine.dispose()\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.ping","title":"ping  <code>async</code>","text":"<pre><code>ping()\n</code></pre> <p>Ping the database</p> Source code in <code>fluid/db/container.py</code> <pre><code>async def ping(self) -&gt; str:\n    \"\"\"Ping the database\"\"\"\n    # TODO: we need a custom ping query\n    async with self.connection() as conn:\n        await conn.execute(sa.text(\"SELECT 1\"))\n    return \"ok\"\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.migration","title":"migration","text":"<pre><code>migration()\n</code></pre> <p>Create a new migration manager for this database</p> Source code in <code>fluid/db/container.py</code> <pre><code>def migration(self) -&gt; Migration:\n    \"\"\"Create a new migration manager for this database\"\"\"\n    return Migration(self)\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.db_select","title":"db_select  <code>async</code>","text":"<pre><code>db_select(table, filters, *, order_by=None, conn=None)\n</code></pre> <p>Select rows from a given table :param table: sqlalchemy Table :param filters: key-value pairs for filtering rows :param conn: optional db connection :param consumer: optional consumer (see :meth:<code>.get_query</code>)</p> PARAMETER DESCRIPTION <code>table</code> <p> TYPE: <code>FromClause</code> </p> <code>filters</code> <p> TYPE: <code>dict</code> </p> <code>order_by</code> <p> TYPE: <code>tuple[str, ...] | None</code> DEFAULT: <code>None</code> </p> <code>conn</code> <p> TYPE: <code>AsyncConnection | None</code> DEFAULT: <code>None</code> </p> Source code in <code>fluid/db/crud.py</code> <pre><code>async def db_select(\n    self,\n    table: FromClause,\n    filters: dict,\n    *,\n    order_by: tuple[str, ...] | None = None,\n    conn: AsyncConnection | None = None,\n) -&gt; CursorResult:\n    \"\"\"Select rows from a given table\n    :param table: sqlalchemy Table\n    :param filters: key-value pairs for filtering rows\n    :param conn: optional db connection\n    :param consumer: optional consumer (see :meth:`.get_query`)\n    \"\"\"\n    sql_query = self.get_query(table, Select(table), params=filters)\n    if order_by:\n        sql_query = self.order_by_query(table, cast(Select, sql_query), order_by)\n    async with self.ensure_transaction(conn) as conn:\n        return await conn.execute(sql_query)\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.db_insert","title":"db_insert  <code>async</code>","text":"<pre><code>db_insert(table, data, *, conn=None)\n</code></pre> <p>Perform an insert into a table :param table: sqlalchemy Table :param data: key-value pairs for columns values :param conn: optional db connection</p> PARAMETER DESCRIPTION <code>table</code> <p> TYPE: <code>Table</code> </p> <code>data</code> <p> TYPE: <code>list[dict] | dict</code> </p> <code>conn</code> <p> TYPE: <code>AsyncConnection | None</code> DEFAULT: <code>None</code> </p> Source code in <code>fluid/db/crud.py</code> <pre><code>async def db_insert(\n    self,\n    table: Table,\n    data: list[dict] | dict,\n    *,\n    conn: AsyncConnection | None = None,\n) -&gt; CursorResult:\n    \"\"\"Perform an insert into a table\n    :param table: sqlalchemy Table\n    :param data: key-value pairs for columns values\n    :param conn: optional db connection\n    \"\"\"\n    async with self.ensure_transaction(conn) as conn:\n        sql_query = self.insert_query(table, data)\n        return await conn.execute(sql_query)\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.db_update","title":"db_update  <code>async</code>","text":"<pre><code>db_update(table, filters, data, *, conn=None)\n</code></pre> <p>Perform an update of rows</p> <p>:param table: sqlalchemy Table :param filters: key-value pairs for filtering rows to update :param data: key-value pairs for updating columns values of selected rows :param conn: optional db connection :param consumer: optional consumer (see :meth:<code>.get_query</code>)</p> PARAMETER DESCRIPTION <code>table</code> <p> TYPE: <code>Table</code> </p> <code>filters</code> <p> TYPE: <code>dict</code> </p> <code>data</code> <p> TYPE: <code>dict</code> </p> <code>conn</code> <p> TYPE: <code>AsyncConnection | None</code> DEFAULT: <code>None</code> </p> Source code in <code>fluid/db/crud.py</code> <pre><code>async def db_update(\n    self,\n    table: Table,\n    filters: dict,\n    data: dict,\n    *,\n    conn: AsyncConnection | None = None,\n) -&gt; CursorResult:\n    \"\"\"Perform an update of rows\n\n    :param table: sqlalchemy Table\n    :param filters: key-value pairs for filtering rows to update\n    :param data: key-value pairs for updating columns values of selected rows\n    :param conn: optional db connection\n    :param consumer: optional consumer (see :meth:`.get_query`)\n    \"\"\"\n    update = (\n        cast(\n            Update,\n            self.get_query(table, table.update(), params=filters),\n        )\n        .values(**data)\n        .returning(*table.columns)\n    )\n    async with self.ensure_transaction(conn) as conn:\n        return await conn.execute(update)\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.db_upsert","title":"db_upsert  <code>async</code>","text":"<pre><code>db_upsert(table, filters, data=None, *, conn=None)\n</code></pre> <p>Perform an upsert for a single record</p> <p>:param table: sqlalchemy Table :param filters: key-value pairs for filtering rows to update :param data: key-value pairs for updating columns values of selected rows :param conn: optional db connection :param consumer: optional consumer (see :meth:<code>.get_query</code>)</p> PARAMETER DESCRIPTION <code>table</code> <p> TYPE: <code>Table</code> </p> <code>filters</code> <p> TYPE: <code>dict</code> </p> <code>data</code> <p> TYPE: <code>dict | None</code> DEFAULT: <code>None</code> </p> <code>conn</code> <p> TYPE: <code>AsyncConnection | None</code> DEFAULT: <code>None</code> </p> Source code in <code>fluid/db/crud.py</code> <pre><code>async def db_upsert(\n    self,\n    table: Table,\n    filters: dict,\n    data: dict | None = None,\n    *,\n    conn: AsyncConnection | None = None,\n) -&gt; Row:\n    \"\"\"Perform an upsert for a single record\n\n    :param table: sqlalchemy Table\n    :param filters: key-value pairs for filtering rows to update\n    :param data: key-value pairs for updating columns values of selected rows\n    :param conn: optional db connection\n    :param consumer: optional consumer (see :meth:`.get_query`)\n    \"\"\"\n    if data:\n        result = await self.db_update(table, filters, data, conn=conn)\n    else:\n        result = await self.db_select(table, filters, conn=conn)\n    record = result.one_or_none()\n    if record is None:\n        insert_data = data.copy() if data else {}\n        insert_data.update(filters)\n        result = await self.db_insert(table, insert_data, conn=conn)\n        record = result.one()\n    return record\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.db_delete","title":"db_delete  <code>async</code>","text":"<pre><code>db_delete(table, filters, *, conn=None)\n</code></pre> <p>Delete rows from a given table :param table: sqlalchemy Table :param filters: key-value pairs for filtering rows :param conn: optional db connection :param consumer: optional consumer (see :meth:<code>.get_query</code>)</p> PARAMETER DESCRIPTION <code>table</code> <p> TYPE: <code>Table</code> </p> <code>filters</code> <p> TYPE: <code>dict</code> </p> <code>conn</code> <p> TYPE: <code>AsyncConnection | None</code> DEFAULT: <code>None</code> </p> Source code in <code>fluid/db/crud.py</code> <pre><code>async def db_delete(\n    self,\n    table: Table,\n    filters: dict,\n    *,\n    conn: AsyncConnection | None = None,\n) -&gt; CursorResult:\n    \"\"\"Delete rows from a given table\n    :param table: sqlalchemy Table\n    :param filters: key-value pairs for filtering rows\n    :param conn: optional db connection\n    :param consumer: optional consumer (see :meth:`.get_query`)\n    \"\"\"\n    sql_query = self.get_query(\n        table,\n        table.delete().returning(*table.columns),\n        params=filters,\n    )\n    async with self.ensure_transaction(conn) as conn:\n        return await conn.execute(sql_query)\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.db_count","title":"db_count  <code>async</code>","text":"<pre><code>db_count(table, filters, *, conn=None)\n</code></pre> <p>Count rows in a table :param table: sqlalchemy Table :param filters: key-value pairs for filtering rows :param conn: optional db connection :param consumer: optional consumer (see :meth:<code>.get_query</code>)</p> PARAMETER DESCRIPTION <code>table</code> <p> TYPE: <code>FromClause</code> </p> <code>filters</code> <p> TYPE: <code>dict</code> </p> <code>conn</code> <p> TYPE: <code>AsyncConnection | None</code> DEFAULT: <code>None</code> </p> Source code in <code>fluid/db/crud.py</code> <pre><code>async def db_count(\n    self,\n    table: FromClause,\n    filters: dict,\n    *,\n    conn: AsyncConnection | None = None,\n) -&gt; int:\n    \"\"\"Count rows in a table\n    :param table: sqlalchemy Table\n    :param filters: key-value pairs for filtering rows\n    :param conn: optional db connection\n    :param consumer: optional consumer (see :meth:`.get_query`)\n    \"\"\"\n    count_query = self.db_count_query(\n        cast(\n            Select,\n            self.get_query(\n                table,\n                table.select(),\n                params=filters,\n            ),\n        ),\n    )\n    async with self.ensure_connection(conn) as conn:\n        result: CursorResult = await conn.execute(count_query)\n        return cast(int, result.scalar())\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.insert_query","title":"insert_query","text":"<pre><code>insert_query(table, records)\n</code></pre> PARAMETER DESCRIPTION <code>table</code> <p> TYPE: <code>Table</code> </p> <code>records</code> <p> TYPE: <code>list[dict] | dict</code> </p> Source code in <code>fluid/db/crud.py</code> <pre><code>def insert_query(self, table: Table, records: list[dict] | dict) -&gt; Insert:\n    if isinstance(records, dict):\n        records = [records]\n    else:\n        cols: Set[str] = set()\n        for record in records:\n            cols.update(record)\n        new_records = []\n        for record in records:\n            if len(record) &lt; len(cols):\n                record = record.copy()\n                missing = cols.difference(record)\n                for col in missing:\n                    record[col] = None\n            new_records.append(record)\n        records = new_records\n    return insert(table).values(records).returning(*table.columns)\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.get_query","title":"get_query","text":"<pre><code>get_query(table, sql_query, *, params=None)\n</code></pre> <p>Build an SqlAlchemy query :param table: sqlalchemy Table :param sql_query: sqlalchemy query type :param params: key-value pairs for the query :param consumer: optional consumer for manipulating parameters</p> PARAMETER DESCRIPTION <code>table</code> <p> TYPE: <code>FromClause</code> </p> <code>sql_query</code> <p> TYPE: <code>QueryType</code> </p> <code>params</code> <p> TYPE: <code>dict | None</code> DEFAULT: <code>None</code> </p> Source code in <code>fluid/db/crud.py</code> <pre><code>def get_query(\n    self,\n    table: FromClause,\n    sql_query: QueryType,\n    *,\n    params: dict | None = None,\n) -&gt; QueryType:\n    \"\"\"Build an SqlAlchemy query\n    :param table: sqlalchemy Table\n    :param sql_query: sqlalchemy query type\n    :param params: key-value pairs for the query\n    :param consumer: optional consumer for manipulating parameters\n    \"\"\"\n    filters: list = []\n    columns = table.c\n    params = params or {}\n\n    for key, value in params.items():\n        bits = key.split(\":\")\n        field = bits[0]\n        op = bits[1] if len(bits) == 2 else \"eq\"\n        field = getattr(columns, field)\n        result = self.default_filter_column(field, op, value)\n        if result is not None:\n            if not isinstance(result, (list, tuple)):\n                result = (result,)\n            filters.extend(result)\n    if filters:\n        whereclause = and_(*filters) if len(filters) &gt; 1 else filters[0]\n        sql_query = cast(Select, sql_query).where(whereclause)\n    return sql_query\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.db_count_query","title":"db_count_query","text":"<pre><code>db_count_query(sql_query)\n</code></pre> PARAMETER DESCRIPTION <code>sql_query</code> <p> TYPE: <code>Select</code> </p> Source code in <code>fluid/db/crud.py</code> <pre><code>def db_count_query(self, sql_query: Select) -&gt; Select:\n    return select(func.count()).select_from(sql_query.alias(\"inner\"))\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.order_by_query","title":"order_by_query","text":"<pre><code>order_by_query(table, sql_query, order_by)\n</code></pre> <p>Apply ordering to a sql_query</p> PARAMETER DESCRIPTION <code>table</code> <p> TYPE: <code>FromClause</code> </p> <code>sql_query</code> <p> TYPE: <code>Select</code> </p> <code>order_by</code> <p> TYPE: <code>tuple[str, ...]</code> </p> Source code in <code>fluid/db/crud.py</code> <pre><code>def order_by_query(\n    self,\n    table: FromClause,\n    sql_query: Select,\n    order_by: tuple[str, ...],\n) -&gt; Select:\n    \"\"\"Apply ordering to a sql_query\"\"\"\n    return sql_query.order_by(*self.order_by_columns(table, order_by))\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.order_by_columns","title":"order_by_columns","text":"<pre><code>order_by_columns(table, order_by)\n</code></pre> <p>Apply ordering to a sql_query</p> PARAMETER DESCRIPTION <code>table</code> <p> TYPE: <code>FromClause</code> </p> <code>order_by</code> <p> TYPE: <code>tuple[str, ...]</code> </p> Source code in <code>fluid/db/crud.py</code> <pre><code>def order_by_columns(\n    self,\n    table: FromClause,\n    order_by: tuple[str, ...],\n) -&gt; list[Column]:\n    \"\"\"Apply ordering to a sql_query\"\"\"\n    columns = []\n    for name in order_by:\n        if name.startswith(\"-\"):\n            order_by_column = getattr(table.c, name[1:], None)\n            if order_by_column is not None:\n                columns.append(order_by_column.desc())\n        else:\n            order_by_column = getattr(table.c, name, None)\n            if order_by_column is not None:\n                columns.append(order_by_column)\n    return columns\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.search_query","title":"search_query","text":"<pre><code>search_query(table, sql_query, search_fields, search)\n</code></pre> <p>Apply search to a sql_query</p> PARAMETER DESCRIPTION <code>table</code> <p> TYPE: <code>FromClause</code> </p> <code>sql_query</code> <p> TYPE: <code>Select</code> </p> <code>search_fields</code> <p> TYPE: <code>tuple[str, ...]</code> </p> <code>search</code> <p> TYPE: <code>str</code> </p> Source code in <code>fluid/db/crud.py</code> <pre><code>def search_query(\n    self,\n    table: FromClause,\n    sql_query: Select,\n    search_fields: tuple[str, ...],\n    search: str,\n) -&gt; Select:\n    \"\"\"Apply search to a sql_query\"\"\"\n    if search and search_fields:\n        columns = [getattr(table.c, col) for col in search_fields]\n        return sql_query.where(or_(*(col.ilike(f\"%{search}%\") for col in columns)))\n    return sql_query\n</code></pre>"},{"location":"reference/db_crud/#fluid.db.CrudDB.default_filter_column","title":"default_filter_column","text":"<pre><code>default_filter_column(column, op, value)\n</code></pre> <p>Applies a filter on a field. Notes on 'ne' op: Example data: [None, 'john', 'roger'] ne:john would return only roger (i.e. nulls excluded) ne:     would return john and roger Notes on  'search' op: For some reason, SQLAlchemy uses to_tsquery rather than plainto_tsquery for the match operator to_tsquery uses operators (&amp;, |, ! etc.) while plainto_tsquery tokenises the input string and uses AND between tokens, hence plainto_tsquery is what we want here For other database back ends, the behaviour of the match operator is completely different - see: http://docs.sqlalchemy.org/en/rel_1_0/core/sqlelement.html :param field: field name :param op: 'eq', 'ne', 'gt', 'lt', 'ge', 'le' or 'search' :param value: comparison value, string or list/tuple :return:</p> PARAMETER DESCRIPTION <code>column</code> <p> TYPE: <code>Column</code> </p> <code>op</code> <p> TYPE: <code>str</code> </p> <code>value</code> <p> TYPE: <code>Any</code> </p> Source code in <code>fluid/db/crud.py</code> <pre><code>def default_filter_column(self, column: Column, op: str, value: Any) -&gt; Any:\n    \"\"\"\n    Applies a filter on a field.\n    Notes on 'ne' op:\n    Example data: [None, 'john', 'roger']\n    ne:john would return only roger (i.e. nulls excluded)\n    ne:     would return john and roger\n    Notes on  'search' op:\n    For some reason, SQLAlchemy uses to_tsquery rather than\n    plainto_tsquery for the match operator\n    to_tsquery uses operators (&amp;, |, ! etc.) while\n    plainto_tsquery tokenises the input string and uses AND between\n    tokens, hence plainto_tsquery is what we want here\n    For other database back ends, the behaviour of the match\n    operator is completely different - see:\n    http://docs.sqlalchemy.org/en/rel_1_0/core/sqlelement.html\n    :param field: field name\n    :param op: 'eq', 'ne', 'gt', 'lt', 'ge', 'le' or 'search'\n    :param value: comparison value, string or list/tuple\n    :return:\n    \"\"\"\n    if multiple := isinstance(value, (list, tuple)):\n        value = tuple(column_value_to_python(column, v) for v in value)\n    else:\n        value = column_value_to_python(column, value)\n\n    if multiple and op in (\"eq\", \"ne\"):\n        if op == \"eq\":\n            return column.in_(value)\n        elif op == \"ne\":\n            return ~column.in_(value)\n    else:\n        if multiple:\n            assert len(value) &gt; 0\n            value = value[0]\n\n        if op == \"eq\":\n            return column == value\n        elif op == \"ne\":\n            return column != value\n        elif op == \"gt\":\n            return column &gt; value\n        elif op == \"ge\":\n            return column &gt;= value\n        elif op == \"lt\":\n            return column &lt; value\n        elif op == \"le\":\n            return column &lt;= value\n</code></pre>"},{"location":"reference/db_pagination/","title":"Pagination","text":"<p>The Pagination class is a tool for managing paginated rows from the database.</p> <p>It can be imported from <code>fluid.db</code>:</p> <pre><code>from fluid.db import Pagination, Search\n</code></pre>"},{"location":"reference/db_pagination/#fluid.db.Pagination","title":"fluid.db.Pagination","text":"<p>               Bases: <code>NamedTuple</code></p>"},{"location":"reference/db_pagination/#fluid.db.Pagination.order_by_fields","title":"order_by_fields  <code>instance-attribute</code>","text":"<pre><code>order_by_fields\n</code></pre>"},{"location":"reference/db_pagination/#fluid.db.Pagination.limit","title":"limit  <code>instance-attribute</code>","text":"<pre><code>limit\n</code></pre>"},{"location":"reference/db_pagination/#fluid.db.Pagination.filters","title":"filters  <code>instance-attribute</code>","text":"<pre><code>filters\n</code></pre>"},{"location":"reference/db_pagination/#fluid.db.Pagination.search","title":"search  <code>instance-attribute</code>","text":"<pre><code>search\n</code></pre>"},{"location":"reference/db_pagination/#fluid.db.Pagination.cursor","title":"cursor  <code>instance-attribute</code>","text":"<pre><code>cursor\n</code></pre>"},{"location":"reference/db_pagination/#fluid.db.Pagination.desc","title":"desc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>desc = False\n</code></pre>"},{"location":"reference/db_pagination/#fluid.db.Pagination.order_by_fields_sign","title":"order_by_fields_sign  <code>property</code>","text":"<pre><code>order_by_fields_sign\n</code></pre>"},{"location":"reference/db_pagination/#fluid.db.Pagination.create","title":"create  <code>classmethod</code>","text":"<pre><code>create(\n    *order_by_fields,\n    cursor=\"\",\n    limit=0,\n    filters=None,\n    search=None,\n    desc=False\n)\n</code></pre> PARAMETER DESCRIPTION <code>*order_by_fields</code> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> <code>cursor</code> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>limit</code> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>filters</code> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>search</code> <p> TYPE: <code>Search | None</code> DEFAULT: <code>None</code> </p> <code>desc</code> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>fluid/db/pagination.py</code> <pre><code>@classmethod\ndef create(\n    cls,\n    *order_by_fields: str,\n    cursor: str = \"\",\n    limit: int = 0,\n    filters: dict[str, Any] | None = None,\n    search: Search | None = None,\n    desc: bool = False,\n) -&gt; Pagination:\n    if limit &lt; 0:\n        raise ValidationError(\"limit must be greater than or equal to 0\")\n    if cursor:\n        if limit &gt; 0:\n            raise ValidationError(\"limit cannot be provided with cursor\")\n        if filters:\n            raise ValidationError(\"filters cannot be provided with cursor\")\n        if search and search.search_text:\n            raise ValidationError(\"search text cannot be provided with cursor\")\n        decoded_cursor = Cursor.decode(cursor, order_by_fields)\n        limit = decoded_cursor.limit\n        filters = decoded_cursor.filters\n        if search:\n            search = search._replace(search_text=decoded_cursor.search_text)\n    else:\n        decoded_cursor = None\n        limit = min(\n            limit or settings.DEFAULT_PAGINATION_LIMIT,\n            settings.DEFAULT_PAGINATION_MAX_LIMIT,\n        )\n    return cls(\n        order_by_fields=order_by_fields,\n        cursor=decoded_cursor,\n        limit=limit,\n        filters=filters or {},\n        search=search,\n        desc=desc,\n    )\n</code></pre>"},{"location":"reference/db_pagination/#fluid.db.Pagination.execute","title":"execute  <code>async</code>","text":"<pre><code>execute(db, table, *, conn=None)\n</code></pre> PARAMETER DESCRIPTION <code>db</code> <p> TYPE: <code>CrudDB</code> </p> <code>table</code> <p> TYPE: <code>FromClause</code> </p> <code>conn</code> <p> TYPE: <code>AsyncConnection | None</code> DEFAULT: <code>None</code> </p> Source code in <code>fluid/db/pagination.py</code> <pre><code>async def execute(\n    self,\n    db: CrudDB,\n    table: FromClause,\n    *,\n    conn: AsyncConnection | None = None,\n) -&gt; tuple[Sequence[Row], str]:\n    sql_query = self.query(db, table)\n    async with db.ensure_connection(conn) as conn:\n        result = await conn.execute(sql_query)\n    data = result.all()\n    cursor = \"\"\n    if len(data) &gt; self.limit:\n        cursor = self._encode_cursor(data[-1])\n        data = data[:-1]\n    return data, cursor\n</code></pre>"},{"location":"reference/db_pagination/#fluid.db.Pagination.query","title":"query","text":"<pre><code>query(db, table)\n</code></pre> PARAMETER DESCRIPTION <code>db</code> <p> TYPE: <code>CrudDB</code> </p> <code>table</code> <p> TYPE: <code>FromClause</code> </p> Source code in <code>fluid/db/pagination.py</code> <pre><code>def query(self, db: CrudDB, table: FromClause) -&gt; Select:\n    sql_query = cast(\n        Select,\n        db.get_query(table, table.select(), params=self.filters),\n    )\n    if self.search:\n        sql_query = db.search_query(\n            table,\n            sql_query,\n            self.search.search_fields,\n            self.search.search_text,\n        )\n    start_clause = self._start_clause(table)\n    if start_clause is not None:\n        sql_query = sql_query.where(start_clause)\n    columns = db.order_by_columns(table, self.order_by_fields_sign)\n    return sql_query.order_by(*columns).limit(self.limit + 1)\n</code></pre>"},{"location":"reference/db_pagination/#fluid.db.Search","title":"fluid.db.Search","text":"<p>               Bases: <code>NamedTuple</code></p>"},{"location":"reference/db_pagination/#fluid.db.Search.search_fields","title":"search_fields  <code>instance-attribute</code>","text":"<pre><code>search_fields\n</code></pre>"},{"location":"reference/db_pagination/#fluid.db.Search.search_text","title":"search_text  <code>instance-attribute</code>","text":"<pre><code>search_text\n</code></pre>"},{"location":"reference/dispatchers/","title":"Event Dispatchers","text":"<p>A set of classes for dispatching events, they can be imported from <code>fluid.utils.dispatcher</code>:</p> <pre><code>from fluid.utils.dispatcher import Dispatcher\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.BaseDispatcher","title":"fluid.utils.dispatcher.BaseDispatcher","text":"<pre><code>BaseDispatcher()\n</code></pre> <p>               Bases: <code>Generic[MessageType, MessageHandlerType]</code>, <code>ABC</code></p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._msg_handlers: defaultdict[str, dict[str, MessageHandlerType]] = (\n        defaultdict(\n            dict,\n        )\n    )\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.BaseDispatcher.register_handler","title":"register_handler","text":"<pre><code>register_handler(event, handler)\n</code></pre> PARAMETER DESCRIPTION <code>event</code> <p> TYPE: <code>Event | str</code> </p> <code>handler</code> <p> TYPE: <code>MessageHandlerType</code> </p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def register_handler(\n    self,\n    event: Event | str,\n    handler: MessageHandlerType,\n) -&gt; MessageHandlerType | None:\n    event = Event.from_string_or_event(event)\n    previous = self._msg_handlers[event.type].get(event.tag)\n    self._msg_handlers[event.type][event.tag] = handler\n    return previous\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.BaseDispatcher.unregister_handler","title":"unregister_handler","text":"<pre><code>unregister_handler(event)\n</code></pre> PARAMETER DESCRIPTION <code>event</code> <p> TYPE: <code>Event | str</code> </p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def unregister_handler(self, event: Event | str) -&gt; MessageHandlerType | None:\n    event = Event.from_string_or_event(event)\n    return self._msg_handlers[event.type].pop(event.tag, None)\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.BaseDispatcher.get_handlers","title":"get_handlers","text":"<pre><code>get_handlers(message)\n</code></pre> PARAMETER DESCRIPTION <code>message</code> <p> TYPE: <code>MessageType</code> </p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def get_handlers(\n    self,\n    message: MessageType,\n) -&gt; dict[str, MessageHandlerType] | None:\n    message_type = str(self.message_type(message))\n    return self._msg_handlers.get(message_type)\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.BaseDispatcher.message_type","title":"message_type  <code>abstractmethod</code>","text":"<pre><code>message_type(message)\n</code></pre> <p>return the message type</p> PARAMETER DESCRIPTION <code>message</code> <p> TYPE: <code>MessageType</code> </p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>@abstractmethod\ndef message_type(self, message: MessageType) -&gt; str:\n    \"\"\"return the message type\"\"\"\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.Dispatcher","title":"fluid.utils.dispatcher.Dispatcher","text":"<pre><code>Dispatcher()\n</code></pre> <p>               Bases: <code>BaseDispatcher[MessageType, Callable[[MessageType], None]]</code></p> <p>Dispatcher for sync handlers</p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._msg_handlers: defaultdict[str, dict[str, MessageHandlerType]] = (\n        defaultdict(\n            dict,\n        )\n    )\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.Dispatcher.register_handler","title":"register_handler","text":"<pre><code>register_handler(event, handler)\n</code></pre> PARAMETER DESCRIPTION <code>event</code> <p> TYPE: <code>Event | str</code> </p> <code>handler</code> <p> TYPE: <code>MessageHandlerType</code> </p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def register_handler(\n    self,\n    event: Event | str,\n    handler: MessageHandlerType,\n) -&gt; MessageHandlerType | None:\n    event = Event.from_string_or_event(event)\n    previous = self._msg_handlers[event.type].get(event.tag)\n    self._msg_handlers[event.type][event.tag] = handler\n    return previous\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.Dispatcher.unregister_handler","title":"unregister_handler","text":"<pre><code>unregister_handler(event)\n</code></pre> PARAMETER DESCRIPTION <code>event</code> <p> TYPE: <code>Event | str</code> </p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def unregister_handler(self, event: Event | str) -&gt; MessageHandlerType | None:\n    event = Event.from_string_or_event(event)\n    return self._msg_handlers[event.type].pop(event.tag, None)\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.Dispatcher.get_handlers","title":"get_handlers","text":"<pre><code>get_handlers(message)\n</code></pre> PARAMETER DESCRIPTION <code>message</code> <p> TYPE: <code>MessageType</code> </p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def get_handlers(\n    self,\n    message: MessageType,\n) -&gt; dict[str, MessageHandlerType] | None:\n    message_type = str(self.message_type(message))\n    return self._msg_handlers.get(message_type)\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.Dispatcher.message_type","title":"message_type  <code>abstractmethod</code>","text":"<pre><code>message_type(message)\n</code></pre> <p>return the message type</p> PARAMETER DESCRIPTION <code>message</code> <p> TYPE: <code>MessageType</code> </p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>@abstractmethod\ndef message_type(self, message: MessageType) -&gt; str:\n    \"\"\"return the message type\"\"\"\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.Dispatcher.dispatch","title":"dispatch","text":"<pre><code>dispatch(message)\n</code></pre> <p>dispatch the message</p> PARAMETER DESCRIPTION <code>message</code> <p> TYPE: <code>MessageType</code> </p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def dispatch(self, message: MessageType) -&gt; int:\n    \"\"\"dispatch the message\"\"\"\n    handlers = self.get_handlers(message)\n    if handlers:\n        for handler in handlers.values():\n            handler(message)\n    return len(handlers or ())\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.AsyncDispatcher","title":"fluid.utils.dispatcher.AsyncDispatcher","text":"<pre><code>AsyncDispatcher()\n</code></pre> <p>               Bases: <code>BaseDispatcher[MessageType, Callable[[MessageType], Awaitable[None]]]</code></p> <p>Dispatcher for async handlers</p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._msg_handlers: defaultdict[str, dict[str, MessageHandlerType]] = (\n        defaultdict(\n            dict,\n        )\n    )\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.AsyncDispatcher.register_handler","title":"register_handler","text":"<pre><code>register_handler(event, handler)\n</code></pre> PARAMETER DESCRIPTION <code>event</code> <p> TYPE: <code>Event | str</code> </p> <code>handler</code> <p> TYPE: <code>MessageHandlerType</code> </p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def register_handler(\n    self,\n    event: Event | str,\n    handler: MessageHandlerType,\n) -&gt; MessageHandlerType | None:\n    event = Event.from_string_or_event(event)\n    previous = self._msg_handlers[event.type].get(event.tag)\n    self._msg_handlers[event.type][event.tag] = handler\n    return previous\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.AsyncDispatcher.unregister_handler","title":"unregister_handler","text":"<pre><code>unregister_handler(event)\n</code></pre> PARAMETER DESCRIPTION <code>event</code> <p> TYPE: <code>Event | str</code> </p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def unregister_handler(self, event: Event | str) -&gt; MessageHandlerType | None:\n    event = Event.from_string_or_event(event)\n    return self._msg_handlers[event.type].pop(event.tag, None)\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.AsyncDispatcher.get_handlers","title":"get_handlers","text":"<pre><code>get_handlers(message)\n</code></pre> PARAMETER DESCRIPTION <code>message</code> <p> TYPE: <code>MessageType</code> </p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def get_handlers(\n    self,\n    message: MessageType,\n) -&gt; dict[str, MessageHandlerType] | None:\n    message_type = str(self.message_type(message))\n    return self._msg_handlers.get(message_type)\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.AsyncDispatcher.message_type","title":"message_type  <code>abstractmethod</code>","text":"<pre><code>message_type(message)\n</code></pre> <p>return the message type</p> PARAMETER DESCRIPTION <code>message</code> <p> TYPE: <code>MessageType</code> </p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>@abstractmethod\ndef message_type(self, message: MessageType) -&gt; str:\n    \"\"\"return the message type\"\"\"\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.AsyncDispatcher.dispatch","title":"dispatch  <code>async</code>","text":"<pre><code>dispatch(message)\n</code></pre> <p>Dispatch the message and wait for all handlers to complete</p> PARAMETER DESCRIPTION <code>message</code> <p> TYPE: <code>MessageType</code> </p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>async def dispatch(self, message: MessageType) -&gt; int:\n    \"\"\"Dispatch the message and wait for all handlers to complete\"\"\"\n    handlers = self.get_handlers(message)\n    if handlers:\n        await asyncio.gather(*[handler(message) for handler in handlers.values()])\n    return len(handlers or ())\n</code></pre>"},{"location":"reference/task/","title":"Task","text":"<p>A Task defines the implementation of a given operation, the inputs required and the scheduling metadata. Usually, a Task is not created directly, but rather through the use of the @task decorator.</p>"},{"location":"reference/task/#example","title":"Example","text":"<p>A task function is decorated vya the @task decorator and must accept the TaskRun object as its first and only argument.</p> <pre><code>from fluid.scheduler import task, TaskRun\n\n@task\ndef hello(ctx: TaskRun) -&gt; None:\n    print(\"Hello, world!\")\n</code></pre>"},{"location":"reference/task/#fluid.scheduler.task","title":"fluid.scheduler.task","text":"<pre><code>task(executor: TaskExecutor) -&gt; Task\n</code></pre><pre><code>task(\n    *,\n    name: str | None = None,\n    schedule: Scheduler | None = None,\n    short_description: str | None = None,\n    description: str | None = None,\n    randomize: RandomizeType | None = None,\n    max_concurrency: int = 0,\n    priority: TaskPriority = medium,\n    cpu_bound: bool = False,\n    timeout_seconds: int = 60\n) -&gt; TaskConstructor\n</code></pre> <pre><code>task(executor=None, **kwargs)\n</code></pre> <p>Decorator to create a Task</p> <p>This decorator can be used in two ways:</p> <ul> <li>As a simple decorator of the executor function</li> <li>As a function with keyword arguments</li> </ul> PARAMETER DESCRIPTION <code>executor</code> <p> TYPE: <code>TaskExecutor | None</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>fluid/scheduler/models.py</code> <pre><code>def task(executor: TaskExecutor | None = None, **kwargs: Any) -&gt; Task | TaskConstructor:\n    \"\"\"Decorator to create a Task\n\n    This decorator can be used in two ways:\n\n    - As a simple decorator of the executor function\n    - As a function with keyword arguments\n    \"\"\"\n    if kwargs and executor:\n        raise TaskDecoratorError(\"cannot use positional parameters\")\n    elif kwargs:\n        return TaskConstructor(**kwargs)\n    elif not executor:\n        raise TaskDecoratorError(\"this is a decorator cannot be invoked in this way\")\n    else:\n        return TaskConstructor()(executor)\n</code></pre>"},{"location":"reference/task/#fluid.scheduler.Task","title":"fluid.scheduler.Task","text":"<p>               Bases: <code>NamedTuple</code>, <code>Generic[TP]</code></p> <p>A Task executes any time it is invoked</p>"},{"location":"reference/task/#fluid.scheduler.Task.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name\n</code></pre> <p>Task name - unique identifier</p>"},{"location":"reference/task/#fluid.scheduler.Task.executor","title":"executor  <code>instance-attribute</code>","text":"<pre><code>executor\n</code></pre> <p>Task executor function</p>"},{"location":"reference/task/#fluid.scheduler.Task.params_model","title":"params_model  <code>instance-attribute</code>","text":"<pre><code>params_model\n</code></pre> <p>Pydantic model for task parameters</p>"},{"location":"reference/task/#fluid.scheduler.Task.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger\n</code></pre> <p>Task logger</p>"},{"location":"reference/task/#fluid.scheduler.Task.module","title":"module  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>module = ''\n</code></pre> <p>Task python module</p>"},{"location":"reference/task/#fluid.scheduler.Task.short_description","title":"short_description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>short_description = ''\n</code></pre> <p>Short task description - one line</p>"},{"location":"reference/task/#fluid.scheduler.Task.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description = ''\n</code></pre> <p>Task description - obtained from the executor docstring if not provided</p>"},{"location":"reference/task/#fluid.scheduler.Task.schedule","title":"schedule  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>schedule = None\n</code></pre> <p>Task schedule - None means the task is not scheduled</p>"},{"location":"reference/task/#fluid.scheduler.Task.randomize","title":"randomize  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>randomize = None\n</code></pre> <p>Randomize function for task schedule</p>"},{"location":"reference/task/#fluid.scheduler.Task.max_concurrency","title":"max_concurrency  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_concurrency = 0\n</code></pre> <p>how many tasks can run in each consumer concurrently - 0 means no limit</p>"},{"location":"reference/task/#fluid.scheduler.Task.timeout_seconds","title":"timeout_seconds  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timeout_seconds = 60\n</code></pre> <p>Task timeout in seconds - how long the task can run before being aborted</p>"},{"location":"reference/task/#fluid.scheduler.Task.priority","title":"priority  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>priority = medium\n</code></pre> <p>Task priority - high, medium, low</p>"},{"location":"reference/task/#fluid.scheduler.Task.cpu_bound","title":"cpu_bound  <code>property</code>","text":"<pre><code>cpu_bound\n</code></pre> <p>True if the task is CPU bound</p>"},{"location":"reference/task/#fluid.scheduler.Task.info","title":"info","text":"<pre><code>info(**params)\n</code></pre> PARAMETER DESCRIPTION <code>**params</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>fluid/scheduler/models.py</code> <pre><code>def info(self, **params: Any) -&gt; TaskInfo:\n    params.update(\n        name=self.name,\n        description=self.description,\n        module=self.module,\n        priority=self.priority,\n        schedule=str(self.schedule) if self.schedule else None,\n    )\n    return TaskInfo(**compact_dict(params))\n</code></pre>"},{"location":"reference/task/#fluid.scheduler.TaskPriority","title":"fluid.scheduler.TaskPriority","text":"<p>               Bases: <code>StrEnum</code></p>"},{"location":"reference/task/#fluid.scheduler.TaskPriority.high","title":"high  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>high = auto()\n</code></pre>"},{"location":"reference/task/#fluid.scheduler.TaskPriority.medium","title":"medium  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>medium = auto()\n</code></pre>"},{"location":"reference/task/#fluid.scheduler.TaskPriority.low","title":"low  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>low = auto()\n</code></pre>"},{"location":"reference/task/#fluid.scheduler.TaskState","title":"fluid.scheduler.TaskState","text":"<p>               Bases: <code>StrEnum</code></p>"},{"location":"reference/task/#fluid.scheduler.TaskState.init","title":"init  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>init = auto()\n</code></pre>"},{"location":"reference/task/#fluid.scheduler.TaskState.queued","title":"queued  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>queued = auto()\n</code></pre>"},{"location":"reference/task/#fluid.scheduler.TaskState.running","title":"running  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>running = auto()\n</code></pre>"},{"location":"reference/task/#fluid.scheduler.TaskState.success","title":"success  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>success = auto()\n</code></pre>"},{"location":"reference/task/#fluid.scheduler.TaskState.failure","title":"failure  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>failure = auto()\n</code></pre>"},{"location":"reference/task/#fluid.scheduler.TaskState.aborted","title":"aborted  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>aborted = auto()\n</code></pre>"},{"location":"reference/task/#fluid.scheduler.TaskState.rate_limited","title":"rate_limited  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rate_limited = auto()\n</code></pre>"},{"location":"reference/task/#fluid.scheduler.TaskState.is_failure","title":"is_failure  <code>property</code>","text":"<pre><code>is_failure\n</code></pre>"},{"location":"reference/task/#fluid.scheduler.TaskState.is_done","title":"is_done  <code>property</code>","text":"<pre><code>is_done\n</code></pre>"},{"location":"reference/task_broker/","title":"Task Broker","text":"<p>It can be imported from <code>fluid.scheduler</code>:</p> <pre><code>from fastapi.scheduler import TaskBroker\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker","title":"fluid.scheduler.TaskBroker","text":"<pre><code>TaskBroker(url)\n</code></pre> <p>               Bases: <code>ABC</code></p> PARAMETER DESCRIPTION <code>url</code> <p> TYPE: <code>URL</code> </p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>def __init__(self, url: URL) -&gt; None:\n    self.url: URL = url\n    self.registry: TaskRegistry = TaskRegistry()\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url = url\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.registry","title":"registry  <code>instance-attribute</code>","text":"<pre><code>registry = TaskRegistry()\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.task_queue_names","title":"task_queue_names  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>task_queue_names\n</code></pre> <p>Names of the task queues</p>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.queue_task","title":"queue_task  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>queue_task(task_run)\n</code></pre> <p>Queue a task</p> PARAMETER DESCRIPTION <code>task_run</code> <p> TYPE: <code>TaskRun</code> </p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>@abstractmethod\nasync def queue_task(self, task_run: TaskRun) -&gt; None:\n    \"\"\"Queue a task\"\"\"\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.get_task_run","title":"get_task_run  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get_task_run(task_manager)\n</code></pre> <p>Get a Task run from the task queue</p> PARAMETER DESCRIPTION <code>task_manager</code> <p> TYPE: <code>TaskManager</code> </p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>@abstractmethod\nasync def get_task_run(self, task_manager: TaskManager) -&gt; TaskRun | None:\n    \"\"\"Get a Task run from the task queue\"\"\"\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.queue_length","title":"queue_length  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>queue_length()\n</code></pre> <p>Length of task queues</p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>@abstractmethod\nasync def queue_length(self) -&gt; dict[str, int]:\n    \"\"\"Length of task queues\"\"\"\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.get_tasks_info","title":"get_tasks_info  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get_tasks_info(*task_names)\n</code></pre> <p>List of TaskInfo objects</p> PARAMETER DESCRIPTION <code>*task_names</code> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>@abstractmethod\nasync def get_tasks_info(self, *task_names: str) -&gt; list[TaskInfo]:\n    \"\"\"List of TaskInfo objects\"\"\"\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.update_task","title":"update_task  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>update_task(task, params)\n</code></pre> <p>Update a task dynamic parameters</p> PARAMETER DESCRIPTION <code>task</code> <p> TYPE: <code>Task</code> </p> <code>params</code> <p> TYPE: <code>dict[str, Any]</code> </p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>@abstractmethod\nasync def update_task(self, task: Task, params: dict[str, Any]) -&gt; TaskInfo:\n    \"\"\"Update a task dynamic parameters\"\"\"\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.close","title":"close  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Close the broker on shutdown</p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>@abstractmethod\nasync def close(self) -&gt; None:\n    \"\"\"Close the broker on shutdown\"\"\"\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.lock","title":"lock  <code>abstractmethod</code>","text":"<pre><code>lock(name, timeout=None)\n</code></pre> <p>Create a lock</p> PARAMETER DESCRIPTION <code>name</code> <p> TYPE: <code>str</code> </p> <code>timeout</code> <p> TYPE: <code>float | None</code> DEFAULT: <code>None</code> </p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>@abstractmethod\ndef lock(self, name: str, timeout: float | None = None) -&gt; Lock:\n    \"\"\"Create a lock\"\"\"\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.new_uuid","title":"new_uuid","text":"<pre><code>new_uuid()\n</code></pre> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>def new_uuid(self) -&gt; str:\n    return uuid4().hex\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.filter_tasks","title":"filter_tasks  <code>async</code>","text":"<pre><code>filter_tasks(scheduled=None, enabled=None)\n</code></pre> PARAMETER DESCRIPTION <code>scheduled</code> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> <code>enabled</code> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>async def filter_tasks(\n    self,\n    scheduled: bool | None = None,\n    enabled: bool | None = None,\n) -&gt; list[Task]:\n    task_info = await self.get_tasks_info()\n    task_map = {info.name: info for info in task_info}\n    tasks = []\n    for task in self.registry.values():\n        if scheduled is not None and bool(task.schedule) is not scheduled:\n            continue\n        if enabled is not None and task_map[task.name].enabled is not enabled:\n            continue\n        tasks.append(task)\n    return tasks\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.task_from_registry","title":"task_from_registry","text":"<pre><code>task_from_registry(task)\n</code></pre> PARAMETER DESCRIPTION <code>task</code> <p> TYPE: <code>str | Task</code> </p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>def task_from_registry(self, task: str | Task) -&gt; Task:\n    if isinstance(task, Task):\n        self.register_task(task)\n        return task\n    else:\n        if task_ := self.registry.get(task):\n            return task_\n        raise UnknownTaskError(task)\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.register_task","title":"register_task","text":"<pre><code>register_task(task)\n</code></pre> PARAMETER DESCRIPTION <code>task</code> <p> TYPE: <code>Task</code> </p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>def register_task(self, task: Task) -&gt; None:\n    self.registry[task.name] = task\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.enable_task","title":"enable_task  <code>async</code>","text":"<pre><code>enable_task(task, enable=True)\n</code></pre> <p>Enable or disable a registered task</p> PARAMETER DESCRIPTION <code>task</code> <p> TYPE: <code>str | Task</code> </p> <code>enable</code> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>async def enable_task(self, task: str | Task, enable: bool = True) -&gt; TaskInfo:\n    \"\"\"Enable or disable a registered task\"\"\"\n    task_ = self.task_from_registry(task)\n    return await self.update_task(task_, dict(enabled=enable))\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.from_url","title":"from_url  <code>classmethod</code>","text":"<pre><code>from_url(url='')\n</code></pre> PARAMETER DESCRIPTION <code>url</code> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>@classmethod\ndef from_url(cls, url: str = \"\") -&gt; TaskBroker:\n    p = URL(url or broker_url_from_env())\n    if factory := _brokers.get(p.scheme):\n        return factory(p)\n    raise RuntimeError(f\"Invalid broker {p}\")\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.register_broker","title":"register_broker  <code>classmethod</code>","text":"<pre><code>register_broker(name, factory)\n</code></pre> PARAMETER DESCRIPTION <code>name</code> <p> TYPE: <code>str</code> </p> <code>factory</code> <p> TYPE: <code>type[TaskBroker]</code> </p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>@classmethod\ndef register_broker(cls, name: str, factory: type[TaskBroker]) -&gt; None:\n    _brokers[name] = factory\n</code></pre>"},{"location":"reference/task_cli/","title":"Task Manager Cli","text":"<p>Command line tools for task manager applications.</p> <p>This modules requires the <code>cli</code> extra to be installed.</p> <p><pre><code>$ pip install aio-fluid[cli]\n</code></pre> It can be imported from <code>fluid.scheduler.cli</code>:</p> <pre><code>from fastapi.scheduler.cli import TaskManagerCLI\n\nif __name__ == \"__main__\":\n    cli = TaskManagerCLI(\"path.to:task_app\")\n    cli()\n</code></pre>"},{"location":"reference/task_cli/#fluid.scheduler.cli.TaskManagerCLI","title":"fluid.scheduler.cli.TaskManagerCLI","text":"<pre><code>TaskManagerCLI(task_manager_app, **kwargs)\n</code></pre> <p>               Bases: <code>LazyGroup</code></p> <p>CLI for TaskManager</p> <p>This class provides a CLI for a TaskManager Application.</p> <p>It requires to install the <code>cli</code> extra dependencies.</p> PARAMETER DESCRIPTION <code>task_manager_app</code> <p> TYPE: <code>TaskManagerApp</code> </p> <code>**kwargs</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>fluid/scheduler/cli.py</code> <pre><code>def __init__(\n    self,\n    task_manager_app: TaskManagerApp,\n    **kwargs: Any,\n):\n    kwargs.setdefault(\"commands\", DEFAULT_COMMANDS)\n    super().__init__(**kwargs)\n    self.task_manager_app = task_manager_app\n</code></pre>"},{"location":"reference/task_cli/#fluid.scheduler.cli.TaskManagerCLI.lazy_subcommands","title":"lazy_subcommands  <code>instance-attribute</code>","text":"<pre><code>lazy_subcommands = lazy_subcommands or {}\n</code></pre>"},{"location":"reference/task_cli/#fluid.scheduler.cli.TaskManagerCLI.task_manager_app","title":"task_manager_app  <code>instance-attribute</code>","text":"<pre><code>task_manager_app = task_manager_app\n</code></pre>"},{"location":"reference/task_cli/#fluid.scheduler.cli.TaskManagerCLI.list_commands","title":"list_commands","text":"<pre><code>list_commands(ctx)\n</code></pre> PARAMETER DESCRIPTION <code>ctx</code> <p> TYPE: <code>Context</code> </p> Source code in <code>fluid/utils/lazy.py</code> <pre><code>def list_commands(self, ctx: click.Context) -&gt; list[str]:\n    commands = super().list_commands(ctx)\n    commands.extend(self.lazy_subcommands)\n    return sorted(commands)\n</code></pre>"},{"location":"reference/task_cli/#fluid.scheduler.cli.TaskManagerCLI.get_command","title":"get_command","text":"<pre><code>get_command(ctx, cmd_name)\n</code></pre> PARAMETER DESCRIPTION <code>ctx</code> <p> TYPE: <code>Context</code> </p> <code>cmd_name</code> <p> TYPE: <code>str</code> </p> Source code in <code>fluid/utils/lazy.py</code> <pre><code>def get_command(self, ctx: click.Context, cmd_name: str) -&gt; click.Command | None:\n    if cmd_name in self.lazy_subcommands:\n        return self._lazy_load(cmd_name)\n    return super().get_command(ctx, cmd_name)\n</code></pre>"},{"location":"reference/task_manager/","title":"Task Manager","text":"<p>It can be imported from <code>fluid.scheduler</code>:</p> <pre><code>from fastapi.scheduler import TaskManager\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager","title":"fluid.scheduler.TaskManager","text":"<pre><code>TaskManager(*, deps=None, config=None, **kwargs)\n</code></pre> <p>The task manager is the main class for managing tasks</p> PARAMETER DESCRIPTION <code>deps</code> <p> TYPE: <code>Any</code> DEFAULT: <code>None</code> </p> <code>config</code> <p> TYPE: <code>TaskManagerConfig | None</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def __init__(\n    self,\n    *,\n    deps: Any = None,\n    config: TaskManagerConfig | None = None,\n    **kwargs: Any,\n) -&gt; None:\n    self.deps: Annotated[\n        Any,\n        Doc(\n            \"\"\"\n            Dependencies for the task manager.\n\n            Production applications requires global dependencies to be\n            available to all tasks. This can be achieved by setting\n            the `deps` attribute of the task manager to an object\n            with the required dependencies.\n\n            Each task can cast the dependencies to the required type.\n            \"\"\"\n        ),\n    ] = (\n        deps if deps is not None else State()\n    )\n    self.config: Annotated[\n        TaskManagerConfig, Doc(\"\"\"Task manager configuration\"\"\")\n    ] = config or TaskManagerConfig(**kwargs)\n    self.dispatcher: Annotated[\n        TaskDispatcher,\n        Doc(\n            \"\"\"\n            A dispatcher of [TaskRun][fluid.scheduler.TaskRun] events.\n\n            Application can register handlers to listen for events\n            happening during the lifecycle of a task run.\n            \"\"\"\n        ),\n    ] = TaskDispatcher()\n    self.broker = TaskBroker.from_url(self.config.broker_url)\n    self._stack = AsyncExitStack()\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.deps","title":"deps  <code>instance-attribute</code>","text":"<pre><code>deps = deps if deps is not None else State()\n</code></pre> <p>Dependencies for the task manager.</p> <p>Production applications requires global dependencies to be available to all tasks. This can be achieved by setting the <code>deps</code> attribute of the task manager to an object with the required dependencies.</p> <p>Each task can cast the dependencies to the required type.</p>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config = config or TaskManagerConfig(**kwargs)\n</code></pre> <p>Task manager configuration</p>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.dispatcher","title":"dispatcher  <code>instance-attribute</code>","text":"<pre><code>dispatcher = TaskDispatcher()\n</code></pre> <p>A dispatcher of TaskRun events.</p> <p>Application can register handlers to listen for events happening during the lifecycle of a task run.</p>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.broker","title":"broker  <code>instance-attribute</code>","text":"<pre><code>broker = from_url(broker_url)\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.registry","title":"registry  <code>property</code>","text":"<pre><code>registry\n</code></pre> <p>The task registry</p>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.type","title":"type  <code>property</code>","text":"<pre><code>type\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.enter_async_context","title":"enter_async_context  <code>async</code>","text":"<pre><code>enter_async_context(cm)\n</code></pre> PARAMETER DESCRIPTION <code>cm</code> <p> TYPE: <code>Any</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>async def enter_async_context(self, cm: Any) -&gt; Any:\n    return await self._stack.enter_async_context(cm)\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.execute","title":"execute  <code>async</code>","text":"<pre><code>execute(task, **params)\n</code></pre> <p>Execute a task and wait for it to finish</p> PARAMETER DESCRIPTION <code>task</code> <p> TYPE: <code>Task | str</code> </p> <code>**params</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>async def execute(self, task: Task | str, **params: Any) -&gt; TaskRun:\n    \"\"\"Execute a task and wait for it to finish\"\"\"\n    task_run = self.create_task_run(task, **params)\n    await task_run.execute()\n    return task_run\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.on_shutdown","title":"on_shutdown  <code>async</code>","text":"<pre><code>on_shutdown()\n</code></pre> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>async def on_shutdown(self) -&gt; None:\n    await self.broker.close()\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.execute_sync","title":"execute_sync","text":"<pre><code>execute_sync(task, **params)\n</code></pre> PARAMETER DESCRIPTION <code>task</code> <p> TYPE: <code>Task | str</code> </p> <code>**params</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def execute_sync(self, task: Task | str, **params: Any) -&gt; TaskRun:\n    return asyncio.run(self._execute_and_exit(task, **params))\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.register_task","title":"register_task","text":"<pre><code>register_task(task)\n</code></pre> <p>Register a task with the task manager</p> <p>Only tasks registered can be executed by a task manager</p> PARAMETER DESCRIPTION <code>task</code> <p> TYPE: <code>Task</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def register_task(self, task: Task) -&gt; None:\n    \"\"\"Register a task with the task manager\n\n    Only tasks registered can be executed by a task manager\n    \"\"\"\n    self.broker.register_task(task)\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.queue","title":"queue  <code>async</code>","text":"<pre><code>queue(task, priority=None, **params)\n</code></pre> <p>Queue a task for execution</p> <p>This methods fires two events:</p> <ul> <li>init: when the task run is created</li> <li>queued: after the task is queued</li> </ul> PARAMETER DESCRIPTION <code>task</code> <p> TYPE: <code>str | Task</code> </p> <code>priority</code> <p> TYPE: <code>TaskPriority | None</code> DEFAULT: <code>None</code> </p> <code>**params</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>async def queue(\n    self,\n    task: str | Task,\n    priority: TaskPriority | None = None,\n    **params: Any,\n) -&gt; TaskRun:\n    \"\"\"Queue a task for execution\n\n    This methods fires two events:\n\n    - init: when the task run is created\n    - queued: after the task is queued\n    \"\"\"\n    task_run = self.create_task_run(task, priority=priority, **params)\n    self.dispatcher.dispatch(task_run)\n    task_run.set_state(TaskState.queued)\n    await self.broker.queue_task(task_run)\n    return task_run\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.create_task_run","title":"create_task_run","text":"<pre><code>create_task_run(task, run_id='', priority=None, **params)\n</code></pre> <p>Create a TaskRun in <code>init</code> state</p> PARAMETER DESCRIPTION <code>task</code> <p> TYPE: <code>str | Task</code> </p> <code>run_id</code> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>priority</code> <p> TYPE: <code>TaskPriority | None</code> DEFAULT: <code>None</code> </p> <code>**params</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def create_task_run(\n    self,\n    task: str | Task,\n    run_id: str = \"\",\n    priority: TaskPriority | None = None,\n    **params: Any,\n) -&gt; TaskRun:\n    \"\"\"Create a TaskRun in `init` state\"\"\"\n    task = self.broker.task_from_registry(task)\n    run_id = run_id or self.broker.new_uuid()\n    return TaskRun(\n        id=run_id,\n        task=task,\n        priority=priority or task.priority,\n        params=task.params_model(**params),\n        task_manager=self,\n    )\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.register_from_module","title":"register_from_module","text":"<pre><code>register_from_module(module)\n</code></pre> PARAMETER DESCRIPTION <code>module</code> <p> TYPE: <code>Any</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def register_from_module(self, module: Any) -&gt; None:\n    for name in dir(module):\n        if name.startswith(\"_\"):\n            continue\n        if isinstance(obj := getattr(module, name), Task):\n            self.register_task(obj)\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.register_from_dict","title":"register_from_dict","text":"<pre><code>register_from_dict(data)\n</code></pre> PARAMETER DESCRIPTION <code>data</code> <p> TYPE: <code>dict</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def register_from_dict(self, data: dict) -&gt; None:\n    for name, obj in data.items():\n        if name.startswith(\"_\"):\n            continue\n        if isinstance(obj, Task):\n            self.register_task(obj)\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.register_async_handler","title":"register_async_handler","text":"<pre><code>register_async_handler(event, handler)\n</code></pre> <p>Register an async handler for a given event</p> <p>This method is a no op for a TaskManager that is not a worker</p> PARAMETER DESCRIPTION <code>event</code> <p> TYPE: <code>str</code> </p> <code>handler</code> <p> TYPE: <code>AsyncHandler</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def register_async_handler(self, event: str, handler: AsyncHandler) -&gt; None:\n    \"\"\"Register an async handler for a given event\n\n    This method is a no op for a TaskManager that is not a worker\n    \"\"\"\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.unregister_async_handler","title":"unregister_async_handler","text":"<pre><code>unregister_async_handler(event)\n</code></pre> <p>Unregister an async handler for a given event</p> <p>This method is a no op for a TaskManager that is not a worker</p> PARAMETER DESCRIPTION <code>event</code> <p> TYPE: <code>Event | str</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def unregister_async_handler(self, event: Event | str) -&gt; AsyncHandler | None:\n    \"\"\"Unregister an async handler for a given event\n\n    This method is a no op for a TaskManager that is not a worker\n    \"\"\"\n    return None\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManagerConfig","title":"fluid.scheduler.TaskManagerConfig  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Task manager configuration</p> <p>Fields:</p> <ul> <li> <code>schedule_tasks</code>                 (<code>bool</code>)             </li> <li> <code>consume_tasks</code>                 (<code>bool</code>)             </li> <li> <code>max_concurrent_tasks</code>                 (<code>int</code>)             </li> <li> <code>sleep</code>                 (<code>float</code>)             </li> <li> <code>broker_url</code>                 (<code>str</code>)             </li> </ul>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManagerConfig.schedule_tasks","title":"schedule_tasks  <code>pydantic-field</code>","text":"<pre><code>schedule_tasks = True\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManagerConfig.consume_tasks","title":"consume_tasks  <code>pydantic-field</code>","text":"<pre><code>consume_tasks = True\n</code></pre> <p>Consume tasks or sleep</p>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManagerConfig.max_concurrent_tasks","title":"max_concurrent_tasks  <code>pydantic-field</code>","text":"<pre><code>max_concurrent_tasks = MAX_CONCURRENT_TASKS\n</code></pre> <p>The number of coroutine workers consuming tasks. Each worker consumes one task at a time, therefore, this number is the maximum number of tasks that can run concurrently.It can be configured via the <code>FLUID_MAX_CONCURRENT_TASKS</code> environment variable, and by default is set to 5.</p>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManagerConfig.sleep","title":"sleep  <code>pydantic-field</code>","text":"<pre><code>sleep = 0.1\n</code></pre> <p>amount to async sleep after completion of a task</p>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManagerConfig.broker_url","title":"broker_url  <code>pydantic-field</code>","text":"<pre><code>broker_url = ''\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.consumer.TaskDispatcher","title":"fluid.scheduler.consumer.TaskDispatcher","text":"<pre><code>TaskDispatcher()\n</code></pre> <p>               Bases: <code>Dispatcher[TaskRun]</code></p> <p>The task dispatcher is responsible for dispatching task run messages</p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._msg_handlers: defaultdict[str, dict[str, MessageHandlerType]] = (\n        defaultdict(\n            dict,\n        )\n    )\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.consumer.TaskDispatcher.register_handler","title":"register_handler","text":"<pre><code>register_handler(event, handler)\n</code></pre> PARAMETER DESCRIPTION <code>event</code> <p> TYPE: <code>Event | str</code> </p> <code>handler</code> <p> TYPE: <code>MessageHandlerType</code> </p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def register_handler(\n    self,\n    event: Event | str,\n    handler: MessageHandlerType,\n) -&gt; MessageHandlerType | None:\n    event = Event.from_string_or_event(event)\n    previous = self._msg_handlers[event.type].get(event.tag)\n    self._msg_handlers[event.type][event.tag] = handler\n    return previous\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.consumer.TaskDispatcher.unregister_handler","title":"unregister_handler","text":"<pre><code>unregister_handler(event)\n</code></pre> PARAMETER DESCRIPTION <code>event</code> <p> TYPE: <code>Event | str</code> </p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def unregister_handler(self, event: Event | str) -&gt; MessageHandlerType | None:\n    event = Event.from_string_or_event(event)\n    return self._msg_handlers[event.type].pop(event.tag, None)\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.consumer.TaskDispatcher.get_handlers","title":"get_handlers","text":"<pre><code>get_handlers(message)\n</code></pre> PARAMETER DESCRIPTION <code>message</code> <p> TYPE: <code>MessageType</code> </p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def get_handlers(\n    self,\n    message: MessageType,\n) -&gt; dict[str, MessageHandlerType] | None:\n    message_type = str(self.message_type(message))\n    return self._msg_handlers.get(message_type)\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.consumer.TaskDispatcher.dispatch","title":"dispatch","text":"<pre><code>dispatch(message)\n</code></pre> <p>dispatch the message</p> PARAMETER DESCRIPTION <code>message</code> <p> TYPE: <code>MessageType</code> </p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def dispatch(self, message: MessageType) -&gt; int:\n    \"\"\"dispatch the message\"\"\"\n    handlers = self.get_handlers(message)\n    if handlers:\n        for handler in handlers.values():\n            handler(message)\n    return len(handlers or ())\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.consumer.TaskDispatcher.message_type","title":"message_type","text":"<pre><code>message_type(message)\n</code></pre> PARAMETER DESCRIPTION <code>message</code> <p> TYPE: <code>TaskRun</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def message_type(self, message: TaskRun) -&gt; str:\n    return message.state\n</code></pre>"},{"location":"reference/task_registry/","title":"Task Registry","text":""},{"location":"reference/task_registry/#fluid.scheduler.broker.TaskRegistry","title":"fluid.scheduler.broker.TaskRegistry","text":"<p>               Bases: <code>dict[str, Task[TP]]</code></p> <p>A registry of tasks</p>"},{"location":"reference/task_registry/#fluid.scheduler.broker.TaskRegistry.periodic","title":"periodic","text":"<pre><code>periodic()\n</code></pre> <p>Iterate over periodic tasks</p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>def periodic(self) -&gt; Iterable[Task]:\n    \"\"\"Iterate over periodic tasks\"\"\"\n    for task in self.values():\n        yield task\n</code></pre>"},{"location":"reference/task_run/","title":"Task Run","text":"<p>It can be imported from <code>fluid.scheduler</code>:</p> <pre><code>from fastapi.scheduler import TaskRun\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun","title":"fluid.scheduler.TaskRun  <code>pydantic-model</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[TP]</code></p> <p>A TaskRun contains all the data generated by a Task run</p> <p>This model is never initialized directly, it is created by the TaskManager</p> <p>Fields:</p> <ul> <li> <code>id</code>                 (<code>str</code>)             </li> <li> <code>task</code>                 (<code>Task</code>)             </li> <li> <code>priority</code>                 (<code>TaskPriority</code>)             </li> <li> <code>params</code>                 (<code>TP</code>)             </li> <li> <code>state</code>                 (<code>TaskState</code>)             </li> <li> <code>task_manager</code>                 (<code>TaskManager</code>)             </li> <li> <code>queued</code>                 (<code>datetime | None</code>)             </li> <li> <code>start</code>                 (<code>datetime | None</code>)             </li> <li> <code>end</code>                 (<code>datetime | None</code>)             </li> <li> <code>logger</code>                 (<code>Logger</code>)             </li> <li> <code>in_queue</code>                 (<code>timedelta | None</code>)             </li> <li> <code>duration</code>                 (<code>timedelta | None</code>)             </li> <li> <code>duration_ms</code>                 (<code>float | None</code>)             </li> <li> <code>total</code>                 (<code>timedelta | None</code>)             </li> <li> <code>name</code>                 (<code>str</code>)             </li> <li> <code>name_id</code>                 (<code>str</code>)             </li> <li> <code>is_done</code>                 (<code>bool</code>)             </li> <li> <code>is_failure</code>                 (<code>bool</code>)             </li> <li> <code>deps</code>                 (<code>Any</code>)             </li> </ul>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.id","title":"id  <code>pydantic-field</code>","text":"<pre><code>id\n</code></pre> <p>Unique task run id</p>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.task","title":"task  <code>pydantic-field</code>","text":"<pre><code>task\n</code></pre> <p>Task to be executed</p>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.priority","title":"priority  <code>pydantic-field</code>","text":"<pre><code>priority\n</code></pre> <p>Task priority</p>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.params","title":"params  <code>pydantic-field</code>","text":"<pre><code>params\n</code></pre> <p>Task parameters</p>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.state","title":"state  <code>pydantic-field</code>","text":"<pre><code>state = init\n</code></pre> <p>Task state</p>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.task_manager","title":"task_manager  <code>pydantic-field</code>","text":"<pre><code>task_manager\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.queued","title":"queued  <code>pydantic-field</code>","text":"<pre><code>queued = None\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.start","title":"start  <code>pydantic-field</code>","text":"<pre><code>start = None\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.end","title":"end  <code>pydantic-field</code>","text":"<pre><code>end = None\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.logger","title":"logger  <code>pydantic-field</code>","text":"<pre><code>logger\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.in_queue","title":"in_queue  <code>pydantic-field</code>","text":"<pre><code>in_queue\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.duration","title":"duration  <code>pydantic-field</code>","text":"<pre><code>duration\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.duration_ms","title":"duration_ms  <code>pydantic-field</code>","text":"<pre><code>duration_ms\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.total","title":"total  <code>pydantic-field</code>","text":"<pre><code>total\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.name","title":"name  <code>pydantic-field</code>","text":"<pre><code>name\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.name_id","title":"name_id  <code>pydantic-field</code>","text":"<pre><code>name_id\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.is_done","title":"is_done  <code>pydantic-field</code>","text":"<pre><code>is_done\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.is_failure","title":"is_failure  <code>pydantic-field</code>","text":"<pre><code>is_failure\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.deps","title":"deps  <code>pydantic-field</code>","text":"<pre><code>deps\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.execute","title":"execute  <code>async</code>","text":"<pre><code>execute()\n</code></pre> Source code in <code>fluid/scheduler/models.py</code> <pre><code>async def execute(self) -&gt; None:\n    try:\n        self.set_state(TaskState.running)\n        await self.task.executor(self)  # type: ignore [arg-type]\n    except Exception:\n        self.set_state(TaskState.failure)\n        raise\n    else:\n        self.set_state(TaskState.success)\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.serialize_task","title":"serialize_task","text":"<pre><code>serialize_task(task, _info)\n</code></pre> PARAMETER DESCRIPTION <code>task</code> <p> TYPE: <code>Task</code> </p> <code>_info</code> <p> TYPE: <code>Any</code> </p> Source code in <code>fluid/scheduler/models.py</code> <pre><code>@field_serializer(\"task\")\ndef serialize_task(self, task: Task, _info: Any) -&gt; str:\n    return task.name\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.set_state","title":"set_state","text":"<pre><code>set_state(state, state_time=None)\n</code></pre> PARAMETER DESCRIPTION <code>state</code> <p> TYPE: <code>TaskState</code> </p> <code>state_time</code> <p> TYPE: <code>datetime | None</code> DEFAULT: <code>None</code> </p> Source code in <code>fluid/scheduler/models.py</code> <pre><code>def set_state(\n    self,\n    state: TaskState,\n    state_time: datetime | None = None,\n) -&gt; None:\n    if self.state == state:\n        return\n    state_time = as_utc(state_time)\n    match (self.state, state):\n        case (TaskState.init, TaskState.queued):\n            self.queued = state_time\n            self.state = state\n            self._dispatch()\n        case (TaskState.init, _):\n            self.set_state(TaskState.queued, state_time)\n            self.set_state(state, state_time)\n        case (TaskState.queued, TaskState.running):\n            self.start = state_time\n            self.state = state\n            self._dispatch()\n        case (\n            TaskState.queued,\n            TaskState.success\n            | TaskState.aborted\n            | TaskState.rate_limited\n            | TaskState.failure,\n        ):\n            self.set_state(TaskState.running, state_time)\n            self.set_state(state, state_time)\n        case (\n            TaskState.running,\n            TaskState.success\n            | TaskState.aborted\n            | TaskState.rate_limited\n            | TaskState.failure,\n        ):\n            self.end = state_time\n            self.state = state\n            self._dispatch()\n        case _:\n            raise TaskRunError(f\"invalid state transition {self.state} -&gt; {state}\")\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.lock","title":"lock","text":"<pre><code>lock(timeout)\n</code></pre> PARAMETER DESCRIPTION <code>timeout</code> <p> TYPE: <code>float | None</code> </p> Source code in <code>fluid/scheduler/models.py</code> <pre><code>def lock(self, timeout: float | None) -&gt; Lock:\n    return self.task_manager.broker.lock(self.name, timeout=timeout)\n</code></pre>"},{"location":"reference/task_scheduler/","title":"Task Scheduler","text":"<p>The task scheduler TaskScheduler inherits from the TaskConsumer to add scheduling of periodic tasks.</p> <p>It can be imported from <code>fluid.scheduler</code>:</p> <pre><code>from fastapi.scheduler import TaskScheduler\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler","title":"fluid.scheduler.TaskScheduler","text":"<pre><code>TaskScheduler(**kwargs)\n</code></pre> <p>               Bases: <code>TaskConsumer</code></p> <p>A task manager for scheduling tasks</p> PARAMETER DESCRIPTION <code>**kwargs</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>fluid/scheduler/scheduler.py</code> <pre><code>def __init__(self, **kwargs: Any) -&gt; None:\n    super().__init__(**kwargs)\n    self.add_workers(ScheduleTasks(self))\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.worker_name","title":"worker_name  <code>property</code>","text":"<pre><code>worker_name\n</code></pre> <p>The name of the worker</p>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.num_workers","title":"num_workers  <code>property</code>","text":"<pre><code>num_workers\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.running","title":"running  <code>property</code>","text":"<pre><code>running\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.deps","title":"deps  <code>instance-attribute</code>","text":"<pre><code>deps = deps if deps is not None else State()\n</code></pre> <p>Dependencies for the task manager.</p> <p>Production applications requires global dependencies to be available to all tasks. This can be achieved by setting the <code>deps</code> attribute of the task manager to an object with the required dependencies.</p> <p>Each task can cast the dependencies to the required type.</p>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config = config or TaskManagerConfig(**kwargs)\n</code></pre> <p>Task manager configuration</p>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.dispatcher","title":"dispatcher  <code>instance-attribute</code>","text":"<pre><code>dispatcher = TaskDispatcher()\n</code></pre> <p>A dispatcher of TaskRun events.</p> <p>Application can register handlers to listen for events happening during the lifecycle of a task run.</p>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.broker","title":"broker  <code>instance-attribute</code>","text":"<pre><code>broker = from_url(broker_url)\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.registry","title":"registry  <code>property</code>","text":"<pre><code>registry\n</code></pre> <p>The task registry</p>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.type","title":"type  <code>property</code>","text":"<pre><code>type\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.num_concurrent_tasks","title":"num_concurrent_tasks  <code>property</code>","text":"<pre><code>num_concurrent_tasks\n</code></pre> <p>The number of concurrent_tasks running in the consumer</p>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.status","title":"status  <code>async</code>","text":"<pre><code>status()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def status(self) -&gt; dict:\n    return await self._workers.status()\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.gracefully_stop","title":"gracefully_stop","text":"<pre><code>gracefully_stop()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def gracefully_stop(self) -&gt; None:\n    self._workers.gracefully_stop()\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.is_running","title":"is_running","text":"<pre><code>is_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_running(self) -&gt; bool:\n    return self._running\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.is_stopping","title":"is_stopping","text":"<pre><code>is_stopping()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_stopping(self) -&gt; bool:\n    return self._workers.is_stopping()\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.run","title":"run  <code>async</code>","text":"<pre><code>run()\n</code></pre> <p>run the workers</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def run(self) -&gt; None:\n    \"\"\"run the workers\"\"\"\n    with self.start_running():\n        async with self.safe_run():\n            workers, _ = self._workers.workers_tasks()\n            self._workers.workers = tuple(workers)\n            self._workers.tasks = tuple(\n                self.create_task(worker) for worker in workers\n            )\n            await asyncio.gather(*self._workers.tasks)\n        await self.shutdown()\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.start_running","title":"start_running","text":"<pre><code>start_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>@contextmanager\ndef start_running(self) -&gt; Generator:\n    if self._running:\n        raise RuntimeError(\"Worker is already running\")\n    self._running = True\n    try:\n        logger.info(\"%s started running\", self.worker_name)\n        yield\n    finally:\n        self._running = False\n        logger.warning(\"%s stopped running\", self.worker_name)\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.add_workers","title":"add_workers","text":"<pre><code>add_workers(*workers)\n</code></pre> <p>add workers to the workers</p> PARAMETER DESCRIPTION <code>*workers</code> <p> TYPE: <code>Worker</code> DEFAULT: <code>()</code> </p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def add_workers(self, *workers: Worker) -&gt; None:\n    \"\"\"add workers to the workers\"\"\"\n    workers_, _ = self._workers.workers_tasks()\n    for worker in workers:\n        if worker not in workers_:\n            workers_.append(worker)\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.wait_for_exit","title":"wait_for_exit  <code>async</code>","text":"<pre><code>wait_for_exit()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def wait_for_exit(self) -&gt; None:\n    if self._workers_task is not None:\n        await self._workers_task\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.create_task","title":"create_task","text":"<pre><code>create_task(worker)\n</code></pre> PARAMETER DESCRIPTION <code>worker</code> <p> TYPE: <code>Worker</code> </p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def create_task(self, worker: Worker) -&gt; asyncio.Task:\n    return asyncio.create_task(\n        self._run_worker(worker), name=f\"{self.worker_name}-{worker.worker_name}\"\n    )\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.on_shutdown","title":"on_shutdown  <code>async</code>","text":"<pre><code>on_shutdown()\n</code></pre> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>async def on_shutdown(self) -&gt; None:\n    await self.broker.close()\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.shutdown","title":"shutdown  <code>async</code>","text":"<pre><code>shutdown()\n</code></pre> <p>shutdown the workers</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def shutdown(self) -&gt; None:\n    \"\"\"shutdown the workers\"\"\"\n    if self._has_shutdown:\n        return\n    self._has_shutdown = True\n    logger.warning(\n        \"gracefully stopping %d workers: %s\",\n        self.num_workers,\n        \", \".join(w.worker_name for w in self._workers.workers),\n    )\n    self.gracefully_stop()\n    try:\n        async with asyncio.timeout(self._stopping_grace_period):\n            await self.wait_for_exit()\n        await self.on_shutdown()\n        return\n    except asyncio.TimeoutError:\n        logger.warning(\n            \"could not stop workers %s gracefully after %s\"\n            \" seconds - force shutdown\",\n            \", \".join(\n                task.get_name() for task in self._workers.tasks if not task.done()\n            ),\n            self._stopping_grace_period,\n        )\n    except asyncio.CancelledError:\n        pass\n    self._force_shutdown = True\n    self._workers.cancel()\n    try:\n        await self.wait_for_exit()\n    except asyncio.CancelledError:\n        pass\n    await self.on_shutdown()\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.bail_out","title":"bail_out","text":"<pre><code>bail_out(reason, code=1)\n</code></pre> PARAMETER DESCRIPTION <code>reason</code> <p> TYPE: <code>str</code> </p> <code>code</code> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def bail_out(self, reason: str, code: int = 1) -&gt; None:\n    self.gracefully_stop()\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.safe_run","title":"safe_run  <code>async</code>","text":"<pre><code>safe_run()\n</code></pre> <p>Context manager to run a worker safely</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>@asynccontextmanager\nasync def safe_run(self) -&gt; AsyncGenerator:\n    \"\"\"Context manager to run a worker safely\"\"\"\n    try:\n        yield\n    except asyncio.CancelledError:\n        if self._force_shutdown:\n            # we are shutting down, this is expected\n            pass\n        raise\n    except Exception as e:\n        reason = f\"unhandled exception while running workers: {e}\"\n        logger.exception(reason)\n        asyncio.get_event_loop().call_soon(self.bail_out, reason, 2)\n    else:\n        # worker finished without error\n        # make sure we are shutting down\n        asyncio.get_event_loop().call_soon(self.bail_out, \"worker exit\", 1)\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.remove_workers","title":"remove_workers","text":"<pre><code>remove_workers(*workers)\n</code></pre> <p>remove workers from the workers</p> PARAMETER DESCRIPTION <code>*workers</code> <p> TYPE: <code>Worker</code> DEFAULT: <code>()</code> </p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def remove_workers(self, *workers: Worker) -&gt; None:\n    \"remove workers from the workers\"\n    workers_, _ = self._workers.workers_tasks()\n    for worker in workers:\n        try:\n            workers_.remove(worker)\n        except ValueError:\n            pass\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.startup","title":"startup  <code>async</code>","text":"<pre><code>startup()\n</code></pre> <p>start the workers</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def startup(self) -&gt; None:\n    \"\"\"start the workers\"\"\"\n    if self._workers_task is None:\n        self._workers_task = asyncio.create_task(self.run(), name=self.worker_name)\n        for args in self._delayed_callbacks:\n            self._delayed_callback(*args)\n        self._delayed_callbacks = []\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.register_callback","title":"register_callback","text":"<pre><code>register_callback(\n    callback, seconds, jitter=0.0, periodic=False\n)\n</code></pre> <p>Register a callback</p> <p>The callback can be periodic or not.</p> PARAMETER DESCRIPTION <code>callback</code> <p> TYPE: <code>Callable[[], None]</code> </p> <code>seconds</code> <p> TYPE: <code>float</code> </p> <code>jitter</code> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> <code>periodic</code> <p> TYPE: <code>bool | float</code> DEFAULT: <code>False</code> </p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def register_callback(\n    self,\n    callback: Callable[[], None],\n    seconds: float,\n    jitter: float = 0.0,\n    periodic: bool | float = False,\n) -&gt; None:\n    \"\"\"Register a callback\n\n    The callback can be periodic or not.\n    \"\"\"\n    if periodic is True:\n        periodic_float = seconds\n    elif periodic is False:\n        periodic_float = 0.0\n    else:\n        periodic_float = periodic\n    if not self.running:\n        self._delayed_callbacks.append((callback, seconds, jitter, periodic_float))\n    else:\n        self._delayed_callback(callback, seconds, jitter, periodic_float)\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.enter_async_context","title":"enter_async_context  <code>async</code>","text":"<pre><code>enter_async_context(cm)\n</code></pre> PARAMETER DESCRIPTION <code>cm</code> <p> TYPE: <code>Any</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>async def enter_async_context(self, cm: Any) -&gt; Any:\n    return await self._stack.enter_async_context(cm)\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.execute","title":"execute  <code>async</code>","text":"<pre><code>execute(task, **params)\n</code></pre> <p>Execute a task and wait for it to finish</p> PARAMETER DESCRIPTION <code>task</code> <p> TYPE: <code>Task | str</code> </p> <code>**params</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>async def execute(self, task: Task | str, **params: Any) -&gt; TaskRun:\n    \"\"\"Execute a task and wait for it to finish\"\"\"\n    task_run = self.create_task_run(task, **params)\n    await task_run.execute()\n    return task_run\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.execute_sync","title":"execute_sync","text":"<pre><code>execute_sync(task, **params)\n</code></pre> PARAMETER DESCRIPTION <code>task</code> <p> TYPE: <code>Task | str</code> </p> <code>**params</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def execute_sync(self, task: Task | str, **params: Any) -&gt; TaskRun:\n    return asyncio.run(self._execute_and_exit(task, **params))\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.register_task","title":"register_task","text":"<pre><code>register_task(task)\n</code></pre> <p>Register a task with the task manager</p> <p>Only tasks registered can be executed by a task manager</p> PARAMETER DESCRIPTION <code>task</code> <p> TYPE: <code>Task</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def register_task(self, task: Task) -&gt; None:\n    \"\"\"Register a task with the task manager\n\n    Only tasks registered can be executed by a task manager\n    \"\"\"\n    self.broker.register_task(task)\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.queue","title":"queue  <code>async</code>","text":"<pre><code>queue(task, priority=None, **params)\n</code></pre> <p>Queue a task for execution</p> <p>This methods fires two events:</p> <ul> <li>init: when the task run is created</li> <li>queued: after the task is queued</li> </ul> PARAMETER DESCRIPTION <code>task</code> <p> TYPE: <code>str | Task</code> </p> <code>priority</code> <p> TYPE: <code>TaskPriority | None</code> DEFAULT: <code>None</code> </p> <code>**params</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>async def queue(\n    self,\n    task: str | Task,\n    priority: TaskPriority | None = None,\n    **params: Any,\n) -&gt; TaskRun:\n    \"\"\"Queue a task for execution\n\n    This methods fires two events:\n\n    - init: when the task run is created\n    - queued: after the task is queued\n    \"\"\"\n    task_run = self.create_task_run(task, priority=priority, **params)\n    self.dispatcher.dispatch(task_run)\n    task_run.set_state(TaskState.queued)\n    await self.broker.queue_task(task_run)\n    return task_run\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.create_task_run","title":"create_task_run","text":"<pre><code>create_task_run(task, run_id='', priority=None, **params)\n</code></pre> <p>Create a TaskRun in <code>init</code> state</p> PARAMETER DESCRIPTION <code>task</code> <p> TYPE: <code>str | Task</code> </p> <code>run_id</code> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>priority</code> <p> TYPE: <code>TaskPriority | None</code> DEFAULT: <code>None</code> </p> <code>**params</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def create_task_run(\n    self,\n    task: str | Task,\n    run_id: str = \"\",\n    priority: TaskPriority | None = None,\n    **params: Any,\n) -&gt; TaskRun:\n    \"\"\"Create a TaskRun in `init` state\"\"\"\n    task = self.broker.task_from_registry(task)\n    run_id = run_id or self.broker.new_uuid()\n    return TaskRun(\n        id=run_id,\n        task=task,\n        priority=priority or task.priority,\n        params=task.params_model(**params),\n        task_manager=self,\n    )\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.register_from_module","title":"register_from_module","text":"<pre><code>register_from_module(module)\n</code></pre> PARAMETER DESCRIPTION <code>module</code> <p> TYPE: <code>Any</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def register_from_module(self, module: Any) -&gt; None:\n    for name in dir(module):\n        if name.startswith(\"_\"):\n            continue\n        if isinstance(obj := getattr(module, name), Task):\n            self.register_task(obj)\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.register_from_dict","title":"register_from_dict","text":"<pre><code>register_from_dict(data)\n</code></pre> PARAMETER DESCRIPTION <code>data</code> <p> TYPE: <code>dict</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def register_from_dict(self, data: dict) -&gt; None:\n    for name, obj in data.items():\n        if name.startswith(\"_\"):\n            continue\n        if isinstance(obj, Task):\n            self.register_task(obj)\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.register_async_handler","title":"register_async_handler","text":"<pre><code>register_async_handler(event, handler)\n</code></pre> PARAMETER DESCRIPTION <code>event</code> <p> TYPE: <code>Event | str</code> </p> <code>handler</code> <p> TYPE: <code>AsyncHandler</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def register_async_handler(self, event: Event | str, handler: AsyncHandler) -&gt; None:\n    event = Event.from_string_or_event(event)\n    self.dispatcher.register_handler(\n        f\"{event.type}.async_dispatch\",\n        self._async_dispatcher_worker.send,\n    )\n    self._async_dispatcher_worker.dispatcher.register_handler(event, handler)\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.unregister_async_handler","title":"unregister_async_handler","text":"<pre><code>unregister_async_handler(event)\n</code></pre> PARAMETER DESCRIPTION <code>event</code> <p> TYPE: <code>Event | str</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def unregister_async_handler(self, event: Event | str) -&gt; AsyncHandler | None:\n    return self._async_dispatcher_worker.dispatcher.unregister_handler(event)\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.sync_queue","title":"sync_queue","text":"<pre><code>sync_queue(task)\n</code></pre> PARAMETER DESCRIPTION <code>task</code> <p> TYPE: <code>str | Task</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def sync_queue(self, task: str | Task) -&gt; None:\n    self._task_to_queue.appendleft(task)\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.sync_priority_queue","title":"sync_priority_queue","text":"<pre><code>sync_priority_queue(task)\n</code></pre> PARAMETER DESCRIPTION <code>task</code> <p> TYPE: <code>str | Task</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def sync_priority_queue(self, task: str | Task) -&gt; None:\n    self._priority_task_run_queue.appendleft(self.create_task_run(task))\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.num_concurrent_tasks_for","title":"num_concurrent_tasks_for","text":"<pre><code>num_concurrent_tasks_for(task_name)\n</code></pre> <p>The number of concurrent tasks for a given task_name</p> PARAMETER DESCRIPTION <code>task_name</code> <p> TYPE: <code>str</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def num_concurrent_tasks_for(self, task_name: str) -&gt; int:\n    \"\"\"The number of concurrent tasks for a given task_name\"\"\"\n    return len(self._concurrent_tasks[task_name])\n</code></pre>"},{"location":"reference/task_scheduler/#fluid.scheduler.TaskScheduler.queue_and_wait","title":"queue_and_wait  <code>async</code>","text":"<pre><code>queue_and_wait(task, *, timeout=2, **params)\n</code></pre> <p>Queue a task and wait for it to finish</p> PARAMETER DESCRIPTION <code>task</code> <p> TYPE: <code>str | Task</code> </p> <code>timeout</code> <p> TYPE: <code>int</code> DEFAULT: <code>2</code> </p> <code>**params</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>async def queue_and_wait(\n    self, task: str | Task, *, timeout: int = 2, **params: Any\n) -&gt; TaskRun:\n    \"\"\"Queue a task and wait for it to finish\"\"\"\n    with TaskRunWaiter(self) as waiter:\n        task_run = await self.queue(task, **params)\n        return await waiter.wait(task_run, timeout=timeout)\n</code></pre>"},{"location":"reference/task_scheduling/","title":"Task Scheduling","text":"<p>Scheduling functions for tasks. They can be imported from <code>fluid.scheduler</code>:</p> <pre><code>from fastapi.scheduler import every, crontab\n</code></pre>"},{"location":"reference/task_scheduling/#fluid.scheduler.Scheduler","title":"fluid.scheduler.Scheduler","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for all schedulers.</p>"},{"location":"reference/task_scheduling/#fluid.scheduler.Scheduler.info","title":"info  <code>abstractmethod</code>","text":"<pre><code>info()\n</code></pre> <p>Return a string representation of the schedule.</p> Source code in <code>fluid/scheduler/scheduler_crontab.py</code> <pre><code>@abstractmethod\ndef info(self) -&gt; str:\n    \"\"\"Return a string representation of the schedule.\"\"\"\n</code></pre>"},{"location":"reference/task_scheduling/#fluid.scheduler.every","title":"fluid.scheduler.every","text":"<pre><code>every(delta, delay=timedelta(), jitter=timedelta())\n</code></pre> <p>               Bases: <code>Scheduler</code></p> PARAMETER DESCRIPTION <code>delta</code> <p> TYPE: <code>timedelta</code> </p> <code>delay</code> <p> TYPE: <code>timedelta</code> DEFAULT: <code>timedelta()</code> </p> <code>jitter</code> <p> TYPE: <code>timedelta</code> DEFAULT: <code>timedelta()</code> </p> Source code in <code>fluid/scheduler/scheduler_every.py</code> <pre><code>def __init__(\n    self,\n    delta: timedelta,\n    delay: timedelta = timedelta(),\n    jitter: timedelta = timedelta(),\n) -&gt; None:\n    self.delta: timedelta = delta\n    self.delay: timedelta = delay\n    self.jitter: timedelta = jitter\n    self._delta: timedelta = self.next_delta()\n    self._started: datetime | None = None\n</code></pre>"},{"location":"reference/task_scheduling/#fluid.scheduler.every.delta","title":"delta  <code>instance-attribute</code>","text":"<pre><code>delta = delta\n</code></pre>"},{"location":"reference/task_scheduling/#fluid.scheduler.every.delay","title":"delay  <code>instance-attribute</code>","text":"<pre><code>delay = delay\n</code></pre>"},{"location":"reference/task_scheduling/#fluid.scheduler.every.jitter","title":"jitter  <code>instance-attribute</code>","text":"<pre><code>jitter = jitter\n</code></pre>"},{"location":"reference/task_scheduling/#fluid.scheduler.every.info","title":"info","text":"<pre><code>info()\n</code></pre> Source code in <code>fluid/scheduler/scheduler_every.py</code> <pre><code>def info(self) -&gt; str:\n    return str(self.delta)\n</code></pre>"},{"location":"reference/task_scheduling/#fluid.scheduler.every.next_delta","title":"next_delta","text":"<pre><code>next_delta()\n</code></pre> Source code in <code>fluid/scheduler/scheduler_every.py</code> <pre><code>def next_delta(self) -&gt; timedelta:\n    return self.delta + random.uniform(0, 1) * self.jitter\n</code></pre>"},{"location":"reference/task_scheduling/#fluid.scheduler.crontab","title":"fluid.scheduler.crontab","text":"<pre><code>crontab(\n    minute=\"*\",\n    hour=\"*\",\n    day=\"*\",\n    month=\"*\",\n    day_of_week=\"*\",\n    tz=UTC,\n)\n</code></pre> <p>               Bases: <code>Scheduler</code></p> <p>Convert a \"crontab\"-style set of parameters into a test function that will return True when the given datetime matches the parameters set forth in the crontab. For day-of-week, 0=Sunday and 6=Saturday. Acceptable inputs: * = every distinct value /n = run every \"n\" times, i.e. hours='/4' == 0, 4, 8, 12, 16, 20 m-n = run every time m..n m,n = run on m and n</p> PARAMETER DESCRIPTION <code>minute</code> <p> TYPE: <code>CI</code> DEFAULT: <code>'*'</code> </p> <code>hour</code> <p> TYPE: <code>CI</code> DEFAULT: <code>'*'</code> </p> <code>day</code> <p> TYPE: <code>CI</code> DEFAULT: <code>'*'</code> </p> <code>month</code> <p> TYPE: <code>CI</code> DEFAULT: <code>'*'</code> </p> <code>day_of_week</code> <p> TYPE: <code>CI</code> DEFAULT: <code>'*'</code> </p> <code>tz</code> <p> TYPE: <code>ZoneInfo</code> DEFAULT: <code>UTC</code> </p> Source code in <code>fluid/scheduler/scheduler_crontab.py</code> <pre><code>def __init__(\n    self,\n    minute: CI = \"*\",\n    hour: CI = \"*\",\n    day: CI = \"*\",\n    month: CI = \"*\",\n    day_of_week: CI = \"*\",\n    tz: ZoneInfo = UTC,\n) -&gt; None:\n    self.tz: ZoneInfo = tz\n    self._info = (\n        f\"minute {minute}; hour {hour}; day {day}; month {month}; \"\n        f\"day_of_week {day_of_week}\"\n    )\n    validation = (\n        (\"m\", month, range(1, 13)),\n        (\"d\", day, range(1, 32)),\n        (\"w\", day_of_week, range(8)),  # 0-6, but also 7 for Sunday.\n        (\"H\", hour, range(24)),\n        (\"M\", minute, range(60)),\n    )\n    cron_settings = []\n\n    for date_str, value, acceptable in validation:\n        settings: Set[int] = set()\n\n        if isinstance(value, int):\n            value = str(value)\n\n        for piece in value.split(\",\"):\n            if piece == \"*\":\n                settings.update(acceptable)\n                continue\n\n            if piece.isdigit():\n                digit = int(piece)\n                if digit not in acceptable:\n                    raise ValueError(\"%d is not a valid input\" % digit)\n                elif date_str == \"w\":\n                    digit %= 7\n                settings.add(digit)\n\n            else:\n                dash_match = dash_re.match(piece)\n                if dash_match:\n                    lhs, rhs = map(int, dash_match.groups())\n                    if lhs not in acceptable or rhs not in acceptable:\n                        raise ValueError(\"%s is not a valid input\" % piece)\n                    elif date_str == \"w\":\n                        lhs %= 7\n                        rhs %= 7\n                    settings.update(range(lhs, rhs + 1))\n                    continue\n\n                # Handle stuff like */3, */6.\n                every_match = every_re.match(piece)\n                if every_match:\n                    if date_str == \"w\":\n                        raise ValueError(\n                            \"Cannot perform this kind of matching\"\n                            \" on day-of-week.\"\n                        )\n                    interval = int(every_match.groups()[0])\n                    settings.update(acceptable[::interval])\n\n        cron_settings.append(sorted(list(settings)))\n    self.cron_settings = tuple(cron_settings)\n</code></pre>"},{"location":"reference/task_scheduling/#fluid.scheduler.crontab.tz","title":"tz  <code>instance-attribute</code>","text":"<pre><code>tz = tz\n</code></pre>"},{"location":"reference/task_scheduling/#fluid.scheduler.crontab.cron_settings","title":"cron_settings  <code>instance-attribute</code>","text":"<pre><code>cron_settings = tuple(cron_settings)\n</code></pre>"},{"location":"reference/task_scheduling/#fluid.scheduler.crontab.info","title":"info","text":"<pre><code>info()\n</code></pre> Source code in <code>fluid/scheduler/scheduler_crontab.py</code> <pre><code>def info(self) -&gt; str:\n    return self._info\n</code></pre>"},{"location":"reference/tast_consumer/","title":"Task Consumer","text":"<p>The task consumer is a TaskManager which is also a Workers that consumes tasks from the task queue and executes them. It can be imported from <code>fluid.scheduler</code>:</p> <pre><code>from fastapi.scheduler import TaskConsumer\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer","title":"fluid.scheduler.TaskConsumer","text":"<pre><code>TaskConsumer(**config)\n</code></pre> <p>               Bases: <code>TaskManager</code>, <code>Workers</code></p> <p>The Task Consumer is a Task Manager responsible for consuming tasks from a task queue</p> PARAMETER DESCRIPTION <code>**config</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def __init__(self, **config: Any) -&gt; None:\n    super().__init__(**config)\n    Workers.__init__(self)\n    self._async_dispatcher_worker = AsyncConsumer(AsyncTaskDispatcher())\n    self._concurrent_tasks: dict[str, dict[str, TaskRun]] = defaultdict(dict)\n    self._task_to_queue: deque[str | Task] = deque()\n    self._priority_task_run_queue: deque[TaskRun] = deque()\n    self._queue_tasks_worker = WorkerFunction(\n        self._queue_task, name=\"queue-task-worker\"\n    )\n    self.add_workers(self._queue_tasks_worker)\n    self.add_workers(self._async_dispatcher_worker)\n    for i in range(self.config.max_concurrent_tasks):\n        worker_name = f\"task-worker-{i+1}\"\n        self.add_workers(\n            WorkerFunction(\n                partial(self._consume_tasks, worker_name), name=worker_name\n            )\n        )\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.worker_name","title":"worker_name  <code>property</code>","text":"<pre><code>worker_name\n</code></pre> <p>The name of the worker</p>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.num_workers","title":"num_workers  <code>property</code>","text":"<pre><code>num_workers\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.running","title":"running  <code>property</code>","text":"<pre><code>running\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.deps","title":"deps  <code>instance-attribute</code>","text":"<pre><code>deps = deps if deps is not None else State()\n</code></pre> <p>Dependencies for the task manager.</p> <p>Production applications requires global dependencies to be available to all tasks. This can be achieved by setting the <code>deps</code> attribute of the task manager to an object with the required dependencies.</p> <p>Each task can cast the dependencies to the required type.</p>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config = config or TaskManagerConfig(**kwargs)\n</code></pre> <p>Task manager configuration</p>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.dispatcher","title":"dispatcher  <code>instance-attribute</code>","text":"<pre><code>dispatcher = TaskDispatcher()\n</code></pre> <p>A dispatcher of TaskRun events.</p> <p>Application can register handlers to listen for events happening during the lifecycle of a task run.</p>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.broker","title":"broker  <code>instance-attribute</code>","text":"<pre><code>broker = from_url(broker_url)\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.registry","title":"registry  <code>property</code>","text":"<pre><code>registry\n</code></pre> <p>The task registry</p>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.type","title":"type  <code>property</code>","text":"<pre><code>type\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.num_concurrent_tasks","title":"num_concurrent_tasks  <code>property</code>","text":"<pre><code>num_concurrent_tasks\n</code></pre> <p>The number of concurrent_tasks running in the consumer</p>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.status","title":"status  <code>async</code>","text":"<pre><code>status()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def status(self) -&gt; dict:\n    return await self._workers.status()\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.gracefully_stop","title":"gracefully_stop","text":"<pre><code>gracefully_stop()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def gracefully_stop(self) -&gt; None:\n    self._workers.gracefully_stop()\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.is_running","title":"is_running","text":"<pre><code>is_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_running(self) -&gt; bool:\n    return self._running\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.is_stopping","title":"is_stopping","text":"<pre><code>is_stopping()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_stopping(self) -&gt; bool:\n    return self._workers.is_stopping()\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.run","title":"run  <code>async</code>","text":"<pre><code>run()\n</code></pre> <p>run the workers</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def run(self) -&gt; None:\n    \"\"\"run the workers\"\"\"\n    with self.start_running():\n        async with self.safe_run():\n            workers, _ = self._workers.workers_tasks()\n            self._workers.workers = tuple(workers)\n            self._workers.tasks = tuple(\n                self.create_task(worker) for worker in workers\n            )\n            await asyncio.gather(*self._workers.tasks)\n        await self.shutdown()\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.start_running","title":"start_running","text":"<pre><code>start_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>@contextmanager\ndef start_running(self) -&gt; Generator:\n    if self._running:\n        raise RuntimeError(\"Worker is already running\")\n    self._running = True\n    try:\n        logger.info(\"%s started running\", self.worker_name)\n        yield\n    finally:\n        self._running = False\n        logger.warning(\"%s stopped running\", self.worker_name)\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.add_workers","title":"add_workers","text":"<pre><code>add_workers(*workers)\n</code></pre> <p>add workers to the workers</p> PARAMETER DESCRIPTION <code>*workers</code> <p> TYPE: <code>Worker</code> DEFAULT: <code>()</code> </p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def add_workers(self, *workers: Worker) -&gt; None:\n    \"\"\"add workers to the workers\"\"\"\n    workers_, _ = self._workers.workers_tasks()\n    for worker in workers:\n        if worker not in workers_:\n            workers_.append(worker)\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.wait_for_exit","title":"wait_for_exit  <code>async</code>","text":"<pre><code>wait_for_exit()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def wait_for_exit(self) -&gt; None:\n    if self._workers_task is not None:\n        await self._workers_task\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.create_task","title":"create_task","text":"<pre><code>create_task(worker)\n</code></pre> PARAMETER DESCRIPTION <code>worker</code> <p> TYPE: <code>Worker</code> </p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def create_task(self, worker: Worker) -&gt; asyncio.Task:\n    return asyncio.create_task(\n        self._run_worker(worker), name=f\"{self.worker_name}-{worker.worker_name}\"\n    )\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.on_shutdown","title":"on_shutdown  <code>async</code>","text":"<pre><code>on_shutdown()\n</code></pre> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>async def on_shutdown(self) -&gt; None:\n    await self.broker.close()\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.shutdown","title":"shutdown  <code>async</code>","text":"<pre><code>shutdown()\n</code></pre> <p>shutdown the workers</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def shutdown(self) -&gt; None:\n    \"\"\"shutdown the workers\"\"\"\n    if self._has_shutdown:\n        return\n    self._has_shutdown = True\n    logger.warning(\n        \"gracefully stopping %d workers: %s\",\n        self.num_workers,\n        \", \".join(w.worker_name for w in self._workers.workers),\n    )\n    self.gracefully_stop()\n    try:\n        async with asyncio.timeout(self._stopping_grace_period):\n            await self.wait_for_exit()\n        await self.on_shutdown()\n        return\n    except asyncio.TimeoutError:\n        logger.warning(\n            \"could not stop workers %s gracefully after %s\"\n            \" seconds - force shutdown\",\n            \", \".join(\n                task.get_name() for task in self._workers.tasks if not task.done()\n            ),\n            self._stopping_grace_period,\n        )\n    except asyncio.CancelledError:\n        pass\n    self._force_shutdown = True\n    self._workers.cancel()\n    try:\n        await self.wait_for_exit()\n    except asyncio.CancelledError:\n        pass\n    await self.on_shutdown()\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.bail_out","title":"bail_out","text":"<pre><code>bail_out(reason, code=1)\n</code></pre> PARAMETER DESCRIPTION <code>reason</code> <p> TYPE: <code>str</code> </p> <code>code</code> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def bail_out(self, reason: str, code: int = 1) -&gt; None:\n    self.gracefully_stop()\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.safe_run","title":"safe_run  <code>async</code>","text":"<pre><code>safe_run()\n</code></pre> <p>Context manager to run a worker safely</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>@asynccontextmanager\nasync def safe_run(self) -&gt; AsyncGenerator:\n    \"\"\"Context manager to run a worker safely\"\"\"\n    try:\n        yield\n    except asyncio.CancelledError:\n        if self._force_shutdown:\n            # we are shutting down, this is expected\n            pass\n        raise\n    except Exception as e:\n        reason = f\"unhandled exception while running workers: {e}\"\n        logger.exception(reason)\n        asyncio.get_event_loop().call_soon(self.bail_out, reason, 2)\n    else:\n        # worker finished without error\n        # make sure we are shutting down\n        asyncio.get_event_loop().call_soon(self.bail_out, \"worker exit\", 1)\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.remove_workers","title":"remove_workers","text":"<pre><code>remove_workers(*workers)\n</code></pre> <p>remove workers from the workers</p> PARAMETER DESCRIPTION <code>*workers</code> <p> TYPE: <code>Worker</code> DEFAULT: <code>()</code> </p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def remove_workers(self, *workers: Worker) -&gt; None:\n    \"remove workers from the workers\"\n    workers_, _ = self._workers.workers_tasks()\n    for worker in workers:\n        try:\n            workers_.remove(worker)\n        except ValueError:\n            pass\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.startup","title":"startup  <code>async</code>","text":"<pre><code>startup()\n</code></pre> <p>start the workers</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def startup(self) -&gt; None:\n    \"\"\"start the workers\"\"\"\n    if self._workers_task is None:\n        self._workers_task = asyncio.create_task(self.run(), name=self.worker_name)\n        for args in self._delayed_callbacks:\n            self._delayed_callback(*args)\n        self._delayed_callbacks = []\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.register_callback","title":"register_callback","text":"<pre><code>register_callback(\n    callback, seconds, jitter=0.0, periodic=False\n)\n</code></pre> <p>Register a callback</p> <p>The callback can be periodic or not.</p> PARAMETER DESCRIPTION <code>callback</code> <p> TYPE: <code>Callable[[], None]</code> </p> <code>seconds</code> <p> TYPE: <code>float</code> </p> <code>jitter</code> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> <code>periodic</code> <p> TYPE: <code>bool | float</code> DEFAULT: <code>False</code> </p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def register_callback(\n    self,\n    callback: Callable[[], None],\n    seconds: float,\n    jitter: float = 0.0,\n    periodic: bool | float = False,\n) -&gt; None:\n    \"\"\"Register a callback\n\n    The callback can be periodic or not.\n    \"\"\"\n    if periodic is True:\n        periodic_float = seconds\n    elif periodic is False:\n        periodic_float = 0.0\n    else:\n        periodic_float = periodic\n    if not self.running:\n        self._delayed_callbacks.append((callback, seconds, jitter, periodic_float))\n    else:\n        self._delayed_callback(callback, seconds, jitter, periodic_float)\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.enter_async_context","title":"enter_async_context  <code>async</code>","text":"<pre><code>enter_async_context(cm)\n</code></pre> PARAMETER DESCRIPTION <code>cm</code> <p> TYPE: <code>Any</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>async def enter_async_context(self, cm: Any) -&gt; Any:\n    return await self._stack.enter_async_context(cm)\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.execute","title":"execute  <code>async</code>","text":"<pre><code>execute(task, **params)\n</code></pre> <p>Execute a task and wait for it to finish</p> PARAMETER DESCRIPTION <code>task</code> <p> TYPE: <code>Task | str</code> </p> <code>**params</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>async def execute(self, task: Task | str, **params: Any) -&gt; TaskRun:\n    \"\"\"Execute a task and wait for it to finish\"\"\"\n    task_run = self.create_task_run(task, **params)\n    await task_run.execute()\n    return task_run\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.execute_sync","title":"execute_sync","text":"<pre><code>execute_sync(task, **params)\n</code></pre> PARAMETER DESCRIPTION <code>task</code> <p> TYPE: <code>Task | str</code> </p> <code>**params</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def execute_sync(self, task: Task | str, **params: Any) -&gt; TaskRun:\n    return asyncio.run(self._execute_and_exit(task, **params))\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.register_task","title":"register_task","text":"<pre><code>register_task(task)\n</code></pre> <p>Register a task with the task manager</p> <p>Only tasks registered can be executed by a task manager</p> PARAMETER DESCRIPTION <code>task</code> <p> TYPE: <code>Task</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def register_task(self, task: Task) -&gt; None:\n    \"\"\"Register a task with the task manager\n\n    Only tasks registered can be executed by a task manager\n    \"\"\"\n    self.broker.register_task(task)\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.queue","title":"queue  <code>async</code>","text":"<pre><code>queue(task, priority=None, **params)\n</code></pre> <p>Queue a task for execution</p> <p>This methods fires two events:</p> <ul> <li>init: when the task run is created</li> <li>queued: after the task is queued</li> </ul> PARAMETER DESCRIPTION <code>task</code> <p> TYPE: <code>str | Task</code> </p> <code>priority</code> <p> TYPE: <code>TaskPriority | None</code> DEFAULT: <code>None</code> </p> <code>**params</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>async def queue(\n    self,\n    task: str | Task,\n    priority: TaskPriority | None = None,\n    **params: Any,\n) -&gt; TaskRun:\n    \"\"\"Queue a task for execution\n\n    This methods fires two events:\n\n    - init: when the task run is created\n    - queued: after the task is queued\n    \"\"\"\n    task_run = self.create_task_run(task, priority=priority, **params)\n    self.dispatcher.dispatch(task_run)\n    task_run.set_state(TaskState.queued)\n    await self.broker.queue_task(task_run)\n    return task_run\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.create_task_run","title":"create_task_run","text":"<pre><code>create_task_run(task, run_id='', priority=None, **params)\n</code></pre> <p>Create a TaskRun in <code>init</code> state</p> PARAMETER DESCRIPTION <code>task</code> <p> TYPE: <code>str | Task</code> </p> <code>run_id</code> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>priority</code> <p> TYPE: <code>TaskPriority | None</code> DEFAULT: <code>None</code> </p> <code>**params</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def create_task_run(\n    self,\n    task: str | Task,\n    run_id: str = \"\",\n    priority: TaskPriority | None = None,\n    **params: Any,\n) -&gt; TaskRun:\n    \"\"\"Create a TaskRun in `init` state\"\"\"\n    task = self.broker.task_from_registry(task)\n    run_id = run_id or self.broker.new_uuid()\n    return TaskRun(\n        id=run_id,\n        task=task,\n        priority=priority or task.priority,\n        params=task.params_model(**params),\n        task_manager=self,\n    )\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.register_from_module","title":"register_from_module","text":"<pre><code>register_from_module(module)\n</code></pre> PARAMETER DESCRIPTION <code>module</code> <p> TYPE: <code>Any</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def register_from_module(self, module: Any) -&gt; None:\n    for name in dir(module):\n        if name.startswith(\"_\"):\n            continue\n        if isinstance(obj := getattr(module, name), Task):\n            self.register_task(obj)\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.register_from_dict","title":"register_from_dict","text":"<pre><code>register_from_dict(data)\n</code></pre> PARAMETER DESCRIPTION <code>data</code> <p> TYPE: <code>dict</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def register_from_dict(self, data: dict) -&gt; None:\n    for name, obj in data.items():\n        if name.startswith(\"_\"):\n            continue\n        if isinstance(obj, Task):\n            self.register_task(obj)\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.sync_queue","title":"sync_queue","text":"<pre><code>sync_queue(task)\n</code></pre> PARAMETER DESCRIPTION <code>task</code> <p> TYPE: <code>str | Task</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def sync_queue(self, task: str | Task) -&gt; None:\n    self._task_to_queue.appendleft(task)\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.sync_priority_queue","title":"sync_priority_queue","text":"<pre><code>sync_priority_queue(task)\n</code></pre> PARAMETER DESCRIPTION <code>task</code> <p> TYPE: <code>str | Task</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def sync_priority_queue(self, task: str | Task) -&gt; None:\n    self._priority_task_run_queue.appendleft(self.create_task_run(task))\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.num_concurrent_tasks_for","title":"num_concurrent_tasks_for","text":"<pre><code>num_concurrent_tasks_for(task_name)\n</code></pre> <p>The number of concurrent tasks for a given task_name</p> PARAMETER DESCRIPTION <code>task_name</code> <p> TYPE: <code>str</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def num_concurrent_tasks_for(self, task_name: str) -&gt; int:\n    \"\"\"The number of concurrent tasks for a given task_name\"\"\"\n    return len(self._concurrent_tasks[task_name])\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.queue_and_wait","title":"queue_and_wait  <code>async</code>","text":"<pre><code>queue_and_wait(task, *, timeout=2, **params)\n</code></pre> <p>Queue a task and wait for it to finish</p> PARAMETER DESCRIPTION <code>task</code> <p> TYPE: <code>str | Task</code> </p> <code>timeout</code> <p> TYPE: <code>int</code> DEFAULT: <code>2</code> </p> <code>**params</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>async def queue_and_wait(\n    self, task: str | Task, *, timeout: int = 2, **params: Any\n) -&gt; TaskRun:\n    \"\"\"Queue a task and wait for it to finish\"\"\"\n    with TaskRunWaiter(self) as waiter:\n        task_run = await self.queue(task, **params)\n        return await waiter.wait(task_run, timeout=timeout)\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.register_async_handler","title":"register_async_handler","text":"<pre><code>register_async_handler(event, handler)\n</code></pre> PARAMETER DESCRIPTION <code>event</code> <p> TYPE: <code>Event | str</code> </p> <code>handler</code> <p> TYPE: <code>AsyncHandler</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def register_async_handler(self, event: Event | str, handler: AsyncHandler) -&gt; None:\n    event = Event.from_string_or_event(event)\n    self.dispatcher.register_handler(\n        f\"{event.type}.async_dispatch\",\n        self._async_dispatcher_worker.send,\n    )\n    self._async_dispatcher_worker.dispatcher.register_handler(event, handler)\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.unregister_async_handler","title":"unregister_async_handler","text":"<pre><code>unregister_async_handler(event)\n</code></pre> PARAMETER DESCRIPTION <code>event</code> <p> TYPE: <code>Event | str</code> </p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def unregister_async_handler(self, event: Event | str) -&gt; AsyncHandler | None:\n    return self._async_dispatcher_worker.dispatcher.unregister_handler(event)\n</code></pre>"},{"location":"reference/utils/","title":"Utils","text":""},{"location":"reference/utils/#fluid.utils.lazy.LazyGroup","title":"fluid.utils.lazy.LazyGroup","text":"<pre><code>LazyGroup(*, lazy_subcommands=None, **kwargs)\n</code></pre> <p>               Bases: <code>Group</code></p> <p>A click Group that can lazily load subcommands</p> <p>This class extends the click.Group class to allow for subcommands to be lazily loaded from a module path.</p> <p>It is useful when you have a large number of subcommands that you don't want to load until they are actually needed.</p> <p>Available with the <code>cli</code> extra dependencies.</p> PARAMETER DESCRIPTION <code>lazy_subcommands</code> <p> TYPE: <code>dict[str, str] | None</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> Source code in <code>fluid/utils/lazy.py</code> <pre><code>def __init__(\n    self,\n    *,\n    lazy_subcommands: dict[str, str] | None = None,\n    **kwargs: Any,\n):\n    super().__init__(**kwargs)\n    self.lazy_subcommands = lazy_subcommands or {}\n</code></pre>"},{"location":"reference/utils/#fluid.utils.lazy.LazyGroup.lazy_subcommands","title":"lazy_subcommands  <code>instance-attribute</code>","text":"<pre><code>lazy_subcommands = lazy_subcommands or {}\n</code></pre>"},{"location":"reference/utils/#fluid.utils.lazy.LazyGroup.list_commands","title":"list_commands","text":"<pre><code>list_commands(ctx)\n</code></pre> PARAMETER DESCRIPTION <code>ctx</code> <p> TYPE: <code>Context</code> </p> Source code in <code>fluid/utils/lazy.py</code> <pre><code>def list_commands(self, ctx: click.Context) -&gt; list[str]:\n    commands = super().list_commands(ctx)\n    commands.extend(self.lazy_subcommands)\n    return sorted(commands)\n</code></pre>"},{"location":"reference/utils/#fluid.utils.lazy.LazyGroup.get_command","title":"get_command","text":"<pre><code>get_command(ctx, cmd_name)\n</code></pre> PARAMETER DESCRIPTION <code>ctx</code> <p> TYPE: <code>Context</code> </p> <code>cmd_name</code> <p> TYPE: <code>str</code> </p> Source code in <code>fluid/utils/lazy.py</code> <pre><code>def get_command(self, ctx: click.Context, cmd_name: str) -&gt; click.Command | None:\n    if cmd_name in self.lazy_subcommands:\n        return self._lazy_load(cmd_name)\n    return super().get_command(ctx, cmd_name)\n</code></pre>"},{"location":"reference/workers/","title":"Workers","text":"<p>Workers are the main building block for asynchronous programming with <code>aio-fluid</code>. They are responsible for running tasks and managing their lifecycle. There are several worker classes which can be imported from <code>fluid.utils.worker</code>:</p> <pre><code>from fluid.utils.worker import StoppingWorker\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Worker","title":"fluid.utils.worker.Worker","text":"<pre><code>Worker(name='')\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>The base class of a worker that can be run</p> PARAMETER DESCRIPTION <code>name</code> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def __init__(self, name: str = \"\") -&gt; None:\n    self._name: str = name or underscore(type(self).__name__)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Worker.worker_name","title":"worker_name  <code>property</code>","text":"<pre><code>worker_name\n</code></pre> <p>The name of the worker</p>"},{"location":"reference/workers/#fluid.utils.worker.Worker.num_workers","title":"num_workers  <code>property</code>","text":"<pre><code>num_workers\n</code></pre> <p>The number of workers in this worker</p>"},{"location":"reference/workers/#fluid.utils.worker.Worker.status","title":"status  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>status()\n</code></pre> <p>Get the status of the worker.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>@abstractmethod\nasync def status(self) -&gt; dict:\n    \"\"\"\n    Get the status of the worker.\n    \"\"\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Worker.gracefully_stop","title":"gracefully_stop  <code>abstractmethod</code>","text":"<pre><code>gracefully_stop()\n</code></pre> <p>gracefully stop the worker</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>@abstractmethod\ndef gracefully_stop(self) -&gt; None:\n    \"gracefully stop the worker\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Worker.is_running","title":"is_running  <code>abstractmethod</code>","text":"<pre><code>is_running()\n</code></pre> <p>Is the worker running?</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>@abstractmethod\ndef is_running(self) -&gt; bool:\n    \"\"\"Is the worker running?\"\"\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Worker.is_stopping","title":"is_stopping  <code>abstractmethod</code>","text":"<pre><code>is_stopping()\n</code></pre> <p>Is the worker stopping?</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>@abstractmethod\ndef is_stopping(self) -&gt; bool:\n    \"\"\"Is the worker stopping?\"\"\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Worker.run","title":"run  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>run()\n</code></pre> <p>run the worker</p> <p>THis is the main entry point of the worker.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>@abstractmethod\nasync def run(self) -&gt; None:\n    \"\"\"run the worker\n\n    THis is the main entry point of the worker.\n    \"\"\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.RunningWorker","title":"fluid.utils.worker.RunningWorker","text":"<pre><code>RunningWorker(name='')\n</code></pre> <p>               Bases: <code>Worker</code></p> <p>A Worker that can be started</p> PARAMETER DESCRIPTION <code>name</code> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def __init__(self, name: str = \"\") -&gt; None:\n    super().__init__(name)\n    self._running: bool = False\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.RunningWorker.worker_name","title":"worker_name  <code>property</code>","text":"<pre><code>worker_name\n</code></pre> <p>The name of the worker</p>"},{"location":"reference/workers/#fluid.utils.worker.RunningWorker.num_workers","title":"num_workers  <code>property</code>","text":"<pre><code>num_workers\n</code></pre> <p>The number of workers in this worker</p>"},{"location":"reference/workers/#fluid.utils.worker.RunningWorker.status","title":"status  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>status()\n</code></pre> <p>Get the status of the worker.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>@abstractmethod\nasync def status(self) -&gt; dict:\n    \"\"\"\n    Get the status of the worker.\n    \"\"\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.RunningWorker.gracefully_stop","title":"gracefully_stop  <code>abstractmethod</code>","text":"<pre><code>gracefully_stop()\n</code></pre> <p>gracefully stop the worker</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>@abstractmethod\ndef gracefully_stop(self) -&gt; None:\n    \"gracefully stop the worker\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.RunningWorker.is_stopping","title":"is_stopping  <code>abstractmethod</code>","text":"<pre><code>is_stopping()\n</code></pre> <p>Is the worker stopping?</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>@abstractmethod\ndef is_stopping(self) -&gt; bool:\n    \"\"\"Is the worker stopping?\"\"\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.RunningWorker.run","title":"run  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>run()\n</code></pre> <p>run the worker</p> <p>THis is the main entry point of the worker.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>@abstractmethod\nasync def run(self) -&gt; None:\n    \"\"\"run the worker\n\n    THis is the main entry point of the worker.\n    \"\"\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.RunningWorker.is_running","title":"is_running","text":"<pre><code>is_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_running(self) -&gt; bool:\n    return self._running\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.RunningWorker.start_running","title":"start_running","text":"<pre><code>start_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>@contextmanager\ndef start_running(self) -&gt; Generator:\n    if self._running:\n        raise RuntimeError(\"Worker is already running\")\n    self._running = True\n    try:\n        logger.info(\"%s started running\", self.worker_name)\n        yield\n    finally:\n        self._running = False\n        logger.warning(\"%s stopped running\", self.worker_name)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.StoppingWorker","title":"fluid.utils.worker.StoppingWorker","text":"<pre><code>StoppingWorker(name='')\n</code></pre> <p>               Bases: <code>RunningWorker</code></p> <p>A Worker that can be stopped</p> PARAMETER DESCRIPTION <code>name</code> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def __init__(self, name: str = \"\") -&gt; None:\n    super().__init__(name)\n    self._stopping: bool = False\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.StoppingWorker.worker_name","title":"worker_name  <code>property</code>","text":"<pre><code>worker_name\n</code></pre> <p>The name of the worker</p>"},{"location":"reference/workers/#fluid.utils.worker.StoppingWorker.num_workers","title":"num_workers  <code>property</code>","text":"<pre><code>num_workers\n</code></pre> <p>The number of workers in this worker</p>"},{"location":"reference/workers/#fluid.utils.worker.StoppingWorker.is_running","title":"is_running","text":"<pre><code>is_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_running(self) -&gt; bool:\n    return self._running\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.StoppingWorker.run","title":"run  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>run()\n</code></pre> <p>run the worker</p> <p>THis is the main entry point of the worker.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>@abstractmethod\nasync def run(self) -&gt; None:\n    \"\"\"run the worker\n\n    THis is the main entry point of the worker.\n    \"\"\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.StoppingWorker.start_running","title":"start_running","text":"<pre><code>start_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>@contextmanager\ndef start_running(self) -&gt; Generator:\n    if self._running:\n        raise RuntimeError(\"Worker is already running\")\n    self._running = True\n    try:\n        logger.info(\"%s started running\", self.worker_name)\n        yield\n    finally:\n        self._running = False\n        logger.warning(\"%s stopped running\", self.worker_name)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.StoppingWorker.is_stopping","title":"is_stopping","text":"<pre><code>is_stopping()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_stopping(self) -&gt; bool:\n    return self._stopping\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.StoppingWorker.gracefully_stop","title":"gracefully_stop","text":"<pre><code>gracefully_stop()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def gracefully_stop(self) -&gt; None:\n    self._stopping = True\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.StoppingWorker.status","title":"status  <code>async</code>","text":"<pre><code>status()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def status(self) -&gt; dict:\n    return {\"stopping\": self.is_stopping(), \"running\": self.is_running()}\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.WorkerFunction","title":"fluid.utils.worker.WorkerFunction","text":"<pre><code>WorkerFunction(run_function, heartbeat=0, name='')\n</code></pre> <p>               Bases: <code>StoppingWorker</code></p> <p>A Worker that runs a coroutine function</p> PARAMETER DESCRIPTION <code>run_function</code> <p> TYPE: <code>Callable[[], Awaitable[None]]</code> </p> <code>heartbeat</code> <p> TYPE: <code>float | int</code> DEFAULT: <code>0</code> </p> <code>name</code> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def __init__(\n    self,\n    run_function: Callable[[], Awaitable[None]],\n    heartbeat: float | int = 0,\n    name: str = \"\",\n) -&gt; None:\n    super().__init__(name=name)\n    self._run_function = run_function\n    self._heartbeat = heartbeat\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.WorkerFunction.worker_name","title":"worker_name  <code>property</code>","text":"<pre><code>worker_name\n</code></pre> <p>The name of the worker</p>"},{"location":"reference/workers/#fluid.utils.worker.WorkerFunction.num_workers","title":"num_workers  <code>property</code>","text":"<pre><code>num_workers\n</code></pre> <p>The number of workers in this worker</p>"},{"location":"reference/workers/#fluid.utils.worker.WorkerFunction.status","title":"status  <code>async</code>","text":"<pre><code>status()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def status(self) -&gt; dict:\n    return {\"stopping\": self.is_stopping(), \"running\": self.is_running()}\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.WorkerFunction.gracefully_stop","title":"gracefully_stop","text":"<pre><code>gracefully_stop()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def gracefully_stop(self) -&gt; None:\n    self._stopping = True\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.WorkerFunction.is_running","title":"is_running","text":"<pre><code>is_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_running(self) -&gt; bool:\n    return self._running\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.WorkerFunction.is_stopping","title":"is_stopping","text":"<pre><code>is_stopping()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_stopping(self) -&gt; bool:\n    return self._stopping\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.WorkerFunction.start_running","title":"start_running","text":"<pre><code>start_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>@contextmanager\ndef start_running(self) -&gt; Generator:\n    if self._running:\n        raise RuntimeError(\"Worker is already running\")\n    self._running = True\n    try:\n        logger.info(\"%s started running\", self.worker_name)\n        yield\n    finally:\n        self._running = False\n        logger.warning(\"%s stopped running\", self.worker_name)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.WorkerFunction.run","title":"run  <code>async</code>","text":"<pre><code>run()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def run(self) -&gt; None:\n    with self.start_running():\n        while not self.is_stopping():\n            await self._run_function()\n            await asyncio.sleep(self._heartbeat)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer","title":"fluid.utils.worker.QueueConsumer","text":"<pre><code>QueueConsumer(name='')\n</code></pre> <p>               Bases: <code>StoppingWorker</code>, <code>MessageProducer[MessageType]</code></p> <p>A Worker that can receive messages</p> <p>This worker can receive messages but not consume them.</p> PARAMETER DESCRIPTION <code>name</code> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def __init__(self, name: str = \"\") -&gt; None:\n    super().__init__(name=name)\n    self._queue: asyncio.Queue[MessageType | None] = asyncio.Queue()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer.worker_name","title":"worker_name  <code>property</code>","text":"<pre><code>worker_name\n</code></pre> <p>The name of the worker</p>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer.num_workers","title":"num_workers  <code>property</code>","text":"<pre><code>num_workers\n</code></pre> <p>The number of workers in this worker</p>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer.gracefully_stop","title":"gracefully_stop","text":"<pre><code>gracefully_stop()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def gracefully_stop(self) -&gt; None:\n    self._stopping = True\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer.is_running","title":"is_running","text":"<pre><code>is_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_running(self) -&gt; bool:\n    return self._running\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer.is_stopping","title":"is_stopping","text":"<pre><code>is_stopping()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_stopping(self) -&gt; bool:\n    return self._stopping\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer.run","title":"run  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>run()\n</code></pre> <p>run the worker</p> <p>THis is the main entry point of the worker.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>@abstractmethod\nasync def run(self) -&gt; None:\n    \"\"\"run the worker\n\n    THis is the main entry point of the worker.\n    \"\"\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer.start_running","title":"start_running","text":"<pre><code>start_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>@contextmanager\ndef start_running(self) -&gt; Generator:\n    if self._running:\n        raise RuntimeError(\"Worker is already running\")\n    self._running = True\n    try:\n        logger.info(\"%s started running\", self.worker_name)\n        yield\n    finally:\n        self._running = False\n        logger.warning(\"%s stopped running\", self.worker_name)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer.get_message","title":"get_message  <code>async</code>","text":"<pre><code>get_message(timeout=0.5)\n</code></pre> PARAMETER DESCRIPTION <code>timeout</code> <p> TYPE: <code>float</code> DEFAULT: <code>0.5</code> </p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def get_message(self, timeout: float = 0.5) -&gt; MessageType | None:\n    try:\n        async with asyncio.timeout(timeout):\n            return await self._queue.get()\n    except asyncio.TimeoutError:\n        return None\n    except (asyncio.CancelledError, RuntimeError):\n        if not self.is_stopping():\n            raise\n    return None\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer.queue_size","title":"queue_size","text":"<pre><code>queue_size()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def queue_size(self) -&gt; int:\n    return self._queue.qsize()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer.status","title":"status  <code>async</code>","text":"<pre><code>status()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def status(self) -&gt; dict:\n    status = await super().status()\n    status.update(queue_size=self.queue_size())\n    return status\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer.send","title":"send","text":"<pre><code>send(message)\n</code></pre> <p>Send a message into the worker</p> PARAMETER DESCRIPTION <code>message</code> <p> TYPE: <code>MessageType | None</code> </p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def send(self, message: MessageType | None) -&gt; None:\n    \"\"\"Send a message into the worker\"\"\"\n    self._queue.put_nowait(message)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker","title":"fluid.utils.worker.QueueConsumerWorker","text":"<pre><code>QueueConsumerWorker(on_message, name='')\n</code></pre> <p>               Bases: <code>QueueConsumer[MessageType]</code></p> <p>A Worker that can receive and consume messages</p> PARAMETER DESCRIPTION <code>on_message</code> <p> TYPE: <code>Callable[[MessageType], Awaitable[None]]</code> </p> <code>name</code> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def __init__(\n    self,\n    on_message: Callable[[MessageType], Awaitable[None]],\n    name: str = \"\",\n) -&gt; None:\n    super().__init__(name=name)\n    self.on_message = on_message\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.worker_name","title":"worker_name  <code>property</code>","text":"<pre><code>worker_name\n</code></pre> <p>The name of the worker</p>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.num_workers","title":"num_workers  <code>property</code>","text":"<pre><code>num_workers\n</code></pre> <p>The number of workers in this worker</p>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.on_message","title":"on_message  <code>instance-attribute</code>","text":"<pre><code>on_message = on_message\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.send","title":"send","text":"<pre><code>send(message)\n</code></pre> <p>Send a message into the worker</p> PARAMETER DESCRIPTION <code>message</code> <p> TYPE: <code>MessageType | None</code> </p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def send(self, message: MessageType | None) -&gt; None:\n    \"\"\"Send a message into the worker\"\"\"\n    self._queue.put_nowait(message)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.status","title":"status  <code>async</code>","text":"<pre><code>status()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def status(self) -&gt; dict:\n    status = await super().status()\n    status.update(queue_size=self.queue_size())\n    return status\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.gracefully_stop","title":"gracefully_stop","text":"<pre><code>gracefully_stop()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def gracefully_stop(self) -&gt; None:\n    self._stopping = True\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.is_running","title":"is_running","text":"<pre><code>is_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_running(self) -&gt; bool:\n    return self._running\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.is_stopping","title":"is_stopping","text":"<pre><code>is_stopping()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_stopping(self) -&gt; bool:\n    return self._stopping\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.start_running","title":"start_running","text":"<pre><code>start_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>@contextmanager\ndef start_running(self) -&gt; Generator:\n    if self._running:\n        raise RuntimeError(\"Worker is already running\")\n    self._running = True\n    try:\n        logger.info(\"%s started running\", self.worker_name)\n        yield\n    finally:\n        self._running = False\n        logger.warning(\"%s stopped running\", self.worker_name)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.get_message","title":"get_message  <code>async</code>","text":"<pre><code>get_message(timeout=0.5)\n</code></pre> PARAMETER DESCRIPTION <code>timeout</code> <p> TYPE: <code>float</code> DEFAULT: <code>0.5</code> </p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def get_message(self, timeout: float = 0.5) -&gt; MessageType | None:\n    try:\n        async with asyncio.timeout(timeout):\n            return await self._queue.get()\n    except asyncio.TimeoutError:\n        return None\n    except (asyncio.CancelledError, RuntimeError):\n        if not self.is_stopping():\n            raise\n    return None\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.queue_size","title":"queue_size","text":"<pre><code>queue_size()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def queue_size(self) -&gt; int:\n    return self._queue.qsize()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.run","title":"run  <code>async</code>","text":"<pre><code>run()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def run(self) -&gt; None:\n    with self.start_running():\n        while not self.is_stopping():\n            message = await self.get_message()\n            if message is not None:\n                await self.on_message(message)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer","title":"fluid.utils.worker.AsyncConsumer","text":"<pre><code>AsyncConsumer(dispatcher, name='')\n</code></pre> <p>               Bases: <code>QueueConsumer[MessageType]</code></p> <p>A Worker that can dispatch async callbacks</p> PARAMETER DESCRIPTION <code>dispatcher</code> <p> TYPE: <code>AsyncDispatcher[MessageType]</code> </p> <code>name</code> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def __init__(\n    self, dispatcher: AsyncDispatcher[MessageType], name: str = \"\"\n) -&gt; None:\n    super().__init__(name)\n    self.dispatcher: AsyncDispatcher[MessageType] = dispatcher\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.worker_name","title":"worker_name  <code>property</code>","text":"<pre><code>worker_name\n</code></pre> <p>The name of the worker</p>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.num_workers","title":"num_workers  <code>property</code>","text":"<pre><code>num_workers\n</code></pre> <p>The number of workers in this worker</p>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.AsyncCallback","title":"AsyncCallback  <code>instance-attribute</code>","text":"<pre><code>AsyncCallback\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.dispatcher","title":"dispatcher  <code>instance-attribute</code>","text":"<pre><code>dispatcher = dispatcher\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.send","title":"send","text":"<pre><code>send(message)\n</code></pre> <p>Send a message into the worker</p> PARAMETER DESCRIPTION <code>message</code> <p> TYPE: <code>MessageType | None</code> </p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def send(self, message: MessageType | None) -&gt; None:\n    \"\"\"Send a message into the worker\"\"\"\n    self._queue.put_nowait(message)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.status","title":"status  <code>async</code>","text":"<pre><code>status()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def status(self) -&gt; dict:\n    status = await super().status()\n    status.update(queue_size=self.queue_size())\n    return status\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.gracefully_stop","title":"gracefully_stop","text":"<pre><code>gracefully_stop()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def gracefully_stop(self) -&gt; None:\n    self._stopping = True\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.is_running","title":"is_running","text":"<pre><code>is_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_running(self) -&gt; bool:\n    return self._running\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.is_stopping","title":"is_stopping","text":"<pre><code>is_stopping()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_stopping(self) -&gt; bool:\n    return self._stopping\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.start_running","title":"start_running","text":"<pre><code>start_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>@contextmanager\ndef start_running(self) -&gt; Generator:\n    if self._running:\n        raise RuntimeError(\"Worker is already running\")\n    self._running = True\n    try:\n        logger.info(\"%s started running\", self.worker_name)\n        yield\n    finally:\n        self._running = False\n        logger.warning(\"%s stopped running\", self.worker_name)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.get_message","title":"get_message  <code>async</code>","text":"<pre><code>get_message(timeout=0.5)\n</code></pre> PARAMETER DESCRIPTION <code>timeout</code> <p> TYPE: <code>float</code> DEFAULT: <code>0.5</code> </p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def get_message(self, timeout: float = 0.5) -&gt; MessageType | None:\n    try:\n        async with asyncio.timeout(timeout):\n            return await self._queue.get()\n    except asyncio.TimeoutError:\n        return None\n    except (asyncio.CancelledError, RuntimeError):\n        if not self.is_stopping():\n            raise\n    return None\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.queue_size","title":"queue_size","text":"<pre><code>queue_size()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def queue_size(self) -&gt; int:\n    return self._queue.qsize()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.run","title":"run  <code>async</code>","text":"<pre><code>run()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def run(self) -&gt; None:\n    with self.start_running():\n        while not self.is_stopping():\n            message = await self.get_message()\n            if message is not None:\n                await self.dispatcher.dispatch(message)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers","title":"fluid.utils.worker.Workers","text":"<pre><code>Workers(\n    *workers,\n    name=\"\",\n    stopping_grace_period=STOPPING_GRACE_PERIOD\n)\n</code></pre> <p>               Bases: <code>MultipleWorkers</code></p> <p>A worker managing several workers</p> PARAMETER DESCRIPTION <code>*workers</code> <p> TYPE: <code>Worker</code> DEFAULT: <code>()</code> </p> <code>name</code> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>stopping_grace_period</code> <p> TYPE: <code>int</code> DEFAULT: <code>STOPPING_GRACE_PERIOD</code> </p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def __init__(\n    self,\n    *workers: Worker,\n    name: str = \"\",\n    stopping_grace_period: int = settings.STOPPING_GRACE_PERIOD,\n) -&gt; None:\n    super().__init__(\n        *workers, name=name, stopping_grace_period=stopping_grace_period\n    )\n    self._workers_task: asyncio.Task | None = None\n    self._delayed_callbacks: list[\n        tuple[Callable[[], None], float, float, float]\n    ] = []\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.worker_name","title":"worker_name  <code>property</code>","text":"<pre><code>worker_name\n</code></pre> <p>The name of the worker</p>"},{"location":"reference/workers/#fluid.utils.worker.Workers.num_workers","title":"num_workers  <code>property</code>","text":"<pre><code>num_workers\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.running","title":"running  <code>property</code>","text":"<pre><code>running\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.status","title":"status  <code>async</code>","text":"<pre><code>status()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def status(self) -&gt; dict:\n    return await self._workers.status()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.gracefully_stop","title":"gracefully_stop","text":"<pre><code>gracefully_stop()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def gracefully_stop(self) -&gt; None:\n    self._workers.gracefully_stop()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.is_running","title":"is_running","text":"<pre><code>is_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_running(self) -&gt; bool:\n    return self._running\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.is_stopping","title":"is_stopping","text":"<pre><code>is_stopping()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_stopping(self) -&gt; bool:\n    return self._workers.is_stopping()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.start_running","title":"start_running","text":"<pre><code>start_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>@contextmanager\ndef start_running(self) -&gt; Generator:\n    if self._running:\n        raise RuntimeError(\"Worker is already running\")\n    self._running = True\n    try:\n        logger.info(\"%s started running\", self.worker_name)\n        yield\n    finally:\n        self._running = False\n        logger.warning(\"%s stopped running\", self.worker_name)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.create_task","title":"create_task","text":"<pre><code>create_task(worker)\n</code></pre> PARAMETER DESCRIPTION <code>worker</code> <p> TYPE: <code>Worker</code> </p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def create_task(self, worker: Worker) -&gt; asyncio.Task:\n    return asyncio.create_task(\n        self._run_worker(worker), name=f\"{self.worker_name}-{worker.worker_name}\"\n    )\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.on_shutdown","title":"on_shutdown  <code>async</code>","text":"<pre><code>on_shutdown()\n</code></pre> <p>called after the workers are stopped</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def on_shutdown(self) -&gt; None:\n    \"\"\"called after the workers are stopped\"\"\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.shutdown","title":"shutdown  <code>async</code>","text":"<pre><code>shutdown()\n</code></pre> <p>shutdown the workers</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def shutdown(self) -&gt; None:\n    \"\"\"shutdown the workers\"\"\"\n    if self._has_shutdown:\n        return\n    self._has_shutdown = True\n    logger.warning(\n        \"gracefully stopping %d workers: %s\",\n        self.num_workers,\n        \", \".join(w.worker_name for w in self._workers.workers),\n    )\n    self.gracefully_stop()\n    try:\n        async with asyncio.timeout(self._stopping_grace_period):\n            await self.wait_for_exit()\n        await self.on_shutdown()\n        return\n    except asyncio.TimeoutError:\n        logger.warning(\n            \"could not stop workers %s gracefully after %s\"\n            \" seconds - force shutdown\",\n            \", \".join(\n                task.get_name() for task in self._workers.tasks if not task.done()\n            ),\n            self._stopping_grace_period,\n        )\n    except asyncio.CancelledError:\n        pass\n    self._force_shutdown = True\n    self._workers.cancel()\n    try:\n        await self.wait_for_exit()\n    except asyncio.CancelledError:\n        pass\n    await self.on_shutdown()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.bail_out","title":"bail_out","text":"<pre><code>bail_out(reason, code=1)\n</code></pre> PARAMETER DESCRIPTION <code>reason</code> <p> TYPE: <code>str</code> </p> <code>code</code> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def bail_out(self, reason: str, code: int = 1) -&gt; None:\n    self.gracefully_stop()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.safe_run","title":"safe_run  <code>async</code>","text":"<pre><code>safe_run()\n</code></pre> <p>Context manager to run a worker safely</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>@asynccontextmanager\nasync def safe_run(self) -&gt; AsyncGenerator:\n    \"\"\"Context manager to run a worker safely\"\"\"\n    try:\n        yield\n    except asyncio.CancelledError:\n        if self._force_shutdown:\n            # we are shutting down, this is expected\n            pass\n        raise\n    except Exception as e:\n        reason = f\"unhandled exception while running workers: {e}\"\n        logger.exception(reason)\n        asyncio.get_event_loop().call_soon(self.bail_out, reason, 2)\n    else:\n        # worker finished without error\n        # make sure we are shutting down\n        asyncio.get_event_loop().call_soon(self.bail_out, \"worker exit\", 1)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.add_workers","title":"add_workers","text":"<pre><code>add_workers(*workers)\n</code></pre> <p>add workers to the workers</p> PARAMETER DESCRIPTION <code>*workers</code> <p> TYPE: <code>Worker</code> DEFAULT: <code>()</code> </p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def add_workers(self, *workers: Worker) -&gt; None:\n    \"\"\"add workers to the workers\"\"\"\n    workers_, _ = self._workers.workers_tasks()\n    for worker in workers:\n        if worker not in workers_:\n            workers_.append(worker)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.run","title":"run  <code>async</code>","text":"<pre><code>run()\n</code></pre> <p>run the workers</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def run(self) -&gt; None:\n    \"\"\"run the workers\"\"\"\n    with self.start_running():\n        async with self.safe_run():\n            workers, _ = self._workers.workers_tasks()\n            self._workers.workers = tuple(workers)\n            self._workers.tasks = tuple(\n                self.create_task(worker) for worker in workers\n            )\n            await asyncio.gather(*self._workers.tasks)\n        await self.shutdown()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.wait_for_exit","title":"wait_for_exit  <code>async</code>","text":"<pre><code>wait_for_exit()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def wait_for_exit(self) -&gt; None:\n    if self._workers_task is not None:\n        await self._workers_task\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.remove_workers","title":"remove_workers","text":"<pre><code>remove_workers(*workers)\n</code></pre> <p>remove workers from the workers</p> PARAMETER DESCRIPTION <code>*workers</code> <p> TYPE: <code>Worker</code> DEFAULT: <code>()</code> </p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def remove_workers(self, *workers: Worker) -&gt; None:\n    \"remove workers from the workers\"\n    workers_, _ = self._workers.workers_tasks()\n    for worker in workers:\n        try:\n            workers_.remove(worker)\n        except ValueError:\n            pass\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.startup","title":"startup  <code>async</code>","text":"<pre><code>startup()\n</code></pre> <p>start the workers</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def startup(self) -&gt; None:\n    \"\"\"start the workers\"\"\"\n    if self._workers_task is None:\n        self._workers_task = asyncio.create_task(self.run(), name=self.worker_name)\n        for args in self._delayed_callbacks:\n            self._delayed_callback(*args)\n        self._delayed_callbacks = []\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.register_callback","title":"register_callback","text":"<pre><code>register_callback(\n    callback, seconds, jitter=0.0, periodic=False\n)\n</code></pre> <p>Register a callback</p> <p>The callback can be periodic or not.</p> PARAMETER DESCRIPTION <code>callback</code> <p> TYPE: <code>Callable[[], None]</code> </p> <code>seconds</code> <p> TYPE: <code>float</code> </p> <code>jitter</code> <p> TYPE: <code>float</code> DEFAULT: <code>0.0</code> </p> <code>periodic</code> <p> TYPE: <code>bool | float</code> DEFAULT: <code>False</code> </p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def register_callback(\n    self,\n    callback: Callable[[], None],\n    seconds: float,\n    jitter: float = 0.0,\n    periodic: bool | float = False,\n) -&gt; None:\n    \"\"\"Register a callback\n\n    The callback can be periodic or not.\n    \"\"\"\n    if periodic is True:\n        periodic_float = seconds\n    elif periodic is False:\n        periodic_float = 0.0\n    else:\n        periodic_float = periodic\n    if not self.running:\n        self._delayed_callbacks.append((callback, seconds, jitter, periodic_float))\n    else:\n        self._delayed_callback(callback, seconds, jitter, periodic_float)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.DynamicWorkers","title":"fluid.utils.worker.DynamicWorkers","text":"<pre><code>DynamicWorkers(\n    *workers,\n    name=\"\",\n    heartbeat=0.1,\n    stopping_grace_period=STOPPING_GRACE_PERIOD\n)\n</code></pre> <p>               Bases: <code>MultipleWorkers</code></p> PARAMETER DESCRIPTION <code>*workers</code> <p> TYPE: <code>Worker</code> DEFAULT: <code>()</code> </p> <code>name</code> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>heartbeat</code> <p> TYPE: <code>float | int</code> DEFAULT: <code>0.1</code> </p> <code>stopping_grace_period</code> <p> TYPE: <code>int</code> DEFAULT: <code>STOPPING_GRACE_PERIOD</code> </p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def __init__(\n    self,\n    *workers: Worker,\n    name: str = \"\",\n    heartbeat: float | int = 0.1,\n    stopping_grace_period: int = settings.STOPPING_GRACE_PERIOD,\n) -&gt; None:\n    super().__init__(name)\n    self._heartbeat = heartbeat\n    self._workers = WorkerTasks()\n    self._has_shutdown = False\n    self._force_shutdown = False\n    self._stopping_grace_period = stopping_grace_period\n    self.add_workers(*workers)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.DynamicWorkers.worker_name","title":"worker_name  <code>property</code>","text":"<pre><code>worker_name\n</code></pre> <p>The name of the worker</p>"},{"location":"reference/workers/#fluid.utils.worker.DynamicWorkers.num_workers","title":"num_workers  <code>property</code>","text":"<pre><code>num_workers\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.DynamicWorkers.status","title":"status  <code>async</code>","text":"<pre><code>status()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def status(self) -&gt; dict:\n    return await self._workers.status()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.DynamicWorkers.gracefully_stop","title":"gracefully_stop","text":"<pre><code>gracefully_stop()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def gracefully_stop(self) -&gt; None:\n    self._workers.gracefully_stop()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.DynamicWorkers.is_running","title":"is_running","text":"<pre><code>is_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_running(self) -&gt; bool:\n    return self._running\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.DynamicWorkers.is_stopping","title":"is_stopping","text":"<pre><code>is_stopping()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_stopping(self) -&gt; bool:\n    return self._workers.is_stopping()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.DynamicWorkers.start_running","title":"start_running","text":"<pre><code>start_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>@contextmanager\ndef start_running(self) -&gt; Generator:\n    if self._running:\n        raise RuntimeError(\"Worker is already running\")\n    self._running = True\n    try:\n        logger.info(\"%s started running\", self.worker_name)\n        yield\n    finally:\n        self._running = False\n        logger.warning(\"%s stopped running\", self.worker_name)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.DynamicWorkers.create_task","title":"create_task","text":"<pre><code>create_task(worker)\n</code></pre> PARAMETER DESCRIPTION <code>worker</code> <p> TYPE: <code>Worker</code> </p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def create_task(self, worker: Worker) -&gt; asyncio.Task:\n    return asyncio.create_task(\n        self._run_worker(worker), name=f\"{self.worker_name}-{worker.worker_name}\"\n    )\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.DynamicWorkers.on_shutdown","title":"on_shutdown  <code>async</code>","text":"<pre><code>on_shutdown()\n</code></pre> <p>called after the workers are stopped</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def on_shutdown(self) -&gt; None:\n    \"\"\"called after the workers are stopped\"\"\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.DynamicWorkers.shutdown","title":"shutdown  <code>async</code>","text":"<pre><code>shutdown()\n</code></pre> <p>shutdown the workers</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def shutdown(self) -&gt; None:\n    \"\"\"shutdown the workers\"\"\"\n    if self._has_shutdown:\n        return\n    self._has_shutdown = True\n    logger.warning(\n        \"gracefully stopping %d workers: %s\",\n        self.num_workers,\n        \", \".join(w.worker_name for w in self._workers.workers),\n    )\n    self.gracefully_stop()\n    try:\n        async with asyncio.timeout(self._stopping_grace_period):\n            await self.wait_for_exit()\n        await self.on_shutdown()\n        return\n    except asyncio.TimeoutError:\n        logger.warning(\n            \"could not stop workers %s gracefully after %s\"\n            \" seconds - force shutdown\",\n            \", \".join(\n                task.get_name() for task in self._workers.tasks if not task.done()\n            ),\n            self._stopping_grace_period,\n        )\n    except asyncio.CancelledError:\n        pass\n    self._force_shutdown = True\n    self._workers.cancel()\n    try:\n        await self.wait_for_exit()\n    except asyncio.CancelledError:\n        pass\n    await self.on_shutdown()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.DynamicWorkers.bail_out","title":"bail_out","text":"<pre><code>bail_out(reason, code=1)\n</code></pre> PARAMETER DESCRIPTION <code>reason</code> <p> TYPE: <code>str</code> </p> <code>code</code> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def bail_out(self, reason: str, code: int = 1) -&gt; None:\n    self.gracefully_stop()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.DynamicWorkers.safe_run","title":"safe_run  <code>async</code>","text":"<pre><code>safe_run()\n</code></pre> <p>Context manager to run a worker safely</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>@asynccontextmanager\nasync def safe_run(self) -&gt; AsyncGenerator:\n    \"\"\"Context manager to run a worker safely\"\"\"\n    try:\n        yield\n    except asyncio.CancelledError:\n        if self._force_shutdown:\n            # we are shutting down, this is expected\n            pass\n        raise\n    except Exception as e:\n        reason = f\"unhandled exception while running workers: {e}\"\n        logger.exception(reason)\n        asyncio.get_event_loop().call_soon(self.bail_out, reason, 2)\n    else:\n        # worker finished without error\n        # make sure we are shutting down\n        asyncio.get_event_loop().call_soon(self.bail_out, \"worker exit\", 1)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.DynamicWorkers.add_workers","title":"add_workers","text":"<pre><code>add_workers(*workers)\n</code></pre> <p>add workers to the workers</p> <p>They can be added while the workers are running.</p> PARAMETER DESCRIPTION <code>*workers</code> <p> TYPE: <code>Worker</code> DEFAULT: <code>()</code> </p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def add_workers(self, *workers: Worker) -&gt; None:\n    \"\"\"add workers to the workers\n\n    They can be added while the workers are running.\n    \"\"\"\n    workers_, tasks_ = self._workers.workers_tasks()\n    for worker in workers:\n        workers_.append(worker)\n        tasks_.append(self.create_task(worker))\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.DynamicWorkers.run","title":"run  <code>async</code>","text":"<pre><code>run()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def run(self) -&gt; None:\n    with self.start_running():\n        while not self.is_stopping():\n            for worker, task in zip(self._workers.workers, self._workers.tasks):\n                if worker.is_stopping() or task.done():\n                    break\n            await asyncio.sleep(self._heartbeat)\n        await self.shutdown()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.DynamicWorkers.wait_for_exit","title":"wait_for_exit  <code>async</code>","text":"<pre><code>wait_for_exit()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def wait_for_exit(self) -&gt; None:\n    await asyncio.gather(*self._workers.tasks)\n</code></pre>"},{"location":"tutorials/","title":"Tutorials","text":"<p>The step-by-step guides, the how-to's, the recipes, and all the Aio Fluid parts you can use in your applications.</p>"},{"location":"tutorials/db/","title":"Async Database","text":"<p>The <code>fluid.db</code> module provides a simple asynchronous interface to interact with postgres databases. It is built on top of the sqlalchemy and asyncpg libraries.</p>"},{"location":"tutorials/db/#database","title":"Database","text":"<p>Create a database container with the <code>Database</code> class:</p> <pre><code>from fluid.db import Database\n\ndb = Database(\"postgresql+asyncpg://postgres:postgres@localhost:5432/fluid\")\n</code></pre> <p>Note the use of the <code>postgresql+asyncpg</code> driver in the connection string. THis is required to use the asyncpg driver.</p>"},{"location":"tutorials/dispatchers/","title":"Event Dispatchers","text":"<p>Event dispatchers are a way to decouple the event source from the event handler. This is useful when you want to have multiple handlers for the same event, or when you want to have a single handler for multiple events.</p> <pre><code>from fluid.utils.dispatcher import SimpleDispatcher\n\nsimple = SimpleDispatcher[Any]()\n\nsimple.dispatch(\"you can dispatch anything to this generic dispatcher\")\n</code></pre>"},{"location":"tutorials/task_app/","title":"Task Queue App","text":"<p>The <code>fluid.scheduler</code> module is a simple yet powerful distributed task producer (TaskScheduler) and consumer (TaskConsumer) system for executing tasks. The middleware for distributing tasks can be configured via the TaskBroker interface.</p> <p>A redis task broker is provided for convenience.</p>"},{"location":"tutorials/task_app/#tasks-consumer","title":"Tasks Consumer","text":"<p>Create a task consumer, register tasks from modules, and run the consumer.</p> <pre><code>import asyncio\nfrom typing import Any\nfrom fluid.scheduler import TaskConsumer\nimport task_module_a, task_module_b\n\n\ndef task_consumer(**kwargs: Any) -&gt; TaskConsumer:\n    consumer = TaskConsumer(**kwargs)\n    consumer.register_from_module(task_module_a)\n    consumer.register_from_module(task_module_b)\n    return consumer\n\n\nif __name__ == \"__main__\":\n    consumer = task_consumer()\n    asyncio.run(consumer.run())\n</code></pre>"},{"location":"tutorials/task_app/#fastapi-integration","title":"FastAPI Integration","text":"<p>The <code>TaskConsumer</code> can be integrated with FastAPI so that tasks can be queued via HTTP requests.</p> <pre><code>import uvicorn\nfrom fluid.scheduler.endpoints import setup_fastapi\n\nif __name__ == \"__main__\":\n    consumer = task_consumer()\n    app = setup_fastapi(consumer)\n    uvicorn.run(app)\n</code></pre> <p>You can test via the example provided</p> <pre><code>$ python -m examples.simple_fastapi\n</code></pre> <p>and check the openapi UI at http://127.0.0.1:8000/docs.</p>"},{"location":"tutorials/task_app/#task-app-command-line","title":"Task App Command Line","text":"<p>The TaskConsumer or TaskScheduler can be run with the command line tool to allow for an even richer API.</p> <pre><code>from fluid.scheduler.cli import TaskManagerCLI\n\nif __name__ == \"__main__\":\n    consumer = task_consumer()\n    TaskManagerCLI(setup_fastapi(consumer))()\n</code></pre> <p>This features requires to install the package with the <code>cli</code> extra.</p> <pre><code>$ pip install aio-fluid[cli]\n</code></pre> <pre><code>$ python -m examples.simple_cli\nUsage: python -m examples.simple_cli [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  exec   Execute a registered task\n  ls     List all tasks with their schedules\n  serve  Start app server\n</code></pre> <p>The command line tool provides a powerful interface to execute tasks, parameters are passed as optional arguments using the standard click interface.</p>"},{"location":"tutorials/task_broker/","title":"Task Broker","text":"<p>A TaskBroker needs to implement three abstract methods</p> <pre><code>  @abstractmethod\n  async def queue_task(self, task_run: TaskRun) -&gt; None:\n      \"\"\"Queue a task\"\"\"\n\n  @abstractmethod\n  async def get_task_run(self) -&gt; Optional[TaskRun]:\n      \"\"\"Get a Task run from the task queue\"\"\"\n\n  @abstractmethod\n  async def queue_length(self) -&gt; Dict[str, int]:\n      \"\"\"Length of task queues\"\"\"\n\n  @abstractmethod\n    async def update_task(self, task: Task, params: dict[str, Any]) -&gt; TaskInfo:\n        \"\"\"Update a task dynamic parameters\"\"\"\n\n  @abstractmethod\n  async def close(self) -&gt; None:\n      \"\"\"Close the broker on shutdown\"\"\"\n\n  @abstractmethod\n  def lock(self, name: str, timeout: float | None = None) -&gt; Lock:\n      \"\"\"Create a lock\"\"\"\n</code></pre> <p>The library ships a Redis broker for convenience.</p> <pre><code>from fluid.scheduler import Broker\n\nredis_broker = Broker.from_url(\"redis://localhost:6349\")\n</code></pre> <p>By default the broker uses the url provided in the <code>FLUID_BROKER_URL</code> environment variable and falls back to <code>redis://localhost:6349</code>.</p> <pre><code>broker = Broker.from_url()\nbroker.url == \"redis://localhost:6349\"\n</code></pre>"},{"location":"tutorials/task_queue/","title":"Tasks","text":"<p>Tasks are standard python async functions decorated with the @task decorator.</p> <pre><code>from fluid.scheduler import task, TaskRun\n\n@task\nasync def say_hi(ctx: TaskRun) -&gt; None:\n    print(\"Hi!\")\n</code></pre> <p>The TaskRun object is passed to the task function and contains the task metadata, including optional parameters, and the TaskManager.</p>"},{"location":"tutorials/task_queue/#task-parameters","title":"Task Parameters","text":"<p>It is possible to pass parameters to the task, to do so, create a pydantic model for the task parameters</p> <pre><code>from pydantic import BaseModel\n\nclass TaskParams(BaseModel):\n    name: str\n</code></pre> <p>and pass it to the <code>task</code> decorator</p> <pre><code>from fluid.scheduler import task, TaskRun\n\n@task\nasync def say_hi(ctx: TaskRun[TaskParams]) -&gt; None:\n    print(f\"Hi {ctx.params.name}!\")\n</code></pre>"},{"location":"tutorials/task_queue/#task-types","title":"Task Types","text":"<p>There are few types of tasks implemented, lets take a look at them.</p>"},{"location":"tutorials/task_queue/#io-bound-tasks","title":"IO Bound Tasks","text":"<p>They run concurrently with the TaskConsumer. They must perform non blocking IO operations (no heavy CPU bound operations that blocks the event loop).</p> <pre><code>from fluid.scheduler import task, TaskRun\nfrom pydantic import BaseModel\n\n\nclass Scrape(BaseModel):\n    url: str = \"https://\"\n\n\n@task\nasync def fecth_data(ctx: TaskRun[Scrape]) -&gt; None:\n    # fetch data\n    data = await http_cli.get(ctx.params.url)\n    data_id = await datastore_cli.stote(data)\n    # trigger another task\n    ctx.task_manager.queue(\"heavy_calculation\", data_id=data_id)\n</code></pre>"},{"location":"tutorials/task_queue/#cpu-bound-tasks","title":"CPU bound tasks","text":"<p>They run on a subprocess</p> <pre><code>from fluid.scheduler import task, TaskRun\n\n@task(cpu_bound=True)\nasync def heavy_calculation(ctx: TaskRun) -&gt; None:\n    data = await datastore_cli.get(ctx.params[\"data_id\"])\n    # perform some heavy calculation\n    ...\n    # trigger another task\n    ctx.task_manager.queue(\"fetch_data\")\n</code></pre>"},{"location":"tutorials/task_queue/#scheduled-tasks","title":"Scheduled Tasks","text":"<p>Both IO and CPU bound tasks can be periodically scheduled via the <code>schedule</code> keyword argument.</p> <p>There are two types of scheduling, the most common is the every function that takes a <code>timedelta</code> object.</p> <pre><code>import asyncio\nfrom datetime import timedelta\nfrom fluid.scheduler import task, TaskRun, every\n\n@task(schedule=every(timedelta(seconds=1)))\nasync def scheduled(ctx: TaskRun) -&gt; None:\n    await asyncio.sleep(0.1)\n</code></pre> <p>You can also use the crontab function to schedule tasks using cron expressions.</p> <pre><code>import asyncio\nfrom fluid.scheduler import task, TaskRun, crontab\n\n@task(schedule=crontab(hours='*/2'))\nasync def scheduled(ctx: TaskRun) -&gt; None:\n    await asyncio.sleep(0.1)\n</code></pre>"}]}