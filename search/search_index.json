{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Aio Fluid</p> <p>Async utilities for backend python services developed by Quantmind.</p> <p> </p> <p>Documentation: https://quantmind.github.io/aio-fluid</p> <p>Source Code: https://github.com/quantmind/aio-fluid</p>"},{"location":"#installation","title":"Installation","text":"<p>This is a simple python package you can install via pip:</p> <pre><code>pip install aio-fluid\n</code></pre> <p>To install all the dependencies:</p> <p><pre><code>pip install aio-fluid[cli, db, http, log]\n</code></pre> this includes the following extra dependencies:</p> <ul> <li><code>cli</code> for the command line interface using click and rich</li> <li><code>db</code> for database support with asyncpg and sqlalchemy</li> <li><code>http</code> for http client support with httpx and aiohttp</li> <li><code>log</code> for JSON logging support with python-json-logger</li> </ul>"},{"location":"#development","title":"Development","text":"<p>You can run the examples via</p> <pre><code>poetry run python -m examples.main\n</code></pre>"},{"location":"reference/","title":"Introduction","text":"<p>Here's the reference or code API, the classes, functions, parameters, attributes, and all the <code>aio-fluid</code> parts you can use in your applications.</p>"},{"location":"reference/dispatchers/","title":"Event Dispatchers","text":"<p>A set of classes for dispatching events, they can be imported from <code>fluid.utils.dispatcher</code>:</p> <pre><code>from fluid.utils.dispatcher import Dispatcher\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.BaseDispatcher","title":"fluid.utils.dispatcher.BaseDispatcher","text":"<pre><code>BaseDispatcher()\n</code></pre> <p>               Bases: <code>Generic[MessageType, MessageHandlerType]</code>, <code>ABC</code></p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._msg_handlers: defaultdict[str, dict[str, MessageHandlerType]] = (\n        defaultdict(\n            dict,\n        )\n    )\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.BaseDispatcher.register_handler","title":"register_handler","text":"<pre><code>register_handler(event, handler)\n</code></pre> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def register_handler(\n    self,\n    event: Event | str,\n    handler: MessageHandlerType,\n) -&gt; MessageHandlerType | None:\n    event = Event.from_string_or_event(event)\n    previous = self._msg_handlers[event.type].get(event.tag)\n    self._msg_handlers[event.type][event.tag] = handler\n    return previous\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.BaseDispatcher.unregister_handler","title":"unregister_handler","text":"<pre><code>unregister_handler(event)\n</code></pre> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def unregister_handler(self, event: Event | str) -&gt; MessageHandlerType | None:\n    event = Event.from_string_or_event(event)\n    return self._msg_handlers[event.type].pop(event.tag, None)\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.BaseDispatcher.get_handlers","title":"get_handlers","text":"<pre><code>get_handlers(message)\n</code></pre> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def get_handlers(\n    self,\n    message: MessageType,\n) -&gt; dict[str, MessageHandlerType] | None:\n    message_type = str(self.message_type(message))\n    return self._msg_handlers.get(message_type)\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.BaseDispatcher.message_type","title":"message_type  <code>abstractmethod</code>","text":"<pre><code>message_type(message)\n</code></pre> <p>return the message type</p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>@abstractmethod\ndef message_type(self, message: MessageType) -&gt; str:\n    \"\"\"return the message type\"\"\"\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.Dispatcher","title":"fluid.utils.dispatcher.Dispatcher","text":"<pre><code>Dispatcher()\n</code></pre> <p>               Bases: <code>BaseDispatcher[MessageType, Callable[[MessageType], None]]</code></p> <p>Dispatcher for sync handlers</p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._msg_handlers: defaultdict[str, dict[str, MessageHandlerType]] = (\n        defaultdict(\n            dict,\n        )\n    )\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.Dispatcher.register_handler","title":"register_handler","text":"<pre><code>register_handler(event, handler)\n</code></pre> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def register_handler(\n    self,\n    event: Event | str,\n    handler: MessageHandlerType,\n) -&gt; MessageHandlerType | None:\n    event = Event.from_string_or_event(event)\n    previous = self._msg_handlers[event.type].get(event.tag)\n    self._msg_handlers[event.type][event.tag] = handler\n    return previous\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.Dispatcher.unregister_handler","title":"unregister_handler","text":"<pre><code>unregister_handler(event)\n</code></pre> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def unregister_handler(self, event: Event | str) -&gt; MessageHandlerType | None:\n    event = Event.from_string_or_event(event)\n    return self._msg_handlers[event.type].pop(event.tag, None)\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.Dispatcher.get_handlers","title":"get_handlers","text":"<pre><code>get_handlers(message)\n</code></pre> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def get_handlers(\n    self,\n    message: MessageType,\n) -&gt; dict[str, MessageHandlerType] | None:\n    message_type = str(self.message_type(message))\n    return self._msg_handlers.get(message_type)\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.Dispatcher.message_type","title":"message_type  <code>abstractmethod</code>","text":"<pre><code>message_type(message)\n</code></pre> <p>return the message type</p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>@abstractmethod\ndef message_type(self, message: MessageType) -&gt; str:\n    \"\"\"return the message type\"\"\"\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.Dispatcher.dispatch","title":"dispatch","text":"<pre><code>dispatch(message)\n</code></pre> <p>dispatch the message</p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def dispatch(self, message: MessageType) -&gt; int:\n    \"\"\"dispatch the message\"\"\"\n    handlers = self.get_handlers(message)\n    if handlers:\n        for handler in handlers.values():\n            handler(message)\n    return len(handlers or ())\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.AsyncDispatcher","title":"fluid.utils.dispatcher.AsyncDispatcher","text":"<pre><code>AsyncDispatcher()\n</code></pre> <p>               Bases: <code>BaseDispatcher[MessageType, Callable[[MessageType], Awaitable[None]]]</code></p> <p>Dispatcher for async handlers</p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._msg_handlers: defaultdict[str, dict[str, MessageHandlerType]] = (\n        defaultdict(\n            dict,\n        )\n    )\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.AsyncDispatcher.register_handler","title":"register_handler","text":"<pre><code>register_handler(event, handler)\n</code></pre> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def register_handler(\n    self,\n    event: Event | str,\n    handler: MessageHandlerType,\n) -&gt; MessageHandlerType | None:\n    event = Event.from_string_or_event(event)\n    previous = self._msg_handlers[event.type].get(event.tag)\n    self._msg_handlers[event.type][event.tag] = handler\n    return previous\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.AsyncDispatcher.unregister_handler","title":"unregister_handler","text":"<pre><code>unregister_handler(event)\n</code></pre> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def unregister_handler(self, event: Event | str) -&gt; MessageHandlerType | None:\n    event = Event.from_string_or_event(event)\n    return self._msg_handlers[event.type].pop(event.tag, None)\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.AsyncDispatcher.get_handlers","title":"get_handlers","text":"<pre><code>get_handlers(message)\n</code></pre> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>def get_handlers(\n    self,\n    message: MessageType,\n) -&gt; dict[str, MessageHandlerType] | None:\n    message_type = str(self.message_type(message))\n    return self._msg_handlers.get(message_type)\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.AsyncDispatcher.message_type","title":"message_type  <code>abstractmethod</code>","text":"<pre><code>message_type(message)\n</code></pre> <p>return the message type</p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>@abstractmethod\ndef message_type(self, message: MessageType) -&gt; str:\n    \"\"\"return the message type\"\"\"\n</code></pre>"},{"location":"reference/dispatchers/#fluid.utils.dispatcher.AsyncDispatcher.dispatch","title":"dispatch  <code>async</code>","text":"<pre><code>dispatch(message)\n</code></pre> <p>Dispatch the message and wait for all handlers to complete</p> Source code in <code>fluid/utils/dispatcher.py</code> <pre><code>async def dispatch(self, message: MessageType) -&gt; int:\n    \"\"\"Dispatch the message and wait for all handlers to complete\"\"\"\n    handlers = self.get_handlers(message)\n    if handlers:\n        await asyncio.gather(*[handler(message) for handler in handlers.values()])\n    return len(handlers or ())\n</code></pre>"},{"location":"reference/task_broker/","title":"Task Broker","text":"<p>It can be imported from <code>fluid.scheduler</code>:</p> <pre><code>from fastapi.scheduler import TaskBroker\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker","title":"fluid.scheduler.TaskBroker","text":"<pre><code>TaskBroker(url)\n</code></pre> <p>               Bases: <code>ABC</code></p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>def __init__(self, url: URL) -&gt; None:\n    self.url: URL = url\n    self.registry: TaskRegistry = TaskRegistry()\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url = url\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.registry","title":"registry  <code>instance-attribute</code>","text":"<pre><code>registry = TaskRegistry()\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.task_queue_names","title":"task_queue_names  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>task_queue_names\n</code></pre> <p>Names of the task queues</p>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.queue_task","title":"queue_task  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>queue_task(task_run)\n</code></pre> <p>Queue a task</p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>@abstractmethod\nasync def queue_task(self, task_run: TaskRun) -&gt; None:\n    \"\"\"Queue a task\"\"\"\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.get_task_run","title":"get_task_run  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get_task_run(task_manager)\n</code></pre> <p>Get a Task run from the task queue</p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>@abstractmethod\nasync def get_task_run(self, task_manager: TaskManager) -&gt; TaskRun | None:\n    \"\"\"Get a Task run from the task queue\"\"\"\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.queue_length","title":"queue_length  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>queue_length()\n</code></pre> <p>Length of task queues</p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>@abstractmethod\nasync def queue_length(self) -&gt; dict[str, int]:\n    \"\"\"Length of task queues\"\"\"\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.get_tasks_info","title":"get_tasks_info  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get_tasks_info(*task_names)\n</code></pre> <p>List of TaskInfo objects</p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>@abstractmethod\nasync def get_tasks_info(self, *task_names: str) -&gt; list[TaskInfo]:\n    \"\"\"List of TaskInfo objects\"\"\"\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.update_task","title":"update_task  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>update_task(task, params)\n</code></pre> <p>Update a task dynamic parameters</p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>@abstractmethod\nasync def update_task(self, task: Task, params: dict[str, Any]) -&gt; TaskInfo:\n    \"\"\"Update a task dynamic parameters\"\"\"\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.close","title":"close  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>close()\n</code></pre> <p>Close the broker on shutdown</p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>@abstractmethod\nasync def close(self) -&gt; None:\n    \"\"\"Close the broker on shutdown\"\"\"\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.lock","title":"lock  <code>abstractmethod</code>","text":"<pre><code>lock(name, timeout=None)\n</code></pre> <p>Create a lock</p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>@abstractmethod\ndef lock(self, name: str, timeout: float | None = None) -&gt; Lock:\n    \"\"\"Create a lock\"\"\"\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.new_uuid","title":"new_uuid","text":"<pre><code>new_uuid()\n</code></pre> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>def new_uuid(self) -&gt; str:\n    return uuid4().hex\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.filter_tasks","title":"filter_tasks  <code>async</code>","text":"<pre><code>filter_tasks(scheduled=None, enabled=None)\n</code></pre> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>async def filter_tasks(\n    self,\n    scheduled: bool | None = None,\n    enabled: bool | None = None,\n) -&gt; list[Task]:\n    task_info = await self.get_tasks_info()\n    task_map = {info.name: info for info in task_info}\n    tasks = []\n    for task in self.registry.values():\n        if scheduled is not None and bool(task.schedule) is not scheduled:\n            continue\n        if enabled is not None and task_map[task.name].enabled is not enabled:\n            continue\n        tasks.append(task)\n    return tasks\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.task_from_registry","title":"task_from_registry","text":"<pre><code>task_from_registry(task)\n</code></pre> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>def task_from_registry(self, task: str | Task) -&gt; Task:\n    if isinstance(task, Task):\n        self.register_task(task)\n        return task\n    else:\n        if task_ := self.registry.get(task):\n            return task_\n        raise UnknownTaskError(task)\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.register_task","title":"register_task","text":"<pre><code>register_task(task)\n</code></pre> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>def register_task(self, task: Task) -&gt; None:\n    self.registry[task.name] = task\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.enable_task","title":"enable_task  <code>async</code>","text":"<pre><code>enable_task(task, enable=True)\n</code></pre> <p>Enable or disable a registered task</p> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>async def enable_task(self, task: str | Task, enable: bool = True) -&gt; TaskInfo:\n    \"\"\"Enable or disable a registered task\"\"\"\n    task_ = self.task_from_registry(task)\n    return await self.update_task(task_, dict(enabled=enable))\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.from_url","title":"from_url  <code>classmethod</code>","text":"<pre><code>from_url(url='')\n</code></pre> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>@classmethod\ndef from_url(cls, url: str = \"\") -&gt; TaskBroker:\n    p = URL(url or broker_url_from_env())\n    if factory := _brokers.get(p.scheme):\n        return factory(p)\n    raise RuntimeError(f\"Invalid broker {p}\")\n</code></pre>"},{"location":"reference/task_broker/#fluid.scheduler.TaskBroker.register_broker","title":"register_broker  <code>classmethod</code>","text":"<pre><code>register_broker(name, factory)\n</code></pre> Source code in <code>fluid/scheduler/broker.py</code> <pre><code>@classmethod\ndef register_broker(cls, name: str, factory: type[TaskBroker]) -&gt; None:\n    _brokers[name] = factory\n</code></pre>"},{"location":"reference/task_manager/","title":"Task Manager","text":"<p>It can be imported from <code>fluid.scheduler</code>:</p> <pre><code>from fastapi.scheduler import TaskManager\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager","title":"fluid.scheduler.TaskManager","text":"<pre><code>TaskManager(**kwargs)\n</code></pre> <p>The task manager is the main entry point for managing tasks</p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def __init__(self, **kwargs: Any) -&gt; None:\n    self.state: dict[str, Any] = {}\n    self.config: TaskManagerConfig = TaskManagerConfig(**kwargs)\n    self.dispatcher: Annotated[\n        TaskDispatcher,\n        Doc(\n            \"\"\"\n            A dispatcher of task run events.\n\n            Register handlers to listen for task run events.\n            \"\"\"\n        ),\n    ] = TaskDispatcher()\n    self.broker = TaskBroker.from_url(self.config.broker_url)\n    self._stack = AsyncExitStack()\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.state","title":"state  <code>instance-attribute</code>","text":"<pre><code>state = {}\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config = TaskManagerConfig(**kwargs)\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.dispatcher","title":"dispatcher  <code>instance-attribute</code>","text":"<pre><code>dispatcher = TaskDispatcher()\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.broker","title":"broker  <code>instance-attribute</code>","text":"<pre><code>broker = from_url(broker_url)\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.registry","title":"registry  <code>property</code>","text":"<pre><code>registry\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.type","title":"type  <code>property</code>","text":"<pre><code>type\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.enter_async_context","title":"enter_async_context  <code>async</code>","text":"<pre><code>enter_async_context(cm)\n</code></pre> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>async def enter_async_context(self, cm: Any) -&gt; Any:\n    return await self._stack.enter_async_context(cm)\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.execute","title":"execute  <code>async</code>","text":"<pre><code>execute(task, **params)\n</code></pre> <p>Execute a task and wait for it to finish</p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>async def execute(self, task: Task | str, **params: Any) -&gt; TaskRun:\n    \"\"\"Execute a task and wait for it to finish\"\"\"\n    task_run = self.create_task_run(task, **params)\n    await task_run.execute()\n    return task_run\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.on_shutdown","title":"on_shutdown  <code>async</code>","text":"<pre><code>on_shutdown()\n</code></pre> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>async def on_shutdown(self) -&gt; None:\n    await self.broker.close()\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.execute_sync","title":"execute_sync","text":"<pre><code>execute_sync(task, **params)\n</code></pre> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def execute_sync(self, task: Task | str, **params: Any) -&gt; TaskRun:\n    return asyncio.run(self._execute_and_exit(task, **params))\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.register_task","title":"register_task","text":"<pre><code>register_task(task)\n</code></pre> <p>Register a task with the task manager</p> <p>Only tasks registered can be executed by a task manager</p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def register_task(self, task: Task) -&gt; None:\n    \"\"\"Register a task with the task manager\n\n    Only tasks registered can be executed by a task manager\n    \"\"\"\n    self.broker.register_task(task)\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.queue","title":"queue  <code>async</code>","text":"<pre><code>queue(task, priority=None, **params)\n</code></pre> <p>Queue a task for execution</p> <p>This methods fires two events:</p> <ul> <li>queue: when the task is about to be queued</li> <li>queued: after the task is queued</li> </ul> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>async def queue(\n    self,\n    task: str | Task,\n    priority: TaskPriority | None = None,\n    **params: Any,\n) -&gt; TaskRun:\n    \"\"\"Queue a task for execution\n\n    This methods fires two events:\n\n    - queue: when the task is about to be queued\n    - queued: after the task is queued\n    \"\"\"\n    task_run = self.create_task_run(task, priority=priority, **params)\n    self.dispatcher.dispatch(task_run)\n    task_run.set_state(TaskState.queued)\n    await self.broker.queue_task(task_run)\n    return task_run\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.create_task_run","title":"create_task_run","text":"<pre><code>create_task_run(task, run_id='', priority=None, **params)\n</code></pre> <p>Create a TaskRun in <code>init</code> state</p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def create_task_run(\n    self,\n    task: str | Task,\n    run_id: str = \"\",\n    priority: TaskPriority | None = None,\n    **params: Any,\n) -&gt; TaskRun:\n    \"\"\"Create a TaskRun in `init` state\"\"\"\n    if isinstance(task, str):\n        task = self.broker.task_from_registry(task)\n    run_id = run_id or self.broker.new_uuid()\n    return TaskRun(\n        id=run_id,\n        task=task,\n        priority=priority or task.priority,\n        params=params,\n        task_manager=self,\n    )\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.register_from_module","title":"register_from_module","text":"<pre><code>register_from_module(module)\n</code></pre> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def register_from_module(self, module: Any) -&gt; None:\n    for name in dir(module):\n        if name.startswith(\"_\"):\n            continue\n        if isinstance(obj := getattr(module, name), Task):\n            self.register_task(obj)\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.register_from_dict","title":"register_from_dict","text":"<pre><code>register_from_dict(data)\n</code></pre> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def register_from_dict(self, data: dict) -&gt; None:\n    for name, obj in data.items():\n        if name.startswith(\"_\"):\n            continue\n        if isinstance(obj, Task):\n            self.register_task(obj)\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.register_async_handler","title":"register_async_handler","text":"<pre><code>register_async_handler(event, handler)\n</code></pre> <p>Register an async handler for a given event</p> <p>This method is a no op for a TaskManager that is not a worker</p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def register_async_handler(self, event: str, handler: AsyncHandler) -&gt; None:\n    \"\"\"Register an async handler for a given event\n\n    This method is a no op for a TaskManager that is not a worker\n    \"\"\"\n</code></pre>"},{"location":"reference/task_manager/#fluid.scheduler.TaskManager.unregister_async_handler","title":"unregister_async_handler","text":"<pre><code>unregister_async_handler(event)\n</code></pre> <p>Unregister an async handler for a given event</p> <p>This method is a no op for a TaskManager that is not a worker</p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def unregister_async_handler(self, event: Event | str) -&gt; AsyncHandler | None:\n    \"\"\"Unregister an async handler for a given event\n\n    This method is a no op for a TaskManager that is not a worker\n    \"\"\"\n    return None\n</code></pre>"},{"location":"reference/task_run/","title":"Task Run","text":"<p>It can be imported from <code>fluid.scheduler</code>:</p> <pre><code>from fastapi.scheduler import TaskRun\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun","title":"fluid.scheduler.TaskRun","text":"<p>               Bases: <code>BaseModel</code></p> <p>A TaskRun contains all the data generated by a Task run</p>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.task","title":"task  <code>instance-attribute</code>","text":"<pre><code>task\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.priority","title":"priority  <code>instance-attribute</code>","text":"<pre><code>priority\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.params","title":"params  <code>instance-attribute</code>","text":"<pre><code>params\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.state","title":"state  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>state = init\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.task_manager","title":"task_manager  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>task_manager = Field(exclude=True, repr=False)\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.queued","title":"queued  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>queued = None\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.start","title":"start  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>start = None\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.end","title":"end  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>end = None\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.logger","title":"logger  <code>property</code>","text":"<pre><code>logger\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.in_queue","title":"in_queue  <code>property</code>","text":"<pre><code>in_queue\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.duration","title":"duration  <code>property</code>","text":"<pre><code>duration\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.duration_ms","title":"duration_ms  <code>property</code>","text":"<pre><code>duration_ms\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.total","title":"total  <code>property</code>","text":"<pre><code>total\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.name","title":"name  <code>property</code>","text":"<pre><code>name\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.name_id","title":"name_id  <code>property</code>","text":"<pre><code>name_id\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.is_done","title":"is_done  <code>property</code>","text":"<pre><code>is_done\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.is_failure","title":"is_failure  <code>property</code>","text":"<pre><code>is_failure\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.execute","title":"execute  <code>async</code>","text":"<pre><code>execute()\n</code></pre> Source code in <code>fluid/scheduler/models.py</code> <pre><code>async def execute(self) -&gt; None:\n    try:\n        self.set_state(TaskState.running)\n        await self.task.executor(self)\n    except Exception:\n        self.set_state(TaskState.failure)\n        raise\n    else:\n        self.set_state(TaskState.success)\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.serialize_task","title":"serialize_task","text":"<pre><code>serialize_task(task, _info)\n</code></pre> Source code in <code>fluid/scheduler/models.py</code> <pre><code>@field_serializer(\"task\")\ndef serialize_task(self, task: Task, _info: Any) -&gt; str:\n    return task.name\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.params_dump_json","title":"params_dump_json","text":"<pre><code>params_dump_json()\n</code></pre> Source code in <code>fluid/scheduler/models.py</code> <pre><code>def params_dump_json(self) -&gt; str:\n    return self.task.params_dump_json(self.params)\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.set_state","title":"set_state","text":"<pre><code>set_state(state, state_time=None)\n</code></pre> Source code in <code>fluid/scheduler/models.py</code> <pre><code>def set_state(\n    self,\n    state: TaskState,\n    state_time: datetime | None = None,\n) -&gt; None:\n    if self.state == state:\n        return\n    state_time = as_utc(state_time)\n    match (self.state, state):\n        case (TaskState.init, TaskState.queued):\n            self.queued = state_time\n            self.state = state\n            self._dispatch()\n        case (TaskState.init, _):\n            self.set_state(TaskState.queued, state_time)\n            self.set_state(state, state_time)\n        case (TaskState.queued, TaskState.running):\n            self.start = state_time\n            self.state = state\n            self._dispatch()\n        case (\n            TaskState.queued,\n            TaskState.success\n            | TaskState.aborted\n            | TaskState.rate_limited\n            | TaskState.failure,\n        ):\n            self.set_state(TaskState.running, state_time)\n            self.set_state(state, state_time)\n        case (\n            TaskState.running,\n            TaskState.success\n            | TaskState.aborted\n            | TaskState.rate_limited\n            | TaskState.failure,\n        ):\n            self.end = state_time\n            self.state = state\n            self._dispatch()\n        case _:\n            raise TaskRunError(f\"invalid state transition {self.state} -&gt; {state}\")\n</code></pre>"},{"location":"reference/task_run/#fluid.scheduler.TaskRun.lock","title":"lock","text":"<pre><code>lock(timeout)\n</code></pre> Source code in <code>fluid/scheduler/models.py</code> <pre><code>def lock(self, timeout: float | None) -&gt; Lock:\n    return self.task_manager.broker.lock(self.name, timeout=timeout)\n</code></pre>"},{"location":"reference/tast_consumer/","title":"Task Consumer","text":"<p>The task consumer is a TaskManager which is also a Workers that consumes tasks from the task queue and executes them. It can be imported from <code>fluid.scheduler</code>:</p> <pre><code>from fastapi.scheduler import TaskConsumer\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer","title":"fluid.scheduler.TaskConsumer","text":"<pre><code>TaskConsumer(**config)\n</code></pre> <p>               Bases: <code>TaskManager</code>, <code>Workers</code></p> <p>The Task Consumer is a Task Manager responsible for consuming tasks from a task queue</p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def __init__(self, **config: Any) -&gt; None:\n    super().__init__(**config)\n    Workers.__init__(self)\n    self._async_dispatcher_worker = AsyncConsumer(AsyncTaskDispatcher())\n    self._concurrent_tasks: dict[str, dict[str, TaskRun]] = defaultdict(dict)\n    self._task_to_queue: deque[str | Task] = deque()\n    self._priority_task_run_queue: deque[TaskRun] = deque()\n    self._queue_tasks_worker = WorkerFunction(\n        self._queue_task, name=\"queue-task-worker\"\n    )\n    self.add_workers(self._queue_tasks_worker)\n    self.add_workers(self._async_dispatcher_worker)\n    for i in range(self.config.max_concurrent_tasks):\n        worker_name = f\"task-worker-{i+1}\"\n        self.add_workers(\n            WorkerFunction(\n                partial(self._consume_tasks, worker_name), name=worker_name\n            )\n        )\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.worker_name","title":"worker_name  <code>property</code>","text":"<pre><code>worker_name\n</code></pre> <p>The name of the worker</p>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.num_workers","title":"num_workers  <code>property</code>","text":"<pre><code>num_workers\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.running","title":"running  <code>property</code>","text":"<pre><code>running\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.state","title":"state  <code>instance-attribute</code>","text":"<pre><code>state = {}\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config = TaskManagerConfig(**kwargs)\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.dispatcher","title":"dispatcher  <code>instance-attribute</code>","text":"<pre><code>dispatcher = TaskDispatcher()\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.broker","title":"broker  <code>instance-attribute</code>","text":"<pre><code>broker = from_url(broker_url)\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.registry","title":"registry  <code>property</code>","text":"<pre><code>registry\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.type","title":"type  <code>property</code>","text":"<pre><code>type\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.num_concurrent_tasks","title":"num_concurrent_tasks  <code>property</code>","text":"<pre><code>num_concurrent_tasks\n</code></pre> <p>The number of concurrent_tasks running in the consumer</p>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.status","title":"status  <code>async</code>","text":"<pre><code>status()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def status(self) -&gt; dict:\n    return await self._workers.status()\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.gracefully_stop","title":"gracefully_stop","text":"<pre><code>gracefully_stop()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def gracefully_stop(self) -&gt; None:\n    self._workers.gracefully_stop()\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.is_running","title":"is_running","text":"<pre><code>is_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_running(self) -&gt; bool:\n    return self._running\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.is_stopping","title":"is_stopping","text":"<pre><code>is_stopping()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_stopping(self) -&gt; bool:\n    return self._workers.is_stopping()\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.run","title":"run  <code>async</code>","text":"<pre><code>run()\n</code></pre> <p>run the workers</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def run(self) -&gt; None:\n    \"\"\"run the workers\"\"\"\n    with self.start_running():\n        async with self.safe_run():\n            workers, _ = self._workers.workers_tasks()\n            self._workers.workers = tuple(workers)\n            self._workers.tasks = tuple(\n                self.create_task(worker) for worker in workers\n            )\n            await asyncio.gather(*self._workers.tasks)\n        await self.shutdown()\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.start_running","title":"start_running","text":"<pre><code>start_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>@contextmanager\ndef start_running(self) -&gt; Generator:\n    if self._running:\n        raise RuntimeError(\"Worker is already running\")\n    self._running = True\n    try:\n        logger.info(\"%s started running\", self.worker_name)\n        yield\n    finally:\n        self._running = False\n        logger.warning(\"%s stopped running\", self.worker_name)\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.add_workers","title":"add_workers","text":"<pre><code>add_workers(*workers)\n</code></pre> <p>add workers to the workers</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def add_workers(self, *workers: Worker) -&gt; None:\n    \"\"\"add workers to the workers\"\"\"\n    workers_, _ = self._workers.workers_tasks()\n    for worker in workers:\n        if worker not in workers_:\n            workers_.append(worker)\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.wait_for_exit","title":"wait_for_exit  <code>async</code>","text":"<pre><code>wait_for_exit()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def wait_for_exit(self) -&gt; None:\n    if self._workers_task is not None:\n        await self._workers_task\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.create_task","title":"create_task","text":"<pre><code>create_task(worker)\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def create_task(self, worker: Worker) -&gt; asyncio.Task:\n    return asyncio.create_task(\n        self._run_worker(worker), name=f\"{self.worker_name}-{worker.worker_name}\"\n    )\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.on_shutdown","title":"on_shutdown  <code>async</code>","text":"<pre><code>on_shutdown()\n</code></pre> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>async def on_shutdown(self) -&gt; None:\n    await self.broker.close()\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.shutdown","title":"shutdown  <code>async</code>","text":"<pre><code>shutdown()\n</code></pre> <p>shutdown the workers</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def shutdown(self) -&gt; None:\n    \"\"\"shutdown the workers\"\"\"\n    if self._has_shutdown:\n        return\n    self._has_shutdown = True\n    logger.warning(\n        \"gracefully stopping %d workers: %s\",\n        self.num_workers,\n        \", \".join(w.worker_name for w in self._workers.workers),\n    )\n    self.gracefully_stop()\n    try:\n        async with asyncio.timeout(self._stopping_grace_period):\n            await self.wait_for_exit()\n        await self.on_shutdown()\n        return\n    except asyncio.TimeoutError:\n        logger.warning(\n            \"could not stop workers %s gracefully after %s\"\n            \" seconds - force shutdown\",\n            \", \".join(\n                task.get_name() for task in self._workers.tasks if not task.done()\n            ),\n            self._stopping_grace_period,\n        )\n    except asyncio.CancelledError:\n        pass\n    self._force_shutdown = True\n    self._workers.cancel()\n    try:\n        await self.wait_for_exit()\n    except asyncio.CancelledError:\n        pass\n    await self.on_shutdown()\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.bail_out","title":"bail_out","text":"<pre><code>bail_out(reason, code=1)\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def bail_out(self, reason: str, code: int = 1) -&gt; None:\n    self.gracefully_stop()\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.safe_run","title":"safe_run  <code>async</code>","text":"<pre><code>safe_run()\n</code></pre> <p>Context manager to run a worker safely</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>@asynccontextmanager\nasync def safe_run(self) -&gt; AsyncGenerator:\n    \"\"\"Context manager to run a worker safely\"\"\"\n    try:\n        yield\n    except asyncio.CancelledError:\n        if self._force_shutdown:\n            # we are shutting down, this is expected\n            pass\n        raise\n    except Exception as e:\n        reason = f\"unhandled exception while running workers: {e}\"\n        logger.exception(reason)\n        asyncio.get_event_loop().call_soon(self.bail_out, reason, 2)\n    else:\n        # worker finished without error\n        # make sure we are shutting down\n        asyncio.get_event_loop().call_soon(self.bail_out, \"worker exit\", 1)\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.remove_workers","title":"remove_workers","text":"<pre><code>remove_workers(*workers)\n</code></pre> <p>remove workers from the workers</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def remove_workers(self, *workers: Worker) -&gt; None:\n    \"remove workers from the workers\"\n    workers_, _ = self._workers.workers_tasks()\n    for worker in workers:\n        try:\n            workers_.remove(worker)\n        except ValueError:\n            pass\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.startup","title":"startup  <code>async</code>","text":"<pre><code>startup()\n</code></pre> <p>start the workers</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def startup(self) -&gt; None:\n    \"\"\"start the workers\"\"\"\n    if self._workers_task is None:\n        self._workers_task = asyncio.create_task(self.run(), name=self.worker_name)\n        for args in self._delayed_callbacks:\n            self._delayed_callback(*args)\n        self._delayed_callbacks = []\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.register_callback","title":"register_callback","text":"<pre><code>register_callback(\n    callback, seconds, jitter=0.0, periodic=False\n)\n</code></pre> <p>Register a callback</p> <p>The callback can be periodic or not.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def register_callback(\n    self,\n    callback: Callable[[], None],\n    seconds: float,\n    jitter: float = 0.0,\n    periodic: bool | float = False,\n) -&gt; None:\n    \"\"\"Register a callback\n\n    The callback can be periodic or not.\n    \"\"\"\n    if periodic is True:\n        periodic_float = seconds\n    elif periodic is False:\n        periodic_float = 0.0\n    else:\n        periodic_float = periodic\n    if not self.running:\n        self._delayed_callbacks.append((callback, seconds, jitter, periodic_float))\n    else:\n        self._delayed_callback(callback, seconds, jitter, periodic_float)\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.enter_async_context","title":"enter_async_context  <code>async</code>","text":"<pre><code>enter_async_context(cm)\n</code></pre> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>async def enter_async_context(self, cm: Any) -&gt; Any:\n    return await self._stack.enter_async_context(cm)\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.execute","title":"execute  <code>async</code>","text":"<pre><code>execute(task, **params)\n</code></pre> <p>Execute a task and wait for it to finish</p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>async def execute(self, task: Task | str, **params: Any) -&gt; TaskRun:\n    \"\"\"Execute a task and wait for it to finish\"\"\"\n    task_run = self.create_task_run(task, **params)\n    await task_run.execute()\n    return task_run\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.execute_sync","title":"execute_sync","text":"<pre><code>execute_sync(task, **params)\n</code></pre> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def execute_sync(self, task: Task | str, **params: Any) -&gt; TaskRun:\n    return asyncio.run(self._execute_and_exit(task, **params))\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.register_task","title":"register_task","text":"<pre><code>register_task(task)\n</code></pre> <p>Register a task with the task manager</p> <p>Only tasks registered can be executed by a task manager</p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def register_task(self, task: Task) -&gt; None:\n    \"\"\"Register a task with the task manager\n\n    Only tasks registered can be executed by a task manager\n    \"\"\"\n    self.broker.register_task(task)\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.queue","title":"queue  <code>async</code>","text":"<pre><code>queue(task, priority=None, **params)\n</code></pre> <p>Queue a task for execution</p> <p>This methods fires two events:</p> <ul> <li>queue: when the task is about to be queued</li> <li>queued: after the task is queued</li> </ul> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>async def queue(\n    self,\n    task: str | Task,\n    priority: TaskPriority | None = None,\n    **params: Any,\n) -&gt; TaskRun:\n    \"\"\"Queue a task for execution\n\n    This methods fires two events:\n\n    - queue: when the task is about to be queued\n    - queued: after the task is queued\n    \"\"\"\n    task_run = self.create_task_run(task, priority=priority, **params)\n    self.dispatcher.dispatch(task_run)\n    task_run.set_state(TaskState.queued)\n    await self.broker.queue_task(task_run)\n    return task_run\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.create_task_run","title":"create_task_run","text":"<pre><code>create_task_run(task, run_id='', priority=None, **params)\n</code></pre> <p>Create a TaskRun in <code>init</code> state</p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def create_task_run(\n    self,\n    task: str | Task,\n    run_id: str = \"\",\n    priority: TaskPriority | None = None,\n    **params: Any,\n) -&gt; TaskRun:\n    \"\"\"Create a TaskRun in `init` state\"\"\"\n    if isinstance(task, str):\n        task = self.broker.task_from_registry(task)\n    run_id = run_id or self.broker.new_uuid()\n    return TaskRun(\n        id=run_id,\n        task=task,\n        priority=priority or task.priority,\n        params=params,\n        task_manager=self,\n    )\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.register_from_module","title":"register_from_module","text":"<pre><code>register_from_module(module)\n</code></pre> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def register_from_module(self, module: Any) -&gt; None:\n    for name in dir(module):\n        if name.startswith(\"_\"):\n            continue\n        if isinstance(obj := getattr(module, name), Task):\n            self.register_task(obj)\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.register_from_dict","title":"register_from_dict","text":"<pre><code>register_from_dict(data)\n</code></pre> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def register_from_dict(self, data: dict) -&gt; None:\n    for name, obj in data.items():\n        if name.startswith(\"_\"):\n            continue\n        if isinstance(obj, Task):\n            self.register_task(obj)\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.sync_queue","title":"sync_queue","text":"<pre><code>sync_queue(task)\n</code></pre> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def sync_queue(self, task: str | Task) -&gt; None:\n    self._task_to_queue.appendleft(task)\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.sync_priority_queue","title":"sync_priority_queue","text":"<pre><code>sync_priority_queue(task)\n</code></pre> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def sync_priority_queue(self, task: str | Task) -&gt; None:\n    self._priority_task_run_queue.appendleft(self.create_task_run(task))\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.num_concurrent_tasks_for","title":"num_concurrent_tasks_for","text":"<pre><code>num_concurrent_tasks_for(task_name)\n</code></pre> <p>The number of concurrent tasks for a given task_name</p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def num_concurrent_tasks_for(self, task_name: str) -&gt; int:\n    \"\"\"The number of concurrent tasks for a given task_name\"\"\"\n    return len(self._concurrent_tasks[task_name])\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.queue_and_wait","title":"queue_and_wait  <code>async</code>","text":"<pre><code>queue_and_wait(task, *, timeout=2, **params)\n</code></pre> <p>Queue a task and wait for it to finish</p> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>async def queue_and_wait(\n    self, task: str, *, timeout: int = 2, **params: Any\n) -&gt; TaskRun:\n    \"\"\"Queue a task and wait for it to finish\"\"\"\n    with TaskRunWaiter(self) as waiter:\n        return await waiter.wait(await self.queue(task, **params), timeout=timeout)\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.register_async_handler","title":"register_async_handler","text":"<pre><code>register_async_handler(event, handler)\n</code></pre> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def register_async_handler(self, event: Event | str, handler: AsyncHandler) -&gt; None:\n    event = Event.from_string_or_event(event)\n    self.dispatcher.register_handler(\n        f\"{event.type}.async_dispatch\",\n        self._async_dispatcher_worker.send,\n    )\n    self._async_dispatcher_worker.dispatcher.register_handler(event, handler)\n</code></pre>"},{"location":"reference/tast_consumer/#fluid.scheduler.TaskConsumer.unregister_async_handler","title":"unregister_async_handler","text":"<pre><code>unregister_async_handler(event)\n</code></pre> Source code in <code>fluid/scheduler/consumer.py</code> <pre><code>def unregister_async_handler(self, event: Event | str) -&gt; AsyncHandler | None:\n    return self._async_dispatcher_worker.dispatcher.unregister_handler(event)\n</code></pre>"},{"location":"reference/workers/","title":"Workers","text":"<p>Workers are the main building block for asynchronous programming with <code>aio-fluid</code>. They are responsible for running tasks and managing their lifecycle. There are several worker classes which can be imported from <code>fluid.utils.worker</code>:</p> <pre><code>from fastapi.utils.worker import StoppingWorker\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Worker","title":"fluid.utils.worker.Worker","text":"<pre><code>Worker(name='')\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>The base class of a worker that can be run</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def __init__(self, name: str = \"\") -&gt; None:\n    self._name: str = name or underscore(type(self).__name__)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Worker.worker_name","title":"worker_name  <code>property</code>","text":"<pre><code>worker_name\n</code></pre> <p>The name of the worker</p>"},{"location":"reference/workers/#fluid.utils.worker.Worker.num_workers","title":"num_workers  <code>property</code>","text":"<pre><code>num_workers\n</code></pre> <p>The number of workers in this worker</p>"},{"location":"reference/workers/#fluid.utils.worker.Worker.status","title":"status  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>status()\n</code></pre> <p>Get the status of the worker.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>@abstractmethod\nasync def status(self) -&gt; dict:\n    \"\"\"\n    Get the status of the worker.\n    \"\"\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Worker.gracefully_stop","title":"gracefully_stop  <code>abstractmethod</code>","text":"<pre><code>gracefully_stop()\n</code></pre> <p>gracefully stop the worker</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>@abstractmethod\ndef gracefully_stop(self) -&gt; None:\n    \"gracefully stop the worker\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Worker.is_running","title":"is_running  <code>abstractmethod</code>","text":"<pre><code>is_running()\n</code></pre> <p>Is the worker running?</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>@abstractmethod\ndef is_running(self) -&gt; bool:\n    \"\"\"Is the worker running?\"\"\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Worker.is_stopping","title":"is_stopping  <code>abstractmethod</code>","text":"<pre><code>is_stopping()\n</code></pre> <p>Is the worker stopping?</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>@abstractmethod\ndef is_stopping(self) -&gt; bool:\n    \"\"\"Is the worker stopping?\"\"\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Worker.run","title":"run  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>run()\n</code></pre> <p>run the worker</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>@abstractmethod\nasync def run(self) -&gt; None:\n    \"\"\"run the worker\"\"\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.RunningWorker","title":"fluid.utils.worker.RunningWorker","text":"<pre><code>RunningWorker(name='')\n</code></pre> <p>               Bases: <code>Worker</code></p> <p>A Worker that can be started</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def __init__(self, name: str = \"\") -&gt; None:\n    super().__init__(name)\n    self._running: bool = False\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.RunningWorker.worker_name","title":"worker_name  <code>property</code>","text":"<pre><code>worker_name\n</code></pre> <p>The name of the worker</p>"},{"location":"reference/workers/#fluid.utils.worker.RunningWorker.num_workers","title":"num_workers  <code>property</code>","text":"<pre><code>num_workers\n</code></pre> <p>The number of workers in this worker</p>"},{"location":"reference/workers/#fluid.utils.worker.RunningWorker.status","title":"status  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>status()\n</code></pre> <p>Get the status of the worker.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>@abstractmethod\nasync def status(self) -&gt; dict:\n    \"\"\"\n    Get the status of the worker.\n    \"\"\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.RunningWorker.gracefully_stop","title":"gracefully_stop  <code>abstractmethod</code>","text":"<pre><code>gracefully_stop()\n</code></pre> <p>gracefully stop the worker</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>@abstractmethod\ndef gracefully_stop(self) -&gt; None:\n    \"gracefully stop the worker\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.RunningWorker.is_stopping","title":"is_stopping  <code>abstractmethod</code>","text":"<pre><code>is_stopping()\n</code></pre> <p>Is the worker stopping?</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>@abstractmethod\ndef is_stopping(self) -&gt; bool:\n    \"\"\"Is the worker stopping?\"\"\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.RunningWorker.run","title":"run  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>run()\n</code></pre> <p>run the worker</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>@abstractmethod\nasync def run(self) -&gt; None:\n    \"\"\"run the worker\"\"\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.RunningWorker.is_running","title":"is_running","text":"<pre><code>is_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_running(self) -&gt; bool:\n    return self._running\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.RunningWorker.start_running","title":"start_running","text":"<pre><code>start_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>@contextmanager\ndef start_running(self) -&gt; Generator:\n    if self._running:\n        raise RuntimeError(\"Worker is already running\")\n    self._running = True\n    try:\n        logger.info(\"%s started running\", self.worker_name)\n        yield\n    finally:\n        self._running = False\n        logger.warning(\"%s stopped running\", self.worker_name)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.StoppingWorker","title":"fluid.utils.worker.StoppingWorker","text":"<pre><code>StoppingWorker(name='')\n</code></pre> <p>               Bases: <code>RunningWorker</code></p> <p>A Worker that can be stopped</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def __init__(self, name: str = \"\") -&gt; None:\n    super().__init__(name)\n    self._stopping: bool = False\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.StoppingWorker.worker_name","title":"worker_name  <code>property</code>","text":"<pre><code>worker_name\n</code></pre> <p>The name of the worker</p>"},{"location":"reference/workers/#fluid.utils.worker.StoppingWorker.num_workers","title":"num_workers  <code>property</code>","text":"<pre><code>num_workers\n</code></pre> <p>The number of workers in this worker</p>"},{"location":"reference/workers/#fluid.utils.worker.StoppingWorker.is_running","title":"is_running","text":"<pre><code>is_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_running(self) -&gt; bool:\n    return self._running\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.StoppingWorker.run","title":"run  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>run()\n</code></pre> <p>run the worker</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>@abstractmethod\nasync def run(self) -&gt; None:\n    \"\"\"run the worker\"\"\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.StoppingWorker.start_running","title":"start_running","text":"<pre><code>start_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>@contextmanager\ndef start_running(self) -&gt; Generator:\n    if self._running:\n        raise RuntimeError(\"Worker is already running\")\n    self._running = True\n    try:\n        logger.info(\"%s started running\", self.worker_name)\n        yield\n    finally:\n        self._running = False\n        logger.warning(\"%s stopped running\", self.worker_name)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.StoppingWorker.is_stopping","title":"is_stopping","text":"<pre><code>is_stopping()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_stopping(self) -&gt; bool:\n    return self._stopping\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.StoppingWorker.gracefully_stop","title":"gracefully_stop","text":"<pre><code>gracefully_stop()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def gracefully_stop(self) -&gt; None:\n    self._stopping = True\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.StoppingWorker.status","title":"status  <code>async</code>","text":"<pre><code>status()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def status(self) -&gt; dict:\n    return {\"stopping\": self.is_stopping(), \"running\": self.is_running()}\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.WorkerFunction","title":"fluid.utils.worker.WorkerFunction","text":"<pre><code>WorkerFunction(run_function, heartbeat=0, name='')\n</code></pre> <p>               Bases: <code>StoppingWorker</code></p> <p>A Worker that runs a coroutine function</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def __init__(\n    self,\n    run_function: Callable[[], Awaitable[None]],\n    heartbeat: float | int = 0,\n    name: str = \"\",\n) -&gt; None:\n    super().__init__(name=name)\n    self._run_function = run_function\n    self._heartbeat = heartbeat\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.WorkerFunction.worker_name","title":"worker_name  <code>property</code>","text":"<pre><code>worker_name\n</code></pre> <p>The name of the worker</p>"},{"location":"reference/workers/#fluid.utils.worker.WorkerFunction.num_workers","title":"num_workers  <code>property</code>","text":"<pre><code>num_workers\n</code></pre> <p>The number of workers in this worker</p>"},{"location":"reference/workers/#fluid.utils.worker.WorkerFunction.status","title":"status  <code>async</code>","text":"<pre><code>status()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def status(self) -&gt; dict:\n    return {\"stopping\": self.is_stopping(), \"running\": self.is_running()}\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.WorkerFunction.gracefully_stop","title":"gracefully_stop","text":"<pre><code>gracefully_stop()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def gracefully_stop(self) -&gt; None:\n    self._stopping = True\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.WorkerFunction.is_running","title":"is_running","text":"<pre><code>is_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_running(self) -&gt; bool:\n    return self._running\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.WorkerFunction.is_stopping","title":"is_stopping","text":"<pre><code>is_stopping()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_stopping(self) -&gt; bool:\n    return self._stopping\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.WorkerFunction.start_running","title":"start_running","text":"<pre><code>start_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>@contextmanager\ndef start_running(self) -&gt; Generator:\n    if self._running:\n        raise RuntimeError(\"Worker is already running\")\n    self._running = True\n    try:\n        logger.info(\"%s started running\", self.worker_name)\n        yield\n    finally:\n        self._running = False\n        logger.warning(\"%s stopped running\", self.worker_name)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.WorkerFunction.run","title":"run  <code>async</code>","text":"<pre><code>run()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def run(self) -&gt; None:\n    with self.start_running():\n        while not self.is_stopping():\n            await self._run_function()\n            await asyncio.sleep(self._heartbeat)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer","title":"fluid.utils.worker.QueueConsumer","text":"<pre><code>QueueConsumer(name='')\n</code></pre> <p>               Bases: <code>StoppingWorker</code>, <code>MessageProducer[MessageType]</code></p> <p>A Worker that can receive messages</p> <p>This worker can receive messages but not consume them.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def __init__(self, name: str = \"\") -&gt; None:\n    super().__init__(name=name)\n    self._queue: asyncio.Queue[MessageType | None] = asyncio.Queue()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer.worker_name","title":"worker_name  <code>property</code>","text":"<pre><code>worker_name\n</code></pre> <p>The name of the worker</p>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer.num_workers","title":"num_workers  <code>property</code>","text":"<pre><code>num_workers\n</code></pre> <p>The number of workers in this worker</p>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer.gracefully_stop","title":"gracefully_stop","text":"<pre><code>gracefully_stop()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def gracefully_stop(self) -&gt; None:\n    self._stopping = True\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer.is_running","title":"is_running","text":"<pre><code>is_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_running(self) -&gt; bool:\n    return self._running\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer.is_stopping","title":"is_stopping","text":"<pre><code>is_stopping()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_stopping(self) -&gt; bool:\n    return self._stopping\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer.run","title":"run  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>run()\n</code></pre> <p>run the worker</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>@abstractmethod\nasync def run(self) -&gt; None:\n    \"\"\"run the worker\"\"\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer.start_running","title":"start_running","text":"<pre><code>start_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>@contextmanager\ndef start_running(self) -&gt; Generator:\n    if self._running:\n        raise RuntimeError(\"Worker is already running\")\n    self._running = True\n    try:\n        logger.info(\"%s started running\", self.worker_name)\n        yield\n    finally:\n        self._running = False\n        logger.warning(\"%s stopped running\", self.worker_name)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer.get_message","title":"get_message  <code>async</code>","text":"<pre><code>get_message(timeout=0.5)\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def get_message(self, timeout: float = 0.5) -&gt; MessageType | None:\n    try:\n        async with asyncio.timeout(timeout):\n            return await self._queue.get()\n    except asyncio.TimeoutError:\n        return None\n    except (asyncio.CancelledError, RuntimeError):\n        if not self.is_stopping():\n            raise\n    return None\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer.queue_size","title":"queue_size","text":"<pre><code>queue_size()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def queue_size(self) -&gt; int:\n    return self._queue.qsize()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer.status","title":"status  <code>async</code>","text":"<pre><code>status()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def status(self) -&gt; dict:\n    status = await super().status()\n    status.update(queue_size=self.queue_size())\n    return status\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumer.send","title":"send","text":"<pre><code>send(message)\n</code></pre> <p>Send a message into the worker</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def send(self, message: MessageType | None) -&gt; None:\n    \"\"\"Send a message into the worker\"\"\"\n    self._queue.put_nowait(message)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker","title":"fluid.utils.worker.QueueConsumerWorker","text":"<pre><code>QueueConsumerWorker(on_message, name='')\n</code></pre> <p>               Bases: <code>QueueConsumer[MessageType]</code></p> <p>A Worker that can receive and consume messages</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def __init__(\n    self,\n    on_message: Callable[[MessageType], Awaitable[None]],\n    name: str = \"\",\n) -&gt; None:\n    super().__init__(name=name)\n    self.on_message = on_message\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.worker_name","title":"worker_name  <code>property</code>","text":"<pre><code>worker_name\n</code></pre> <p>The name of the worker</p>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.num_workers","title":"num_workers  <code>property</code>","text":"<pre><code>num_workers\n</code></pre> <p>The number of workers in this worker</p>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.on_message","title":"on_message  <code>instance-attribute</code>","text":"<pre><code>on_message = on_message\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.send","title":"send","text":"<pre><code>send(message)\n</code></pre> <p>Send a message into the worker</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def send(self, message: MessageType | None) -&gt; None:\n    \"\"\"Send a message into the worker\"\"\"\n    self._queue.put_nowait(message)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.status","title":"status  <code>async</code>","text":"<pre><code>status()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def status(self) -&gt; dict:\n    status = await super().status()\n    status.update(queue_size=self.queue_size())\n    return status\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.gracefully_stop","title":"gracefully_stop","text":"<pre><code>gracefully_stop()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def gracefully_stop(self) -&gt; None:\n    self._stopping = True\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.is_running","title":"is_running","text":"<pre><code>is_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_running(self) -&gt; bool:\n    return self._running\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.is_stopping","title":"is_stopping","text":"<pre><code>is_stopping()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_stopping(self) -&gt; bool:\n    return self._stopping\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.start_running","title":"start_running","text":"<pre><code>start_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>@contextmanager\ndef start_running(self) -&gt; Generator:\n    if self._running:\n        raise RuntimeError(\"Worker is already running\")\n    self._running = True\n    try:\n        logger.info(\"%s started running\", self.worker_name)\n        yield\n    finally:\n        self._running = False\n        logger.warning(\"%s stopped running\", self.worker_name)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.get_message","title":"get_message  <code>async</code>","text":"<pre><code>get_message(timeout=0.5)\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def get_message(self, timeout: float = 0.5) -&gt; MessageType | None:\n    try:\n        async with asyncio.timeout(timeout):\n            return await self._queue.get()\n    except asyncio.TimeoutError:\n        return None\n    except (asyncio.CancelledError, RuntimeError):\n        if not self.is_stopping():\n            raise\n    return None\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.queue_size","title":"queue_size","text":"<pre><code>queue_size()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def queue_size(self) -&gt; int:\n    return self._queue.qsize()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.QueueConsumerWorker.run","title":"run  <code>async</code>","text":"<pre><code>run()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def run(self) -&gt; None:\n    with self.start_running():\n        while not self.is_stopping():\n            message = await self.get_message()\n            if message is not None:\n                await self.on_message(message)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer","title":"fluid.utils.worker.AsyncConsumer","text":"<pre><code>AsyncConsumer(dispatcher, name='')\n</code></pre> <p>               Bases: <code>QueueConsumer[MessageType]</code></p> <p>A Worker that can dispatch async callbacks</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def __init__(\n    self, dispatcher: AsyncDispatcher[MessageType], name: str = \"\"\n) -&gt; None:\n    super().__init__(name)\n    self.dispatcher: AsyncDispatcher[MessageType] = dispatcher\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.worker_name","title":"worker_name  <code>property</code>","text":"<pre><code>worker_name\n</code></pre> <p>The name of the worker</p>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.num_workers","title":"num_workers  <code>property</code>","text":"<pre><code>num_workers\n</code></pre> <p>The number of workers in this worker</p>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.AsyncCallback","title":"AsyncCallback  <code>instance-attribute</code>","text":"<pre><code>AsyncCallback\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.dispatcher","title":"dispatcher  <code>instance-attribute</code>","text":"<pre><code>dispatcher = dispatcher\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.send","title":"send","text":"<pre><code>send(message)\n</code></pre> <p>Send a message into the worker</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def send(self, message: MessageType | None) -&gt; None:\n    \"\"\"Send a message into the worker\"\"\"\n    self._queue.put_nowait(message)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.status","title":"status  <code>async</code>","text":"<pre><code>status()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def status(self) -&gt; dict:\n    status = await super().status()\n    status.update(queue_size=self.queue_size())\n    return status\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.gracefully_stop","title":"gracefully_stop","text":"<pre><code>gracefully_stop()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def gracefully_stop(self) -&gt; None:\n    self._stopping = True\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.is_running","title":"is_running","text":"<pre><code>is_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_running(self) -&gt; bool:\n    return self._running\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.is_stopping","title":"is_stopping","text":"<pre><code>is_stopping()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_stopping(self) -&gt; bool:\n    return self._stopping\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.start_running","title":"start_running","text":"<pre><code>start_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>@contextmanager\ndef start_running(self) -&gt; Generator:\n    if self._running:\n        raise RuntimeError(\"Worker is already running\")\n    self._running = True\n    try:\n        logger.info(\"%s started running\", self.worker_name)\n        yield\n    finally:\n        self._running = False\n        logger.warning(\"%s stopped running\", self.worker_name)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.get_message","title":"get_message  <code>async</code>","text":"<pre><code>get_message(timeout=0.5)\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def get_message(self, timeout: float = 0.5) -&gt; MessageType | None:\n    try:\n        async with asyncio.timeout(timeout):\n            return await self._queue.get()\n    except asyncio.TimeoutError:\n        return None\n    except (asyncio.CancelledError, RuntimeError):\n        if not self.is_stopping():\n            raise\n    return None\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.queue_size","title":"queue_size","text":"<pre><code>queue_size()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def queue_size(self) -&gt; int:\n    return self._queue.qsize()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.AsyncConsumer.run","title":"run  <code>async</code>","text":"<pre><code>run()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def run(self) -&gt; None:\n    with self.start_running():\n        while not self.is_stopping():\n            message = await self.get_message()\n            if message is not None:\n                await self.dispatcher.dispatch(message)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers","title":"fluid.utils.worker.Workers","text":"<pre><code>Workers(\n    *workers,\n    name=\"\",\n    stopping_grace_period=STOPPING_GRACE_PERIOD\n)\n</code></pre> <p>               Bases: <code>MultipleWorkers</code></p> <p>A worker managing several workers</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def __init__(\n    self,\n    *workers: Worker,\n    name: str = \"\",\n    stopping_grace_period: int = settings.STOPPING_GRACE_PERIOD,\n) -&gt; None:\n    super().__init__(\n        *workers, name=name, stopping_grace_period=stopping_grace_period\n    )\n    self._workers_task: asyncio.Task | None = None\n    self._delayed_callbacks: list[\n        tuple[Callable[[], None], float, float, float]\n    ] = []\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.worker_name","title":"worker_name  <code>property</code>","text":"<pre><code>worker_name\n</code></pre> <p>The name of the worker</p>"},{"location":"reference/workers/#fluid.utils.worker.Workers.num_workers","title":"num_workers  <code>property</code>","text":"<pre><code>num_workers\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.running","title":"running  <code>property</code>","text":"<pre><code>running\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.status","title":"status  <code>async</code>","text":"<pre><code>status()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def status(self) -&gt; dict:\n    return await self._workers.status()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.gracefully_stop","title":"gracefully_stop","text":"<pre><code>gracefully_stop()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def gracefully_stop(self) -&gt; None:\n    self._workers.gracefully_stop()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.is_running","title":"is_running","text":"<pre><code>is_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_running(self) -&gt; bool:\n    return self._running\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.is_stopping","title":"is_stopping","text":"<pre><code>is_stopping()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_stopping(self) -&gt; bool:\n    return self._workers.is_stopping()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.start_running","title":"start_running","text":"<pre><code>start_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>@contextmanager\ndef start_running(self) -&gt; Generator:\n    if self._running:\n        raise RuntimeError(\"Worker is already running\")\n    self._running = True\n    try:\n        logger.info(\"%s started running\", self.worker_name)\n        yield\n    finally:\n        self._running = False\n        logger.warning(\"%s stopped running\", self.worker_name)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.create_task","title":"create_task","text":"<pre><code>create_task(worker)\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def create_task(self, worker: Worker) -&gt; asyncio.Task:\n    return asyncio.create_task(\n        self._run_worker(worker), name=f\"{self.worker_name}-{worker.worker_name}\"\n    )\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.on_shutdown","title":"on_shutdown  <code>async</code>","text":"<pre><code>on_shutdown()\n</code></pre> <p>called after the workers are stopped</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def on_shutdown(self) -&gt; None:\n    \"\"\"called after the workers are stopped\"\"\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.shutdown","title":"shutdown  <code>async</code>","text":"<pre><code>shutdown()\n</code></pre> <p>shutdown the workers</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def shutdown(self) -&gt; None:\n    \"\"\"shutdown the workers\"\"\"\n    if self._has_shutdown:\n        return\n    self._has_shutdown = True\n    logger.warning(\n        \"gracefully stopping %d workers: %s\",\n        self.num_workers,\n        \", \".join(w.worker_name for w in self._workers.workers),\n    )\n    self.gracefully_stop()\n    try:\n        async with asyncio.timeout(self._stopping_grace_period):\n            await self.wait_for_exit()\n        await self.on_shutdown()\n        return\n    except asyncio.TimeoutError:\n        logger.warning(\n            \"could not stop workers %s gracefully after %s\"\n            \" seconds - force shutdown\",\n            \", \".join(\n                task.get_name() for task in self._workers.tasks if not task.done()\n            ),\n            self._stopping_grace_period,\n        )\n    except asyncio.CancelledError:\n        pass\n    self._force_shutdown = True\n    self._workers.cancel()\n    try:\n        await self.wait_for_exit()\n    except asyncio.CancelledError:\n        pass\n    await self.on_shutdown()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.bail_out","title":"bail_out","text":"<pre><code>bail_out(reason, code=1)\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def bail_out(self, reason: str, code: int = 1) -&gt; None:\n    self.gracefully_stop()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.safe_run","title":"safe_run  <code>async</code>","text":"<pre><code>safe_run()\n</code></pre> <p>Context manager to run a worker safely</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>@asynccontextmanager\nasync def safe_run(self) -&gt; AsyncGenerator:\n    \"\"\"Context manager to run a worker safely\"\"\"\n    try:\n        yield\n    except asyncio.CancelledError:\n        if self._force_shutdown:\n            # we are shutting down, this is expected\n            pass\n        raise\n    except Exception as e:\n        reason = f\"unhandled exception while running workers: {e}\"\n        logger.exception(reason)\n        asyncio.get_event_loop().call_soon(self.bail_out, reason, 2)\n    else:\n        # worker finished without error\n        # make sure we are shutting down\n        asyncio.get_event_loop().call_soon(self.bail_out, \"worker exit\", 1)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.add_workers","title":"add_workers","text":"<pre><code>add_workers(*workers)\n</code></pre> <p>add workers to the workers</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def add_workers(self, *workers: Worker) -&gt; None:\n    \"\"\"add workers to the workers\"\"\"\n    workers_, _ = self._workers.workers_tasks()\n    for worker in workers:\n        if worker not in workers_:\n            workers_.append(worker)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.run","title":"run  <code>async</code>","text":"<pre><code>run()\n</code></pre> <p>run the workers</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def run(self) -&gt; None:\n    \"\"\"run the workers\"\"\"\n    with self.start_running():\n        async with self.safe_run():\n            workers, _ = self._workers.workers_tasks()\n            self._workers.workers = tuple(workers)\n            self._workers.tasks = tuple(\n                self.create_task(worker) for worker in workers\n            )\n            await asyncio.gather(*self._workers.tasks)\n        await self.shutdown()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.wait_for_exit","title":"wait_for_exit  <code>async</code>","text":"<pre><code>wait_for_exit()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def wait_for_exit(self) -&gt; None:\n    if self._workers_task is not None:\n        await self._workers_task\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.remove_workers","title":"remove_workers","text":"<pre><code>remove_workers(*workers)\n</code></pre> <p>remove workers from the workers</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def remove_workers(self, *workers: Worker) -&gt; None:\n    \"remove workers from the workers\"\n    workers_, _ = self._workers.workers_tasks()\n    for worker in workers:\n        try:\n            workers_.remove(worker)\n        except ValueError:\n            pass\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.startup","title":"startup  <code>async</code>","text":"<pre><code>startup()\n</code></pre> <p>start the workers</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def startup(self) -&gt; None:\n    \"\"\"start the workers\"\"\"\n    if self._workers_task is None:\n        self._workers_task = asyncio.create_task(self.run(), name=self.worker_name)\n        for args in self._delayed_callbacks:\n            self._delayed_callback(*args)\n        self._delayed_callbacks = []\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.Workers.register_callback","title":"register_callback","text":"<pre><code>register_callback(\n    callback, seconds, jitter=0.0, periodic=False\n)\n</code></pre> <p>Register a callback</p> <p>The callback can be periodic or not.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def register_callback(\n    self,\n    callback: Callable[[], None],\n    seconds: float,\n    jitter: float = 0.0,\n    periodic: bool | float = False,\n) -&gt; None:\n    \"\"\"Register a callback\n\n    The callback can be periodic or not.\n    \"\"\"\n    if periodic is True:\n        periodic_float = seconds\n    elif periodic is False:\n        periodic_float = 0.0\n    else:\n        periodic_float = periodic\n    if not self.running:\n        self._delayed_callbacks.append((callback, seconds, jitter, periodic_float))\n    else:\n        self._delayed_callback(callback, seconds, jitter, periodic_float)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.DynamicWorkers","title":"fluid.utils.worker.DynamicWorkers","text":"<pre><code>DynamicWorkers(\n    *workers,\n    name=\"\",\n    heartbeat=0.1,\n    stopping_grace_period=STOPPING_GRACE_PERIOD\n)\n</code></pre> <p>               Bases: <code>MultipleWorkers</code></p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def __init__(\n    self,\n    *workers: Worker,\n    name: str = \"\",\n    heartbeat: float | int = 0.1,\n    stopping_grace_period: int = settings.STOPPING_GRACE_PERIOD,\n) -&gt; None:\n    super().__init__(name)\n    self._heartbeat = heartbeat\n    self._workers = WorkerTasks()\n    self._has_shutdown = False\n    self._force_shutdown = False\n    self._stopping_grace_period = stopping_grace_period\n    self.add_workers(*workers)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.DynamicWorkers.worker_name","title":"worker_name  <code>property</code>","text":"<pre><code>worker_name\n</code></pre> <p>The name of the worker</p>"},{"location":"reference/workers/#fluid.utils.worker.DynamicWorkers.num_workers","title":"num_workers  <code>property</code>","text":"<pre><code>num_workers\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.DynamicWorkers.status","title":"status  <code>async</code>","text":"<pre><code>status()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def status(self) -&gt; dict:\n    return await self._workers.status()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.DynamicWorkers.gracefully_stop","title":"gracefully_stop","text":"<pre><code>gracefully_stop()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def gracefully_stop(self) -&gt; None:\n    self._workers.gracefully_stop()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.DynamicWorkers.is_running","title":"is_running","text":"<pre><code>is_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_running(self) -&gt; bool:\n    return self._running\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.DynamicWorkers.is_stopping","title":"is_stopping","text":"<pre><code>is_stopping()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def is_stopping(self) -&gt; bool:\n    return self._workers.is_stopping()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.DynamicWorkers.start_running","title":"start_running","text":"<pre><code>start_running()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>@contextmanager\ndef start_running(self) -&gt; Generator:\n    if self._running:\n        raise RuntimeError(\"Worker is already running\")\n    self._running = True\n    try:\n        logger.info(\"%s started running\", self.worker_name)\n        yield\n    finally:\n        self._running = False\n        logger.warning(\"%s stopped running\", self.worker_name)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.DynamicWorkers.create_task","title":"create_task","text":"<pre><code>create_task(worker)\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def create_task(self, worker: Worker) -&gt; asyncio.Task:\n    return asyncio.create_task(\n        self._run_worker(worker), name=f\"{self.worker_name}-{worker.worker_name}\"\n    )\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.DynamicWorkers.on_shutdown","title":"on_shutdown  <code>async</code>","text":"<pre><code>on_shutdown()\n</code></pre> <p>called after the workers are stopped</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def on_shutdown(self) -&gt; None:\n    \"\"\"called after the workers are stopped\"\"\"\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.DynamicWorkers.shutdown","title":"shutdown  <code>async</code>","text":"<pre><code>shutdown()\n</code></pre> <p>shutdown the workers</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def shutdown(self) -&gt; None:\n    \"\"\"shutdown the workers\"\"\"\n    if self._has_shutdown:\n        return\n    self._has_shutdown = True\n    logger.warning(\n        \"gracefully stopping %d workers: %s\",\n        self.num_workers,\n        \", \".join(w.worker_name for w in self._workers.workers),\n    )\n    self.gracefully_stop()\n    try:\n        async with asyncio.timeout(self._stopping_grace_period):\n            await self.wait_for_exit()\n        await self.on_shutdown()\n        return\n    except asyncio.TimeoutError:\n        logger.warning(\n            \"could not stop workers %s gracefully after %s\"\n            \" seconds - force shutdown\",\n            \", \".join(\n                task.get_name() for task in self._workers.tasks if not task.done()\n            ),\n            self._stopping_grace_period,\n        )\n    except asyncio.CancelledError:\n        pass\n    self._force_shutdown = True\n    self._workers.cancel()\n    try:\n        await self.wait_for_exit()\n    except asyncio.CancelledError:\n        pass\n    await self.on_shutdown()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.DynamicWorkers.bail_out","title":"bail_out","text":"<pre><code>bail_out(reason, code=1)\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>def bail_out(self, reason: str, code: int = 1) -&gt; None:\n    self.gracefully_stop()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.DynamicWorkers.safe_run","title":"safe_run  <code>async</code>","text":"<pre><code>safe_run()\n</code></pre> <p>Context manager to run a worker safely</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>@asynccontextmanager\nasync def safe_run(self) -&gt; AsyncGenerator:\n    \"\"\"Context manager to run a worker safely\"\"\"\n    try:\n        yield\n    except asyncio.CancelledError:\n        if self._force_shutdown:\n            # we are shutting down, this is expected\n            pass\n        raise\n    except Exception as e:\n        reason = f\"unhandled exception while running workers: {e}\"\n        logger.exception(reason)\n        asyncio.get_event_loop().call_soon(self.bail_out, reason, 2)\n    else:\n        # worker finished without error\n        # make sure we are shutting down\n        asyncio.get_event_loop().call_soon(self.bail_out, \"worker exit\", 1)\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.DynamicWorkers.add_workers","title":"add_workers","text":"<pre><code>add_workers(*workers)\n</code></pre> <p>add workers to the workers</p> <p>They can be added while the workers are running.</p> Source code in <code>fluid/utils/worker.py</code> <pre><code>def add_workers(self, *workers: Worker) -&gt; None:\n    \"\"\"add workers to the workers\n\n    They can be added while the workers are running.\n    \"\"\"\n    workers_, tasks_ = self._workers.workers_tasks()\n    for worker in workers:\n        workers_.append(worker)\n        tasks_.append(self.create_task(worker))\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.DynamicWorkers.run","title":"run  <code>async</code>","text":"<pre><code>run()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def run(self) -&gt; None:\n    with self.start_running():\n        while not self.is_stopping():\n            for worker, task in zip(self._workers.workers, self._workers.tasks):\n                if worker.is_stopping() or task.done():\n                    break\n            await asyncio.sleep(self._heartbeat)\n        await self.shutdown()\n</code></pre>"},{"location":"reference/workers/#fluid.utils.worker.DynamicWorkers.wait_for_exit","title":"wait_for_exit  <code>async</code>","text":"<pre><code>wait_for_exit()\n</code></pre> Source code in <code>fluid/utils/worker.py</code> <pre><code>async def wait_for_exit(self) -&gt; None:\n    await asyncio.gather(*self._workers.tasks)\n</code></pre>"},{"location":"tutorials/","title":"Tutorials","text":"<p>The step-by-step guides, the how-to's, the recipes, and all the Aio Fluid parts you can use in your applications.</p>"},{"location":"tutorials/db/","title":"Async Database","text":"<p>The <code>fluid.db</code> module provides a simple asynchronous interface to interact with postgres databases. It is built on top of the sqlalchemy and asyncpg libraries.</p>"},{"location":"tutorials/dispatchers/","title":"Event Dispatchers","text":"<p>Event dispatchers are a way to decouple the event source from the event handler. This is useful when you want to have multiple handlers for the same event, or when you want to have a single handler for multiple events.</p> <pre><code>from fluid.utils.dispatcher import SimpleDispatcher\n\nsimple = SimpleDispatcher[Any]()\n\nsimple.dispatch(\"you can dispatch anything to this generic dispatcher\")\n</code></pre>"},{"location":"tutorials/scheduler/","title":"Task Queue","text":"<p>This module has a lightweight implementation of a distributed task producer (TaskScheduler) and consumer (TaskConsumer). The middleware for distributing tasks can be configured via the Broker interface. A redis broker is provided for convenience.</p>"},{"location":"tutorials/scheduler/#tasks","title":"Tasks","text":"<p>Tasks are standard python async functions decorated with the <code>task</code> decorator.</p> <pre><code>from fluid.scheduler import task, TaskRun\n\n@task\nasync def say_hi(ctx: TaskRun):\n    return \"Hi!\"\n</code></pre> <p>There are two types of tasks implemented</p> <ul> <li>Simple concurrent tasks - they run concurrently with the task consumer - thy must be IO type tasks (no heavy CPU bound operations)</li> </ul> <pre><code>  from fluid.scheduler import task, TaskRun\n\n  @task\n  async def fecth_data(ctx: TaskRun):\n      # fetch data\n      data = await http_cli.get(\"https://...\")\n      data_id = await datastore_cli.stote(data)\n      # trigger another task\n      ctx.task_manager.queue(\"heavy_calculation\", data_id=data_id)\n</code></pre> <ul> <li>CPU bound tasks - they run on a subprocess</li> </ul> <pre><code>from fluid.scheduler import task, TaskRun\n\n@task(cpu_bound=True)\nasync def heavy_calculation(ctx: TaskRun):\n    data = await datastore_cli.get(ctx.params[\"data_id\"])\n    # perform some heavy calculation\n    ...\n    # trigger another task\n    ctx.task_manager.queue(\"fetch_data\")\n</code></pre> <p>Both tasks can be periodically scheduled via the <code>schedule</code> keyword argument:</p> <pre><code>from datetime import timedelta\nfrom fluid.scheduler import task, TaskContext, every\n\n@task(schedule=every(timedelta(seconds=1)))\nasync def scheduled(context: TaskContext) -&gt; str:\n    await asyncio.sleep(0.1)\n    return \"OK\"\n</code></pre>"},{"location":"tutorials/scheduler/#broker","title":"Broker","text":"<p>A Task broker needs to implement three abstract methods <pre><code>  @abstractmethod\n  async def queue_task(self, queued_task: QueuedTask) -&gt; TaskRun:\n      \"\"\"Queue a task\"\"\"\n\n  @abstractmethod\n  async def get_task_run(self) -&gt; Optional[TaskRun]:\n      \"\"\"Get a Task run from the task queue\"\"\"\n\n  @abstractmethod\n  async def queue_length(self) -&gt; Dict[str, int]:\n      \"\"\"Length of task queues\"\"\"\n</code></pre></p> <p>The library ships a Redis broker for convenience.</p> <pre><code>from fluid.scheduler import Broker\n\nredis_broker = Broker.from_url(\"redis://localhost:6349\")\n</code></pre>"}]}